import { __decorate, __awaiter, __param } from 'tslib';
import { ViewContext, EmptyComponent, gettext, AppStateService, RouterService, ActionService, TabsService, RouterModule, HOOK_NAVIGATOR_NODES, HOOK_TABS, HOOK_ACTION_BAR, HOOK_ACTION, HOOK_BREADCRUMB, HOOK_SEARCH, HOOK_DOCS, getActivatedRoute, ActionBarService, WidgetsDashboardComponent, HOOK_COMPONENTS, BootstrapComponent, UserTotpRevokeComponent, DataGridComponent, HOOK_PATTERN_MESSAGES, HeaderService, AlertService, UserMenuService, DocsService, PasswordService, NavigatorNodeRoot } from '@c8y/ngx-components';
import { ReplaySubject, BehaviorSubject, of, combineLatest, from, fromEventPattern, Subject, defer } from 'rxjs';
import { filter, merge, debounceTime, switchMap, startWith, map as map$1 } from 'rxjs/operators';
import { ActivationEnd, Router } from '@angular/router';
import { FetchClient } from '@c8y/client';
import { NgZone, Injectable, NgModule, Optional, ElementRef, Component, ChangeDetectionStrategy, ViewContainerRef, ViewChild, TemplateRef, Inject } from '@angular/core';
import { map, unary, find, forEach, startsWith, get, assign, pick, property, some, every } from 'lodash-es';
import { ContextDashboardService } from '@c8y/ngx-components/context-dashboard';
import { CommonModule } from '@angular/common';
import { TranslateModule, TranslateService } from '@ngx-translate/core';
import { downgradeComponent, downgradeInjectable } from '@angular/upgrade/static';
import { bind, element, module } from 'angular';
import { AppLogsAutoRefreshComponent } from '@c8y/ngx-components/app-logs';
import { ImpactProviderSettingsComponent } from '@c8y/ngx-components/connectivity';
import { ApiService } from '@c8y/ngx-components/api';
import { BulkOperationDetailsService } from '@c8y/ngx-components/operations';

var ViewContextLegacyParameter;
(function (ViewContextLegacyParameter) {
    ViewContextLegacyParameter["Device"] = "deviceId";
    ViewContextLegacyParameter["Group"] = "groupId";
    ViewContextLegacyParameter["User"] = "userId";
    ViewContextLegacyParameter["Application"] = "applicationId";
    ViewContextLegacyParameter["SubscribedApplications"] = "applicationId";
    ViewContextLegacyParameter["Tenant"] = "tenantId";
})(ViewContextLegacyParameter || (ViewContextLegacyParameter = {}));
function c8yViewsProvider($routeProvider, c8yTabsProvider, c8yPathUtils) {
    'ngInject';
    const viewMap = {};
    const contextViews = new ReplaySubject();
    return {
        when,
        $get() {
            return {
                contextViews,
                when(path, cfg) {
                    return when(path, cfg, true);
                },
                getByPath,
                prefixWithSlash
            };
        }
    };
    /**
     * @ngdoc function
     * @name when
     * @methodOf c8y.ui.provider:c8yViewsProvider
     *
     * @description
     * Defines a view for given route.
     * If multiple views are defined for a single route then there will be a separate tab for each view available when user visits that route.
     *
     * @param path Target route.
     * @param cfg View configuration object with the following properties:
     *
     * - **name** - `string` - View's name (in case of multiple views at single route this will be displayed as tab's title).
     * - **priority** - `integer` - View's priority (in case of multiple views at single route this will determine the position of view's tab in the tabs stack).
     * - **icon** - `string` - Font Awesome icon name for the view (displayed on the tab's header).
     * - **showIf** - `function` - Function returning boolean value indicating whether to show a tab for the view or not.
     * - **templateUrl** - `string` - Path to the template to use for displaying the view.
     *
     * You can also provide other view options - the same as available for standard {@link https://docs.angularjs.org/api/ngRoute/provider/$routeProvider $routeProvider} in AngularJS.
     *
     * @example
     * The following example demonstrates how to add a new view to device details route
     * (which will be displayed as a tab if other views are assigned to the same route):
     * <pre>
     *   c8yViewsProvider.when('/device/:deviceId', {
     *     name: 'Tracking',
     *     templateUrl: ':::PLUGIN_PATH:::/views/index.html',
     *     icon: 'crosshairs',
     *     showIf: ['$routeParams', 'c8yDevices', function ($routeParams, c8yDevices) {
     *       var deviceId = $routeParams.deviceId;
     *       return c8yDevices.detailCached(deviceId).then(function (res) {
     *         var device = res.data;
     *         return device && (device.c8y_MotionTracking || device.c8y_Geofence);
     *       });
     *     }]
     *   });
     * </pre>
     */
    function when(path, cfg, runPhase) {
        const newPath = prefixWithSlash(path);
        cfg.resolve = cfg.resolve || {};
        // eslint-disable-next-line no-underscore-dangle
        cfg.resolve.__c8y_locales = [
            'c8yLocales',
            c8yLocales => {
                return c8yLocales.initDone;
            }
        ];
        let currentCfg = viewMap[newPath];
        const originalPath = newPath;
        if (!cfg.name) {
            // console.warn('View name not defined');
        }
        if (!currentCfg) {
            viewMap[newPath] = [];
            currentCfg = viewMap[newPath];
        }
        const upgradedContext = Object.keys(ViewContext)
            .map(key => ({
            key,
            isUpgrade: prefixWithSlash(ViewContext[key].replace('id', ViewContextLegacyParameter[key])) === path
        }))
            .find(({ isUpgrade }) => isUpgrade);
        if (upgradedContext) {
            currentCfg.push(cfg);
            cfg.path = newPath;
            const p = c8yPathUtils.appendSegment(originalPath.replace(path, ''), cfg.name);
            contextViews.next(Object.assign({}, cfg, { path: cfg.name ? p.substring(1) : '', contextKey: upgradedContext.key, runPhase }));
            cfg.showIf = undefined;
            if (cfg.name) {
                cfg.path = c8yPathUtils.appendSegment(originalPath, cfg.name);
            }
        }
        else {
            if (currentCfg.length === 1) {
                const [existingConfig] = currentCfg;
                existingConfig.path = c8yPathUtils.appendSegment(originalPath, existingConfig.name);
                existingConfig.tab = createTab(originalPath, existingConfig);
                $routeProvider.when(existingConfig.path, existingConfig);
            }
            currentCfg.push(cfg);
            cfg.path = newPath;
            if (currentCfg.length > 1) {
                cfg.path = c8yPathUtils.appendSegment(originalPath, cfg.name);
                createTab(originalPath, cfg);
                $routeProvider.when(prefixWithSlash(originalPath), {
                    resolveRedirectTo($route, $q, c8yUiUtil, c8yTabs, gettextCatalog) {
                        'ngInject';
                        const sortedCurrentCfg = c8yTabsProvider.sortTabsViews(currentCfg, gettextCatalog);
                        const params = $route.current.pathParams;
                        return $q
                            .all(map(sortedCurrentCfg, unary(c8yUiUtil.configureVisibility)))
                            .then(views => {
                            const first = find(views, 'show');
                            let url = first.path;
                            forEach(params, (val, key) => {
                                url = url.replace(`:${key}`, val);
                            });
                            c8yTabs.redirectedViewPath = url;
                            return url;
                        });
                    }
                });
            }
        }
        return $routeProvider.when(prefixWithSlash(cfg.path), cfg);
    }
    function getByPath(path) {
        return viewMap[prefixWithSlash(path)];
    }
    function createTab(path, cfg) {
        c8yTabsProvider.addTab(path, cfg);
    }
    function prefixWithSlash(path) {
        const prefix = startsWith(path, '/') ? '' : '/';
        return prefix + path;
    }
}

class BridgeService {
    constructor(injector, appState, fetchClient, router, ngZone, routerService, actionService) {
        this.injector = injector;
        this.appState = appState;
        this.fetchClient = fetchClient;
        this.router = router;
        this.ngZone = ngZone;
        this.routerService = routerService;
        this.actionService = actionService;
        this.$liveTabs = new BehaviorSubject([]);
        this.fixE2eIssues();
        this.$ng1RouteChangeSuccess = this.fromNg1Event(this.injector.get('$rootScope'), '$routeChangeSuccess');
        this.$ng1RouteChangeStart = this.fromNg1Event(this.injector.get('$rootScope'), '$routeChangeStart');
        this.hookAuth();
        this.hookLanguage();
        this.hookTabs();
        this.hookNavigator();
        this.hookUserMenu();
        this.hookViewProvider();
        this.router.initialNavigation();
        this.ng1Routes();
    }
    hookViewProvider() {
        const c8yViews = this.injector.get('c8yViews');
        c8yViews.contextViews.subscribe(cfg => this.addRoute(cfg));
    }
    addRoute(cfg) {
        this.routerService.addRoute({
            label: cfg.label || cfg.name,
            path: cfg.path,
            icon: cfg.icon,
            context: ViewContext[cfg.contextKey],
            priority: cfg.priority,
            component: EmptyComponent,
            data: {
                showIf: cfg.showIf
                    ? ngxRoute => {
                        const params = Object.assign({}, ngxRoute.params, { [ViewContextLegacyParameter[cfg.contextKey]]: ngxRoute.params.id });
                        const showIfResult = this.injector.invoke(cfg.showIf, undefined, {
                            $routeParams: params
                        });
                        // make sure showIf result is a promise with boolean result:
                        return this.injector
                            .get('$q')
                            .when(showIfResult)
                            .then(Boolean);
                    }
                    : undefined
            }
        });
        if (cfg.runPhase) {
            this.routerService.refresh();
        }
    }
    ng1Routes() {
        const template = '';
        const fallbackRoutes = [];
        // tslint:disable-next-line: forin
        for (const context in ViewContext) {
            const path = ViewContext[context].match(/(\w+)\//)[1];
            const regexp = new RegExp(`^/${path}/(?:([^/]+)).*$`);
            fallbackRoutes.push({
                keys: [{ name: ViewContextLegacyParameter[context], optional: false }],
                regexp,
                template
            });
        }
        /**
         * When asset detail routes (/device/:id,  /group/:id) are matched in Angular Router, ngRoute in
         * angular.js must also have matching generic routes so that the ids can be extracted from the paths and
         * injected in multiple calls (showIf, c8yActions, etc) as properties of $routeParams.
         *
         * The function in src/ngRoute/route.js (angular.js) where the routes are matched is called parseRoute(). This
         * function calls angular.forEach and in turn this function checks for the presence of a forEach method before
         * trying object key iteration.
         * By attaching a non enumerable forEach method to the routes object we guarantee that the fallback generic routes
         * are only matched after any other registered through $routeProvider.when.
         */
        const $route = this.injector.get('$route');
        Object.defineProperty($route.routes, 'forEach', {
            // make non enumerable
            value: function forEach(iterator, context) {
                // tslint:disable-next-line: forin
                for (const key in this) {
                    iterator.call(context, this[key], key, this);
                }
                fallbackRoutes.forEach(r => iterator.call(context, r));
            }
        });
        /**
         * Some functions use the current context. As some parts are upgraded and some not, the following updates the
         * angularjs getContext function to resolve always the right context.
         */
        const c8yUiUtil = this.injector.get('c8yUiUtil');
        const _getContext = c8yUiUtil.getContext;
        this.router.events
            .pipe(filter(event => event instanceof ActivationEnd))
            .subscribe((event) => {
            if (event.snapshot.routeConfig.path === '**') {
                c8yUiUtil.getContext = _getContext;
            }
            else if (event.snapshot.data && event.snapshot.data.context) {
                c8yUiUtil.getContext = () => {
                    return {
                        context: event.snapshot.data.context.replace('/:id', ''),
                        id: event.snapshot.data.contextData.id
                    };
                };
            }
            else {
                c8yUiUtil.getContext = () => ({ context: null, id: null });
            }
        });
    }
    fixE2eIssues() {
        try {
            const { ngZone } = this;
            const { Utils } = window.org.cometd;
            const timeoutFn = Utils.setTimeout;
            // tslint:disable-next-line:only-arrow-functions
            Utils.setTimeout = function (...args) {
                return ngZone.runOutsideAngular(() => timeoutFn.apply(Utils, args));
            };
        }
        catch (e) {
            // do nothing
        }
        try {
            const { ace } = window;
            const editFn = ace.edit;
            const { ngZone } = this;
            // tslint:disable-next-line:only-arrow-functions
            ace.edit = function (...args) {
                return ngZone.runOutsideAngular(() => editFn.apply(ace, args));
            };
        }
        catch (e) {
            // do nothing
        }
    }
    setToken(token, tfa, type = 'Basic') {
        const c8yAuth = this.injector.get('c8yAuth');
        if (type === 'Basic') {
            c8yAuth.onSetToken({ token, type });
            if (tfa) {
                c8yAuth.setTFAToken(tfa);
            }
        }
        else {
            c8yAuth.authReady();
        }
    }
    hookAuth() {
        this.appState.currentUser.subscribe(u => {
            if (u) {
                const { headers } = this.fetchClient.getFetchOptions({});
                this.injector.get('c8yAuth').headers = () => this.fetchClient.getFetchOptions({}).headers;
                if (headers.Authorization) {
                    const token = headers.Authorization.match(/basic\s(.*)$/i)[1];
                    if (token) {
                        this.setToken(token, headers.tfatoken);
                    }
                }
                else {
                    this.setToken(undefined, headers.tfatoken, 'Oauth');
                }
                this.injector.get('$rootScope').$emit('authStateChange', { hasAuth: true });
            }
            else {
                this.injector.get('$rootScope').$emit('authStateChange', { hasAuth: false });
            }
        });
    }
    hookLanguage() {
        let first = true;
        this.appState
            .map(store => store.lang)
            .subscribe(lang => {
            this.injector.get('c8yLocales').switchToLanguage(lang);
            if (!first) {
                this.injector.get('$rootScope').$apply();
            }
            first = false;
        });
    }
    hookTabs() {
        // Just for instantiation of the c8yAction service
        this.injector.get('c8yActions');
        const $location = this.injector.get('$location');
        const c8yTabs = this.injector.get('c8yTabs');
        let liveTabs = [];
        c8yTabs.addTab = tab => {
            liveTabs.push(Object.assign({}, tab, { label: tab.label || tab.name, path: decodeURIComponent(tab.path) }));
            this.$liveTabs.next(liveTabs);
        };
        this.$ng1RouteChangeStart.subscribe(e => {
            liveTabs = [];
            this.$liveTabs.next(liveTabs);
        });
        this.$ng1RouteChangeSuccess
            .subscribe(e => {
            const path = $location.path();
            if (this.router.url !== path) {
                this.router.navigate(path.split('/'), {
                    queryParams: $location.search(),
                    skipLocationChange: true
                });
            }
            if (this.actionService) {
                this.actionService.refresh();
            }
        });
        this.$routeChanges = this.$ng1RouteChangeSuccess.pipe(merge(this.fromNg1Event(c8yTabs, c8yTabs.EVENT_UPDATE), of(1)), debounceTime(100));
    }
    hookNavigator() {
        this.navigationNodes$ = this.injector.get('c8yNavigator').rootNodes$;
    }
    getTabs() {
        const onlyVisible = ({ show }) => show;
        const upgradeTab = tab => (Object.assign({}, tab, { label: tab.label || tab.name, path: decodeURIComponent(tab.path) }));
        const routeTabs = this.$routeChanges.pipe(switchMap(() => {
            const routes = this.injector.get('c8yTabs').routeTabs;
            const visibilityPromise = Promise.all(routes.map(({ checkingVisibility }) => checkingVisibility));
            return visibilityPromise.then(() => routes.filter(onlyVisible).map(upgradeTab));
        }), startWith([]));
        return combineLatest(routeTabs, this.$liveTabs).pipe(map$1(([route, live]) => route.concat(live)));
    }
    getQuickLinks() {
        const c8yQuickLinks = this.injector.get('c8yQuickLinks');
        return c8yQuickLinks.list();
    }
    getActionBarItems() {
        const c8yActionBar = this.injector.get('c8yActionBar');
        const $rootScope = this.injector.get('$rootScope');
        const getActionBarElements = () => c8yActionBar.elements.map(element => ({
            priority: element.getAttribute('action-bar-priority') || 0,
            template: element,
            placement: element.getAttribute('action-bar-position') || 'right'
        }));
        return this.fromNg1Event($rootScope, 'c8yActionBarChanged').pipe(startWith(1), map$1(getActionBarElements));
    }
    getBreadcrumbs() {
        const $location = this.injector.get('$location');
        const path = $location.path();
        const c8yBreadcrumbs = this.injector.get('c8yBreadcrumbs');
        const breadcrumbs = c8yBreadcrumbs.get(path) || {};
        const breadcrumbsData = breadcrumbs.data ? this.injector.invoke(breadcrumbs.data) : of([]);
        return from(breadcrumbsData).pipe(map$1((value) => {
            value = value.concat(c8yBreadcrumbs.getLiveBreadcrumbs());
            return value.map(items => ({ items: items.slice(0, items.length - 1) }));
        }));
    }
    getSearch() {
        const c8ySearch = this.injector.get('c8ySearch');
        return c8ySearch.list().map(item => {
            return {
                icon: 'search',
                name: item.name,
                term: '',
                onSearch() {
                    if (this.term) {
                        c8ySearch.search(this.term);
                    }
                }
            };
        });
    }
    getActions() {
        const registeredActions = this.injector.get('c8yActions').registeredActions;
        return of(registeredActions
            .filter(action => !action.hidden)
            .map(action => ({
            // The priority was reversed: Aligned it to dashboard, high first, low last.
            priority: (action.priority || 0) * -1,
            label: action.text,
            icon: action.icon,
            disabled: action.disabled,
            action: () => {
                this.injector.invoke(action.action, action);
            }
        })));
    }
    fromNg1Event(obj, evt) {
        let stopListening;
        function add(handler) {
            stopListening = obj.$on(evt, handler);
        }
        return fromEventPattern(add, () => stopListening());
    }
    hookUserMenu() {
        const userMenuService = this.injector.get('c8yUserMenuService');
        const c8yAccessDenied = this.injector.get('c8yAccessDenied');
        userMenuService.add({
            icon: 'exclamation-triangle',
            priority: 10,
            label: gettext('Access denied requests'),
            click: c8yAccessDenied.showAccessDeniedRequestsList
        });
    }
}
function bridgeServiceFactory(injector, appState, fetchClient, router, ngZone, routerService, actionService) {
    return new BridgeService(injector, appState, fetchClient, router, ngZone, routerService, actionService);
}
const bridgeServiceProvider = {
    provide: BridgeService,
    useFactory: bridgeServiceFactory,
    deps: ['$injector', AppStateService, FetchClient, Router, NgZone, RouterService, ActionService]
};

let Ng1ActionBarFactoryService = class Ng1ActionBarFactoryService {
    constructor(bridge) {
        this.bridge = bridge;
        this.routeChanges$ = bridge.$routeChanges;
    }
    get() {
        return this.bridge.getActionBarItems();
    }
};
Ng1ActionBarFactoryService.ctorParameters = () => [
    { type: BridgeService }
];
Ng1ActionBarFactoryService = __decorate([
    Injectable()
], Ng1ActionBarFactoryService);

let Ng1ActionFactoryService = class Ng1ActionFactoryService {
    constructor(bridge, tabs) {
        this.bridge = bridge;
        this.tabs = tabs;
        this.routeChanges$ = bridge.$routeChanges;
        this.$location = bridge.injector.get('$location');
        this.tabs.items$.subscribe((newTabs) => this.handleTabsRedirect(newTabs));
    }
    handleTabsRedirect(tabs) {
        /**
         * This function is doing the same process as function redirect in the file
         * modules/core/ui/navigation/tabs.provider.js
         * That function  is not run because bridge.service.ts overrides the method addTab where the redirect() was called.
         */
        const redirectedTab = tabs.find((tab) => tab.redirectedTo);
        const [topPriorityTab] = tabs;
        if (redirectedTab && !topPriorityTab.redirectedTo) {
            this.$location.replace();
            this.$location.path(topPriorityTab.path);
            topPriorityTab.redirectedTo = true;
            redirectedTab.redirectedTo = false;
        }
    }
    get() {
        return this.bridge.getActions();
    }
};
Ng1ActionFactoryService.ctorParameters = () => [
    { type: BridgeService },
    { type: TabsService }
];
Ng1ActionFactoryService = __decorate([
    Injectable()
], Ng1ActionFactoryService);

let Ng1BreadcrumbFactoryService = class Ng1BreadcrumbFactoryService {
    constructor(bridge) {
        this.bridge = bridge;
        this.trigger = new ReplaySubject(1);
        this.breadcrumbs = this.trigger.pipe(debounceTime(100), switchMap(() => {
            return this.bridge.getBreadcrumbs();
        }));
    }
    get() {
        this.trigger.next();
        return this.breadcrumbs;
    }
};
Ng1BreadcrumbFactoryService.ctorParameters = () => [
    { type: BridgeService }
];
Ng1BreadcrumbFactoryService = __decorate([
    Injectable()
], Ng1BreadcrumbFactoryService);

let Ng1NodesFactoryService = class Ng1NodesFactoryService {
    constructor(bridge) {
        this.bridge = bridge;
    }
    get() {
        return this.bridge.navigationNodes$;
    }
};
Ng1NodesFactoryService.ctorParameters = () => [
    { type: BridgeService }
];
Ng1NodesFactoryService = __decorate([
    Injectable()
], Ng1NodesFactoryService);

let Ng1SearchFactoryService = class Ng1SearchFactoryService {
    constructor(bridge) {
        this.bridge = bridge;
        this.search = this.bridge.getSearch();
    }
    get() {
        return this.search;
    }
};
Ng1SearchFactoryService.ctorParameters = () => [
    { type: BridgeService }
];
Ng1SearchFactoryService = __decorate([
    Injectable()
], Ng1SearchFactoryService);

let Ng1TabsFactoryService = class Ng1TabsFactoryService {
    constructor(bridge) {
        this.bridge = bridge;
        this.tabsObservable = bridge.getTabs();
    }
    get() {
        return this.tabsObservable;
    }
};
Ng1TabsFactoryService.ctorParameters = () => [
    { type: BridgeService }
];
Ng1TabsFactoryService = __decorate([
    Injectable()
], Ng1TabsFactoryService);

let Ng1DocsFactoryService = class Ng1DocsFactoryService {
    constructor(bridge) {
        this.bridge = bridge;
        this.links = this.bridge.getQuickLinks();
        this.links.then(list => {
            list.map(el => {
                el.type = el.type || 'quicklink';
                return el;
            });
        });
    }
    get() {
        return this.links;
    }
};
Ng1DocsFactoryService.ctorParameters = () => [
    { type: BridgeService }
];
Ng1DocsFactoryService = __decorate([
    Injectable()
], Ng1DocsFactoryService);

let UpgradeModule = class UpgradeModule {
};
UpgradeModule = __decorate([
    NgModule({
        imports: [RouterModule],
        exports: [],
        providers: [
            bridgeServiceProvider,
            { provide: HOOK_NAVIGATOR_NODES, useClass: Ng1NodesFactoryService, multi: true },
            { provide: HOOK_TABS, useClass: Ng1TabsFactoryService, multi: true },
            { provide: HOOK_ACTION_BAR, useClass: Ng1ActionBarFactoryService, multi: true },
            { provide: HOOK_ACTION, useClass: Ng1ActionFactoryService, multi: true },
            { provide: HOOK_BREADCRUMB, useClass: Ng1BreadcrumbFactoryService, multi: true },
            { provide: HOOK_SEARCH, useClass: Ng1SearchFactoryService, multi: true },
            { provide: HOOK_DOCS, useClass: Ng1DocsFactoryService, multi: true }
        ]
    })
], UpgradeModule);

let DashboardBridgeService = class DashboardBridgeService {
    constructor(ng1Injector, zone, router, contextDashboardService, actionBarService) {
        this.ng1Injector = ng1Injector;
        this.zone = zone;
        this.router = router;
        this.contextDashboardService = contextDashboardService;
        this.actionBarService = actionBarService;
        this.dashboardSvc = ng1Injector.get('dashboardSvc');
        this.compile = ng1Injector.get('$compile');
    }
    get ng1Components() {
        return this.ng1Injector.get('c8yComponents');
    }
    instantiateComponent(widget, element) {
        return __awaiter(this, void 0, void 0, function* () {
            const { dashboard, context, child } = widget;
            if (dashboard) {
                const transformedChild = yield this.dashboardSvc.transformChildWithContext(this.dashboardSvc.forcedContext || context, dashboard, child);
                if (this.dashboardSvc.forcedContext || dashboard.deviceType) {
                    yield this.dashboardSvc.updateConfigTargetsWithContext(this.dashboardSvc.forcedContext || context, transformedChild.config);
                }
                return this.zone.runOutsideAngular(() => this.loadTemplate(transformedChild, child, element, context));
            }
            else {
                return this.loadConfigTemplate(element, widget);
            }
        });
    }
    editDashboard(dashboard) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.dashboardSvc.editCurrentDashboard({ dashboardId: dashboard.id });
        });
    }
    copyDashboard() {
        const dashboard = this.getDashboard();
        const couldCopy = this.dashboardSvc.copyDashboard(dashboard.c8y_Dashboard);
        if (couldCopy) {
            this.dashboardClipboard = dashboard;
            this.actionBarService.refresh();
            return dashboard;
        }
    }
    pasteDashboard() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const newDashboard = yield this.dashboardSvc.pasteDashboard();
                this.navigateToDashboard(newDashboard);
                this.dashboardClipboard = undefined;
            }
            catch (ex) {
                // intended empty
            }
            this.actionBarService.refresh();
        });
    }
    instantiateDeviceSelector(element, widgetConfig) {
        return this.loadConfigTemplate(element, widgetConfig, true);
    }
    loadTemplate(transformedChild, child, element, context) {
        const scope = this.ng1Injector.get('$rootScope').$new(true);
        scope.child = transformedChild;
        scope.dashboardContext = context;
        if (child.widgetComponent) {
            element.innerHTML = `<c8y-ui-component component-name="'${child.widgetComponent}'" config="child.config" context="dashboardContext"></c8y-ui-component>`;
        }
        else if (child.templateUrl) {
            element.innerHTML = `<ng-include src="'${child.templateUrl}'"></ng-include>`;
        }
        this.compile(element)(scope);
        return scope;
    }
    navigateToDashboard(dashboard) {
        if (/dashboard/.test(this.router.url)) {
            this.router.navigate(['..', dashboard.id], {
                relativeTo: getActivatedRoute(this.router)
            });
        }
        else {
            this.router.navigate(['..', 'dashboard', dashboard.id], {
                relativeTo: getActivatedRoute(this.router)
            });
        }
    }
    getDashboard() {
        return getActivatedRoute(this.router).snapshot.data.dashboard;
    }
    loadConfigTemplate(element, widgetConfig, onlyDeviceSelector = false) {
        const { settings } = widgetConfig;
        const scope = this.ng1Injector.get('$rootScope').$new(true);
        scope.settings = Object.assign({}, settings, settings.ng1);
        scope.options = widgetConfig.options;
        scope.config = widgetConfig;
        scope.forms = {};
        scope.rootId = settings.context.id;
        scope.dashboard = get(widgetConfig, 'settings.dashboardMo');
        let configCmp = '';
        if (!onlyDeviceSelector) {
            if (widgetConfig.settings.configComponent) {
                configCmp = `<c8y-ui-component component-name="'${widgetConfig.settings.configComponent}'" config="config"></c8y-ui-component>`;
            }
            else if (widgetConfig.settings.configTemplateUrl) {
                configCmp = `<ng-include src="'${widgetConfig.settings.configTemplateUrl}'"></ng-include>`;
            }
        }
        element.innerHTML = `
    <ng-form name="forms.componentForm">
      <div class="form-group"
        ng-if="!settings.noDeviceTarget"
        ng-style="{height: settings.hideTarget && '0', overflow: 'hidden'}"
      >
        <label translate>${gettext('Target assets or devices')}</label>
        <c8y-device-selector-combo parent="rootId"
          selected-child-device="config.device"
          groups-selectable="settings.groupsSelectable"
        ></c8y-device-selector-combo>
      </div>
      ${configCmp}
    </ng-form>`;
        scope.$watch('forms.componentForm.$invalid', formStatus => {
            this.contextDashboardService.formDisabled = formStatus;
        });
        this.compile(element)(scope);
        this.contextDashboardService.formDisabled = scope.forms.componentForm.$invalid;
        return scope;
    }
};
DashboardBridgeService.ctorParameters = () => [
    { type: undefined },
    { type: NgZone },
    { type: Router },
    { type: ContextDashboardService },
    { type: ActionBarService }
];
DashboardBridgeService = __decorate([
    Injectable()
], DashboardBridgeService);

let WidgetComponent = class WidgetComponent {
    constructor(dashboard, dashboardBridgeService, el) {
        this.dashboard = dashboard;
        this.dashboardBridgeService = dashboardBridgeService;
        this.el = el;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.ng1Scope = yield this.dashboardBridgeService.instantiateComponent(this.config, this.el.nativeElement);
            if (this.dashboard) {
                this.resizeSubscription = this.dashboard.onChangeDashboard.subscribe(() => {
                    this.ng1Scope.$broadcast('dashboardResize');
                });
            }
        });
    }
    ngOnDestroy() {
        if (this.ng1Scope) {
            this.ng1Scope.$destroy();
        }
        if (this.resizeSubscription) {
            this.resizeSubscription.unsubscribe();
        }
    }
};
WidgetComponent.ctorParameters = () => [
    { type: WidgetsDashboardComponent, decorators: [{ type: Optional }] },
    { type: DashboardBridgeService },
    { type: ElementRef }
];
WidgetComponent = __decorate([
    Component({
        selector: 'c8y-widget-legacy',
        template: '',
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __param(0, Optional())
], WidgetComponent);

let DeviceSelectorComponent = class DeviceSelectorComponent {
    constructor(dashboardBridgeService, el) {
        this.dashboardBridgeService = dashboardBridgeService;
        this.el = el;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.ng1Scope = this.dashboardBridgeService.instantiateDeviceSelector(this.el.nativeElement, this.config);
        });
    }
    ngOnDestroy() {
        if (this.ng1Scope) {
            this.ng1Scope.$destroy();
        }
    }
};
DeviceSelectorComponent.ctorParameters = () => [
    { type: DashboardBridgeService },
    { type: ElementRef }
];
DeviceSelectorComponent = __decorate([
    Component({
        selector: 'c8y-device-selector-legacy',
        template: '',
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], DeviceSelectorComponent);

let Ng1ComponentFactoryService = class Ng1ComponentFactoryService {
    constructor(bridge) {
        this.bridge = bridge;
    }
    get() {
        return __awaiter(this, void 0, void 0, function* () {
            const components = (yield this.bridge.ng1Components.list()).map(cmp => {
                const data = {
                    settings: Object.assign({}, cmp.options, { configTemplateUrl: cmp.configTemplateUrl, widgetComponent: cmp.widgetComponent, configComponent: cmp.configComponent, transformConfigWithContext: cmp.transformConfigWithContext || cmp.componentTransformConfigWithContext, upgrade: true })
                };
                data.settings.templateUrl = cmp.templateUrl; // workaround as in object it creates build error
                return {
                    id: cmp.name,
                    label: cmp.nameDisplay || cmp.name,
                    description: cmp.description,
                    component: WidgetComponent,
                    configComponent: WidgetComponent,
                    previewImage: cmp.previewImage,
                    data
                };
            });
            // add the device selector legacy component
            components.push({
                id: 'device.selector.legacy',
                label: 'Device selector',
                description: '',
                data: { settings: { noNewWidgets: true, upgrade: true } },
                component: DeviceSelectorComponent
            });
            return components;
        });
    }
};
Ng1ComponentFactoryService.ctorParameters = () => [
    { type: DashboardBridgeService }
];
Ng1ComponentFactoryService = __decorate([
    Injectable()
], Ng1ComponentFactoryService);

let CopyActionComponent = class CopyActionComponent {
    constructor(vcRef, dashboardBridgeService) {
        this.vcRef = vcRef;
        this.dashboardBridgeService = dashboardBridgeService;
    }
    ngOnInit() {
        this.vcRef.createEmbeddedView(this.templateCopy);
    }
    copyDashboard() {
        this.dashboardBridgeService.copyDashboard();
    }
};
CopyActionComponent.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: DashboardBridgeService }
];
__decorate([
    ViewChild('templateCopy', { read: TemplateRef, static: true })
], CopyActionComponent.prototype, "templateCopy", void 0);
CopyActionComponent = __decorate([
    Component({
        selector: 'c8y-copy-action-legacy',
        template: `
    <ng-template #templateCopy>
      <li>
        <button title="{{'Copy dashboard' | translate}}" (click)="copyDashboard()">
          <i class="fa fw fa-clone"></i>&nbsp;<span translate>Copy dashboard</span>
        </button>
      </li>
    </ng-template>
  `
    })
], CopyActionComponent);

let PasteActionComponent = class PasteActionComponent {
    constructor(vcRef, dashboardBridgeService) {
        this.vcRef = vcRef;
        this.dashboardBridgeService = dashboardBridgeService;
        this.dashboardName = '';
    }
    ngOnInit() {
        this.vcRef.createEmbeddedView(this.templatePaste);
        this.dashboardName = this.dashboardBridgeService.dashboardClipboard.c8y_Dashboard.name;
    }
    pasteDashboard() {
        this.dashboardBridgeService.pasteDashboard();
    }
};
PasteActionComponent.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: DashboardBridgeService }
];
__decorate([
    ViewChild('templatePaste', { read: TemplateRef, static: true })
], PasteActionComponent.prototype, "templatePaste", void 0);
PasteActionComponent = __decorate([
    Component({
        selector: 'c8y-paste-action-legacy',
        template: `
    <ng-template #templatePaste>
      <li>
        <button title="{{'Paste dashboard' | translate}}" (click)="pasteDashboard()">
          <i class="fa fw fa-clipboard"></i>&nbsp;<span translate>Paste dashboard</span>&nbsp;<span
            >"{{ dashboardName }}"</span
          >
        </button>
      </li>
    </ng-template>
  `
    })
], PasteActionComponent);

let Ng1DashboardActionFactoryService = class Ng1DashboardActionFactoryService {
    constructor(dashboardBridgeService) {
        this.dashboardBridgeService = dashboardBridgeService;
    }
    get(activeRoute) {
        const actions = [];
        const data = !activeRoute.parent || activeRoute.snapshot.data.context
            ? activeRoute.snapshot.data
            : activeRoute.parent.snapshot.data;
        const { contextData } = data;
        const isDashboard = contextData && activeRoute.snapshot.data.dashboard;
        const canPaste = contextData &&
            [ViewContext.Device, ViewContext.Group].includes(data.context) &&
            this.dashboardBridgeService.dashboardClipboard;
        if (isDashboard) {
            actions.push({
                priority: -20,
                placement: 'more',
                template: CopyActionComponent
            });
        }
        if (canPaste) {
            actions.push({
                priority: -10,
                placement: 'more',
                template: PasteActionComponent
            });
        }
        return actions;
    }
};
Ng1DashboardActionFactoryService.ctorParameters = () => [
    { type: DashboardBridgeService }
];
Ng1DashboardActionFactoryService = __decorate([
    Injectable()
], Ng1DashboardActionFactoryService);

let DashboardUpgradeModule = class DashboardUpgradeModule {
};
DashboardUpgradeModule = __decorate([
    NgModule({
        declarations: [DeviceSelectorComponent, WidgetComponent, CopyActionComponent, PasteActionComponent],
        entryComponents: [DeviceSelectorComponent, WidgetComponent, CopyActionComponent, PasteActionComponent],
        imports: [CommonModule, TranslateModule],
        providers: [
            {
                provide: DashboardBridgeService,
                useFactory: dashboardBridgeFactory,
                deps: ['$injector', NgZone, Router, [new Optional(), ContextDashboardService], ActionBarService]
            },
            { provide: HOOK_COMPONENTS, useClass: Ng1ComponentFactoryService, multi: true },
            { provide: HOOK_ACTION_BAR, useClass: Ng1DashboardActionFactoryService, multi: true }
        ]
    })
], DashboardUpgradeModule);
function dashboardBridgeFactory(injector, ngZone, router, contextDashboardService, actionBarService) {
    return new DashboardBridgeService(injector, ngZone, router, contextDashboardService, actionBarService);
}

function c8yAlertDecorator($delegate, $rootScope, $injector) {
    'ngInject';
    $delegate.add = (alert) => {
        $delegate.addAlert(transformAlert(alert));
    };
    $rootScope.$on('alert', (evt, alert) => {
        $delegate.addAlert(transformAlert(alert));
    });
    $rootScope.$on('message', (evt, alert) => {
        $delegate.addAlert(transformAlert(alert));
    });
    for (const property in $delegate) {
        if (typeof $delegate[property] === 'function') {
            $delegate[property] = $delegate[property].bind($delegate);
        }
    }
    function transformAlert(alert) {
        const newAlert = Object.assign({}, alert);
        if (alert.onClose) {
            newAlert.onClose = () => {
                $injector.invoke(alert.onClose);
            };
        }
        if (alert.onDetail) {
            newAlert.onDetail = () => {
                $injector.invoke(alert.onDetail);
            };
        }
        return newAlert;
    }
    return $delegate;
}

const bootstrapComponent = downgradeComponent({ component: BootstrapComponent });
const userTotpComponent = downgradeComponent({ component: UserTotpRevokeComponent });
const appLogsAutoRefreshComponent = downgradeComponent({
    component: AppLogsAutoRefreshComponent
});
const dataGridComponent = downgradeComponent({ component: DataGridComponent });
const impactProviderSettingsComponent = downgradeComponent({
    component: ImpactProviderSettingsComponent
});

let ServerMessagesService = class ServerMessagesService {
    constructor(translateService, patterns) {
        this.translateService = translateService;
        this.MESSAGE_PATTERNS = patterns;
    }
    translate(s) {
        return this.translateService.instant(s);
    }
};
ServerMessagesService.ctorParameters = () => [
    { type: TranslateService },
    { type: undefined, decorators: [{ type: Inject, args: [HOOK_PATTERN_MESSAGES,] }] }
];
ServerMessagesService = __decorate([
    Injectable(),
    __param(1, Inject(HOOK_PATTERN_MESSAGES))
], ServerMessagesService);

const bridgeService = downgradeInjectable(BridgeService);
const appStateService = downgradeInjectable(AppStateService);
const headerService = downgradeInjectable(HeaderService);
const alertsService = downgradeInjectable(AlertService);
const userMenuService = downgradeInjectable(UserMenuService);
const apiService = downgradeInjectable(ApiService);
const docsService = downgradeInjectable(DocsService);
const passwordService = downgradeInjectable(PasswordService);
const translateService = downgradeInjectable(TranslateService);
const serverMessagesService = downgradeInjectable(ServerMessagesService);
const bulkOperationDetailsService = downgradeInjectable(BulkOperationDetailsService);

function gettextCatalogDecorator($delegate, $interpolate, c8yTranslate) {
    'ngInject';
    const gettextCatalog = $delegate;
    const originalGetString = bind(gettextCatalog, gettextCatalog.getString);
    function newGetString(input, scope, context) {
        if (typeof input === 'string') {
            const translatedString = originalGetString(input, scope, context);
            const interpolatedString = scope ? $interpolate(input)(scope) : input;
            let stringToReturn = translatedString;
            if (translatedString && translatedString === interpolatedString) {
                const translatedServerMessage = c8yTranslate.instant(interpolatedString);
                stringToReturn = translatedServerMessage;
            }
            return stringToReturn;
        }
        return input;
    }
    gettextCatalog.getString = newGetString;
    return gettextCatalog;
}

function groupTypesHierarchyNavigatorDecorator($delegate, $q) {
    'ngInject';
    $delegate.loadAll = () => $q.when();
    $delegate.addGroupNavigation = () => $q.when();
    return $delegate;
}

function c8yNg1HttpInterceptor($q, c8yLoadingIndicator, c8yApiService) {
    'ngInject';
    function request(config) {
        const { url, method } = config;
        c8yApiService.onStart({ url, method, options: config });
        return config;
    }
    function requestError(rejection) {
        finishRequest(rejection);
        return $q.reject(rejection);
    }
    function response(res) {
        finishRequest(res);
        return res;
    }
    function responseError(rejection) {
        finishRequest(rejection);
        c8yLoadingIndicator.responseError(rejection);
        return $q.reject(rejection);
    }
    function finishRequest(res) {
        const { url, method } = res.config;
        c8yApiService.onFinish({
            url,
            method,
            response: res,
            options: res.config
        });
    }
    return {
        request,
        requestError,
        response,
        responseError
    };
}

class NavigatorNodeRootLegacy extends NavigatorNodeRoot {
    addRoot(nodeData) {
        let duplicate;
        if (nodeData.path === '') {
            nodeData.path = '/';
        }
        nodeData.label = nodeData.name;
        if (typeof nodeData.parent === 'object') {
            nodeData.parent.label = nodeData.parent.name;
        }
        if (nodeData.preventDuplicates) {
            duplicate = this.find(({ path, parents, label }) => {
                return path === nodeData.path &&
                    (label === nodeData.label) &&
                    parents.some((p) => p.label === nodeData.parent);
            });
            if (duplicate) {
                duplicate.routerLinkExact = false;
            }
        }
        return duplicate || super.addRoot(nodeData);
    }
    createNode(node) {
        const newNode = super.createNode(node);
        const update = newNode.update.bind(newNode);
        const root = this;
        return Object.defineProperties(assign(newNode, {
            realName: newNode.name || newNode.label,
            _parent: true,
            update(data) {
                if (this._parent === undefined) {
                    // _parent was deleted somene instead to put this in root
                    root.addRoot(this);
                    // put it back so it can be deleted again
                    this._parent = true;
                }
                update(data);
            },
            addChild(nodeChild) {
                this.add(root.createNode(nodeChild));
            }
        }), {
            label: {
                get() {
                    return this.realName || '';
                },
                set(name) {
                    this.realName = name;
                }
            },
            name: {
                get() {
                    return this.realName || '';
                },
                set(name) {
                    this.realName = name;
                }
            },
            show: {
                get() {
                    return !this.hidden;
                },
                set(show) {
                    this.hidden = !show;
                }
            }
        });
    }
}

// Just to hook into the bridge service
function c8yNavigatorProvider() {
    const root = new NavigatorNodeRootLegacy();
    const rootNodesSubject = new Subject();
    const conditionalNodes = [];
    const rootNodes$ = rootNodesSubject.pipe(merge(defer(() => of(root.children))));
    function addNavigation(nodes) {
        const nodeList = (Array.isArray(nodes) ? nodes : [nodes]);
        nodeList.forEach((node) => {
            if (isConditional(node)) {
                node.hidden = undefined;
                conditionalNodes.push(node);
            }
            node.navNode = root.addRoot(node);
        });
        rootNodesSubject.next(root.children);
    }
    function removeNavigation(node) {
        const found = root.find((n) => n === node);
        if (found) {
            found.parents.forEach((p) => p.remove(found));
            rootNodesSubject.next(root.children);
        }
    }
    function findNode(node) {
        return root.find(node);
    }
    function isConditional(node) {
        return node.showIf || node.showIfPermissions || node.showIfContainsVisibleViews;
    }
    function $get($q, $injector) {
        'ngInject';
        // This avoids the circular dependency
        setTimeout(() => conditionalNodes.forEach(processShowIf));
        function processShowIf(node) {
            const c8yUiUtil = $injector.get('c8yUiUtil');
            const visibilityPromises = [];
            const { showIf, showIfPermissions, showIfContainsVisibleViews } = node;
            if (showIf) {
                visibilityPromises.push($injector.invoke(showIf));
            }
            if (showIfContainsVisibleViews) {
                visibilityPromises.push(viewsConditionalVisibility(node));
            }
            c8yUiUtil.configureVisibility({
                showIf: () => $q.all(visibilityPromises).then(every),
                showIfPermissions
            }, 'visible')
                .then(({ visible }) => {
                if (visible) {
                    node.navNode.update({
                        hidden: false,
                        showIf: null,
                        showIfPermission: null,
                        showIfContainsVisibleViews: null
                    });
                }
                else {
                    node.navNode.update({
                        hidden: true
                    });
                }
            });
        }
        function viewsConditionalVisibility(node) {
            const c8yUiUtil = $injector.get('c8yUiUtil');
            const c8yViews = $injector.get('c8yViews');
            const views = c8yViews.getByPath(node.path);
            return $q.all(map(views, (view) => c8yUiUtil
                .configureVisibility(pick(view, ['showIf', 'showIfPermissions']), 'show', false)
                .then(property('show'))))
                .then(some);
        }
        return {
            rootNodes() {
                return root.children;
            },
            findNode,
            addNavigation,
            removeNavigation,
            rootNodes$
        };
    }
    return {
        $get,
        addNavigation,
        removeNavigation
    };
}

const rootComponent = {
    template: `
  <c8y-bootstrap>
    <div id="c8y-legacy-view">
      <div ng-view ng-if="vm.widthSet && vm.authState.hasAuth"></div>
    </div>
  </c8y-bootstrap>`,
    controller: c8yUiRootController,
    controllerAs: 'vm'
};
function c8yUiRootController($rootScope, $timeout, c8yBase, c8yNavigator, c8yApplication, c8yHeaderService) {
    'ngInject';
    const vm = this;
    Object.assign(vm, {
        $onInit,
        navOpen: false
    });
    ////////////
    function $onInit() {
        c8yHeaderService.map((states) => states.nav.open).subscribe((isOpen) => {
            vm.navOpen = isOpen;
        });
        c8yHeaderService.configNavigator({ canToggle: true });
        $rootScope.$on('authStateChange', onAuthStateChange);
        vm.rootNodes = c8yNavigator.rootNodes;
        c8yApplication.currentAppCached().then(onAppInfo);
        vm.navHiddenOnStartup = c8yBase.appOption('hide_navigator');
        checkReady();
    }
    function onAuthStateChange(evt, data) {
        vm.authState = data;
    }
    function onAppInfo() {
        vm.tabsHorizontal = c8yBase.appOption('tabsHorizontal');
    }
    function checkReady() {
        const element = document.querySelector('#c8y-legacy-view');
        const hasWidth = element && element.clientWidth;
        if (hasWidth) {
            vm.widthSet = true;
        }
        else {
            $timeout(checkReady);
        }
    }
}

function c8yTitleDecorator($q, $delegate, $injector, $rootScope, $location, $templateCache, $compile, c8yHeaderService) {
    'ngInject';
    $delegate.changeTitle = changeTitle;
    $delegate.setTitleElement = setTitleElement;
    $rootScope.$on('$routeChangeStart', () => {
        changeTitle({});
    });
    $rootScope.$on('$routeChangeSuccess', (event) => {
        const title = $delegate.get($location.path());
        if (title) {
            const titleData = $q.when(title.data ? $injector.invoke(title.data) : {});
            titleData.then((data) => {
                const { templateUrl } = data;
                if (templateUrl) {
                    const template = $templateCache.get(templateUrl);
                    setTitleElement($compile(template)(event.targetScope));
                }
                else {
                    changeTitle(data);
                }
            });
        }
    });
    function changeTitle(newTitle) {
        $q.when(newTitle).then((title) => changeTitleInAngular(translate(title)));
    }
    function translate({ title, subtitle }) {
        const isolatedScope = $rootScope.$new(true);
        isolatedScope.title = title;
        isolatedScope.subtitle = subtitle;
        return $compile(element(`
      <h1 class="text-truncate">{{title | translate}}
      <small>{{ subtitle | translate }}</small></h1>
    `))(isolatedScope)[0];
    }
    function changeTitleInAngular(domElement) {
        c8yHeaderService.changeTitle(domElement);
    }
    function setTitleElement($element) {
        $element.show();
        changeTitleInAngular($element[0]);
    }
    return $delegate;
}

const NAME = 'c8y.upgrade';
window.preventNg1Bootstrap = true;
module(NAME, [])
    .config($httpProvider => {
    'ngInject';
    const ng1InterceptorIndex = $httpProvider.interceptors.indexOf('c8yLoadingIndicator');
    if (ng1InterceptorIndex > -1) {
        $httpProvider.interceptors.splice(ng1InterceptorIndex, 1);
    }
    $httpProvider.interceptors.push(c8yNg1HttpInterceptor);
})
    .component('c8yUiRoot', rootComponent)
    .directive('c8yBootstrap', bootstrapComponent)
    .factory('c8yBridgeService', bridgeService)
    .factory('c8yAppStateService', appStateService)
    .factory('c8yHeaderService', headerService)
    .factory('c8yUserMenuService', userMenuService)
    .decorator('c8yTitle', c8yTitleDecorator)
    .factory('c8yAlert', alertsService)
    .decorator('c8yAlert', c8yAlertDecorator)
    .decorator('groupTypesHierarchyNavigator', groupTypesHierarchyNavigatorDecorator) // prevents loading the groups
    .factory('c8yApiService', apiService)
    .factory('c8yDocs', docsService)
    .service('c8yPasswordConfirm', passwordService);
module('c8y.ui')
    .provider('c8yNavigator', c8yNavigatorProvider)
    .provider('c8yViews', c8yViewsProvider)
    .directive('c8yUserTotpRevoke', userTotpComponent)
    .directive('c8yAppLogsAutoRefresh', appLogsAutoRefreshComponent)
    .directive('c8yImpactProviderSettings', impactProviderSettingsComponent)
    .directive('c8yDataGrid', dataGridComponent)
    .factory('c8yTranslate', translateService)
    .factory('c8yBulkOperationDetailsService', bulkOperationDetailsService)
    .decorator('gettextCatalog', gettextCatalogDecorator)
    .factory('c8yServerMessages', serverMessagesService)
    .factory('ngZone', downgradeInjectable(NgZone));
const ng1Modules = ['app', NAME];

class HybridAppModule {
    constructor() {
        this.ng1Modules = ng1Modules;
    }
    ngDoBootstrap() {
        window.bootstrap();
        this.upgrade.bootstrap(document.getElementById('app'), this.ng1Modules, { strictDi: false });
    }
}

const UPGRADE_ROUTES = [
    { path: '**', component: EmptyComponent }
];

/**
 * Generated bundle index. Do not edit.
 */

export { BridgeService, DashboardBridgeService, DashboardUpgradeModule, HybridAppModule, UPGRADE_ROUTES, UpgradeModule, ng1Modules, bridgeServiceFactory as a, bridgeServiceProvider as b, dashboardBridgeFactory as c, Ng1NodesFactoryService as d, Ng1TabsFactoryService as e, Ng1ActionBarFactoryService as f, Ng1ActionFactoryService as g, Ng1BreadcrumbFactoryService as h, Ng1SearchFactoryService as i, Ng1DocsFactoryService as j, DeviceSelectorComponent as k, WidgetComponent as l, CopyActionComponent as m, PasteActionComponent as n, Ng1ComponentFactoryService as o, Ng1DashboardActionFactoryService as p };
//# sourceMappingURL=c8y-ngx-components-upgrade.js.map
