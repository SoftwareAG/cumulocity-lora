import { __decorate, __param, __awaiter } from 'tslib';
import { ElementRef, Injector, Input, Directive, ViewChild, forwardRef, Component, Inject, Injectable, EventEmitter, Output, NgModule } from '@angular/core';
import { FilteringFormRendererContext, CellRendererContext, gettext, FilteringActionType, DataGridComponent, CommonModule, FormsModule, DeviceStatusModule, DataGridModule } from '@c8y/ngx-components';
import { AssetSelectorModule } from '@c8y/ngx-components/assets-navigator';
import { QueriesUtil, InventoryService } from '@c8y/client';
import { TranslateService } from '@ngx-translate/core';
import { cloneDeep, get, map, sortBy, remove, transform, identity, assign, forEach } from 'lodash-es';
import { UpgradeComponent } from '@angular/upgrade/static';

// TODO: MTM-31785: find replacement for schema-form ng1 library
let SchemaFormComponent = class SchemaFormComponent extends UpgradeComponent {
    constructor(elementRef, injector) {
        super('c8ySchemaForm', elementRef, injector);
    }
};
SchemaFormComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Injector }
];
__decorate([
    Input()
], SchemaFormComponent.prototype, "schema", void 0);
__decorate([
    Input()
], SchemaFormComponent.prototype, "model", void 0);
__decorate([
    Input('form')
], SchemaFormComponent.prototype, "inputForm", void 0);
__decorate([
    Input('options')
], SchemaFormComponent.prototype, "inputOptions", void 0);
SchemaFormComponent = __decorate([
    Directive({
        selector: 'c8y-schema-form'
    })
], SchemaFormComponent);

let BaseFilteringFormRendererComponent = class BaseFilteringFormRendererComponent {
    constructor(context) {
        this.context = context;
    }
    ngOnInit() {
        const column = this.context.property;
        this.schema = cloneDeep(column.filteringConfig.schema);
        this.form = cloneDeep(column.filteringConfig.form);
        this.model = cloneDeep(column.externalFilterQuery || {});
        this.options = { formDefaults: { ngModelOptions: { debounce: 100 } } };
    }
    canApply() {
        return get(this.schemaFormComponent, '$componentScope.vm.ngForm.$invalid');
    }
    applyFilter() {
        this.context.applyFilter({
            externalFilterQuery: this.model
        });
    }
    resetFilter() {
        this.context.resetFilter();
    }
};
BaseFilteringFormRendererComponent.ctorParameters = () => [
    { type: FilteringFormRendererContext }
];
__decorate([
    ViewChild(forwardRef(() => SchemaFormComponent), { static: false })
], BaseFilteringFormRendererComponent.prototype, "schemaFormComponent", void 0);
BaseFilteringFormRendererComponent = __decorate([
    Component({
        template: "<c8y-schema-form\n  [schema]=\"schema\"\n  [form]=\"form\"\n  [model]=\"model\"\n  [options]=\"options\"\n></c8y-schema-form>\n<div class=\"data-grid__dropdown__footer d-flex separator-top\">\n  <button\n    class=\"btn btn-default btn-sm m-r-8 flex-grow\"\n    (click)=\"resetFilter()\"\n    title=\"{{ 'Reset' | translate }}\"\n    translate\n  >\n    Reset\n  </button>\n\n  <button\n    class=\"btn btn-primary btn-sm flex-grow\"\n    (click)=\"applyFilter()\"\n    [disabled]=\"canApply()\"\n    title=\"{{ 'Apply' | translate }}\"\n    translate\n  >\n    Apply\n  </button>\n</div>\n"
    })
], BaseFilteringFormRendererComponent);

class BaseDeviceGridColumn {
    constructor() {
        this.filteringFormRendererComponent = BaseFilteringFormRendererComponent;
    }
}

let AlarmsCellRendererComponent = class AlarmsCellRendererComponent {
    constructor(context, deviceGridService) {
        this.context = context;
        this.deviceGridService = deviceGridService;
    }
};
AlarmsCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext },
    { type: DeviceGridService, decorators: [{ type: Inject, args: [forwardRef(() => DeviceGridService),] }] }
];
AlarmsCellRendererComponent = __decorate([
    Component({
        template: "<a [href]=\"deviceGridService.getAlarmsHref(context.item)\" class=\"listLink\">\n  <small\n    class=\"status critical\"\n    *ngIf=\"context.item.c8y_ActiveAlarmsStatus?.critical\"\n    style=\"white-space: nowrap;\"\n  >\n    {{ context.item.c8y_ActiveAlarmsStatus?.critical }} <i [c8yIcon]=\"'warning'\"></i>\n  </small>\n  <small\n    class=\"status major\"\n    *ngIf=\"context.item.c8y_ActiveAlarmsStatus?.major\"\n    style=\"white-space: nowrap;\"\n  >\n    {{ context.item.c8y_ActiveAlarmsStatus?.major }}\n    <i [c8yIcon]=\"'exclamation-circle'\"></i>\n  </small>\n  <small\n    class=\"status minor\"\n    *ngIf=\"context.item.c8y_ActiveAlarmsStatus?.minor\"\n    style=\"white-space: nowrap;\"\n  >\n    {{ context.item.c8y_ActiveAlarmsStatus?.minor }}\n    <i [c8yIcon]=\"'exclamation-circle'\"></i>\n  </small>\n  <small\n    class=\"status warning\"\n    *ngIf=\"context.item.c8y_ActiveAlarmsStatus?.warning\"\n    style=\"white-space: nowrap;\"\n  >\n    {{ context.item.c8y_ActiveAlarmsStatus?.warning }} <i [c8yIcon]=\"'circle'\"></i>\n  </small>\n</a>\n"
    }),
    __param(1, Inject(forwardRef(() => DeviceGridService)))
], AlarmsCellRendererComponent);

class AlarmsDeviceGridColumn extends BaseDeviceGridColumn {
    constructor() {
        super();
        this.name = 'alarms';
        this.header = gettext('Alarms');
        this.cellRendererComponent = AlarmsCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    critical: {
                        type: 'boolean'
                    },
                    major: {
                        type: 'boolean'
                    },
                    minor: {
                        type: 'boolean'
                    },
                    warning: {
                        type: 'boolean'
                    },
                    none: {
                        type: 'boolean'
                    }
                }
            },
            form: [
                {
                    type: 'template',
                    template: `<label><span translate>${gettext('Show devices with active')}</span>:</label>`
                },
                {
                    key: 'critical',
                    title: gettext('Critical alarms')
                },
                {
                    key: 'major',
                    title: gettext('Major alarms')
                },
                {
                    key: 'minor',
                    title: gettext('Minor alarms')
                },
                {
                    key: 'warning',
                    title: gettext('Warnings')
                },
                {
                    key: 'none',
                    title: gettext('No alarms')
                }
            ],
            getFilter(model) {
                const filter = {};
                const ors = [];
                if (model.critical) {
                    ors.push({ 'c8y_ActiveAlarmsStatus.critical': { __gt: 0 } });
                }
                if (model.major) {
                    ors.push({ 'c8y_ActiveAlarmsStatus.major': { __gt: 0 } });
                }
                if (model.minor) {
                    ors.push({ 'c8y_ActiveAlarmsStatus.minor': { __gt: 0 } });
                }
                if (model.warning) {
                    ors.push({ 'c8y_ActiveAlarmsStatus.warning': { __gt: 0 } });
                }
                if (model.none) {
                    ors.push({ __not: { __has: 'c8y_ActiveAlarmsStatus' } });
                    ors.push({
                        __and: map(['critical', 'major', 'minor', 'warning'], sev => {
                            const zero = {};
                            const has = { __not: { __has: undefined } };
                            const key = `c8y_ActiveAlarmsStatus.${sev}`;
                            zero[key] = 0;
                            has.__not.__has = key;
                            return { __or: [zero, has] };
                        })
                    });
                }
                if (ors.length) {
                    filter.__or = ors;
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [
                { path: 'c8y_ActiveAlarmsStatus.critical' },
                { path: 'c8y_ActiveAlarmsStatus.major' },
                { path: 'c8y_ActiveAlarmsStatus.minor' },
                { path: 'c8y_ActiveAlarmsStatus.warning' }
            ]
        };
    }
}

let GroupCellRendererComponent = class GroupCellRendererComponent {
    constructor(context, deviceGridService) {
        this.context = context;
        this.deviceGridService = deviceGridService;
    }
};
GroupCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext },
    { type: DeviceGridService, decorators: [{ type: Inject, args: [forwardRef(() => DeviceGridService),] }] }
];
GroupCellRendererComponent = __decorate([
    Component({
        template: "<span\n  title=\"{{\n    deviceGridService.getParentsNames(\n      context.item,\n      context.property.externalFilterQuery?.deviceGroupId\n    )\n  }}\"\n  class=\"text-truncate\"\n>\n  {{\n    deviceGridService.getParentsNames(\n      context.item,\n      context.property.externalFilterQuery?.deviceGroupId\n    )\n  }}\n</span>\n"
    }),
    __param(1, Inject(forwardRef(() => DeviceGridService)))
], GroupCellRendererComponent);

let GroupFilteringFormRendererComponent = class GroupFilteringFormRendererComponent {
    constructor(context) {
        this.context = context;
        this.preselected = [];
    }
    ngOnInit() {
        const column = this.context.property;
        this.model = cloneDeep(column.externalFilterQuery || {});
        this.preselected = this.model.selectedNodes || [];
    }
    applyFilter() {
        this.context.applyFilter({
            externalFilterQuery: this.model
        });
    }
    resetFilter() {
        this.context.resetFilter();
    }
    selectionChanged(nodes) {
        this.model.selectedNodes = nodes;
    }
};
GroupFilteringFormRendererComponent.ctorParameters = () => [
    { type: FilteringFormRendererContext }
];
GroupFilteringFormRendererComponent = __decorate([
    Component({
        template: "<c8y-asset-selector\n  [selected]=\"preselected\"\n  (onChange)=\"selectionChanged($event)\"\n></c8y-asset-selector>\n\n<div class=\"data-grid__dropdown__footer d-flex separator-top\">\n  <button\n    class=\"btn btn-default btn-sm m-r-8 flex-grow\"\n    (click)=\"resetFilter()\"\n    title=\"{{ 'Reset' | translate }}\"\n    translate\n  >\n    Reset\n  </button>\n\n  <button\n    class=\"btn btn-primary btn-sm flex-grow\"\n    (click)=\"applyFilter()\"\n    title=\"{{ 'Apply' | translate }}\"\n    translate\n  >\n    Apply\n  </button>\n</div>\n"
    })
], GroupFilteringFormRendererComponent);

class GroupDeviceGridColumn extends BaseDeviceGridColumn {
    constructor() {
        super();
        this.name = 'group';
        this.header = gettext('Group');
        this.cellRendererComponent = GroupCellRendererComponent;
        this.filteringFormRendererComponent = GroupFilteringFormRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            getFilter(model) {
                const filter = {};
                if (model.selectedNodes) {
                    filter.__or = model.selectedNodes.map((mo) => {
                        if (mo.c8y_DeviceQueryString) {
                            return { __useFilterQueryString: mo.c8y_DeviceQueryString };
                        }
                        return { __bygroupid: mo.id };
                    });
                }
                return filter;
            }
        };
        this.sortable = false;
    }
}

class ImeiDeviceGridColumn extends BaseDeviceGridColumn {
    constructor() {
        super();
        const self = this;
        this.path = 'c8y_Mobile.imei';
        this.name = 'imei';
        this.header = gettext('IMEI');
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    imeis: {
                        type: 'array',
                        items: {
                            type: 'string'
                        }
                    }
                }
            },
            form: [
                {
                    key: 'imeis',
                    title: gettext('Show devices with IMEI'),
                    add: gettext('Or'),
                    items: [
                        {
                            key: 'imeis[]',
                            notitle: true,
                            placeholder: gettext('e.g. 46543432321, you can use an asterisk (*) as wildcard character')
                        }
                    ]
                }
            ],
            getFilter(model) {
                const filter = {};
                if (model.imeis.length) {
                    filter[self.path] = { __in: model.imeis };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

let ModelCellRendererComponent = class ModelCellRendererComponent {
    constructor(context, deviceGridService) {
        this.context = context;
        this.deviceGridService = deviceGridService;
    }
};
ModelCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext },
    { type: DeviceGridService, decorators: [{ type: Inject, args: [forwardRef(() => DeviceGridService),] }] }
];
ModelCellRendererComponent = __decorate([
    Component({
        template: `
    {{ deviceGridService.getModel(context.item) }}
  `
    }),
    __param(1, Inject(forwardRef(() => DeviceGridService)))
], ModelCellRendererComponent);

class ModelDeviceGridColumn extends BaseDeviceGridColumn {
    constructor() {
        super();
        const hardwareModelPath = 'c8y_Hardware.model';
        const vendingModelPath = 'com_nsn_startups_vendme_fragments_VendingMachineTypeInfo.model';
        this.name = 'model';
        this.header = gettext('Model');
        this.cellRendererComponent = ModelCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    models: {
                        type: 'array',
                        items: {
                            type: 'string'
                        }
                    }
                }
            },
            form: [
                {
                    key: 'models',
                    title: gettext('Show devices with model'),
                    add: gettext('Or'),
                    items: [
                        {
                            key: 'models[]',
                            notitle: true,
                            placeholder: gettext('e.g. ModelName, you can use an asterisk (*) as wildcard character')
                        }
                    ]
                }
            ],
            getFilter(model) {
                const filter = {};
                if (model.models.length) {
                    filter.__or = {
                        [hardwareModelPath]: { __in: model.models },
                        [vendingModelPath]: { __in: model.models }
                    };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: hardwareModelPath }, { path: vendingModelPath }]
        };
    }
}

let NameCellRendererComponent = class NameCellRendererComponent {
    constructor(context, deviceGridService) {
        this.context = context;
        this.deviceGridService = deviceGridService;
    }
};
NameCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext },
    { type: DeviceGridService, decorators: [{ type: Inject, args: [forwardRef(() => DeviceGridService),] }] }
];
NameCellRendererComponent = __decorate([
    Component({
        template: `
    <a
      [href]="deviceGridService.getDeviceHref(context.item)"
      title="{{ deviceGridService.getProperName(context.item) }}"
      class="interact"
    >
      {{ deviceGridService.getProperName(context.item) }}
    </a>
  `
    }),
    __param(1, Inject(forwardRef(() => DeviceGridService)))
], NameCellRendererComponent);

class NameDeviceGridColumn extends BaseDeviceGridColumn {
    constructor() {
        super();
        this.name = 'name';
        this.path = 'name';
        this.header = gettext('Name');
        this.cellCSSClassName = "data-record-header" /* Header */;
        this.cellRendererComponent = NameCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    names: {
                        type: 'array',
                        items: {
                            type: 'string'
                        }
                    }
                }
            },
            form: [
                {
                    key: 'names',
                    title: gettext('Show devices with name'),
                    add: gettext('Or'),
                    items: [
                        {
                            key: 'names[]',
                            notitle: true,
                            placeholder: gettext('e.g. My Device, you can use an asterisk (*) as wildcard character')
                        }
                    ]
                }
            ],
            getFilter(model) {
                const filter = {};
                if (model.names.length) {
                    filter.name = { __in: model.names };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

let RegistrationDateCellRendererComponent = class RegistrationDateCellRendererComponent {
    constructor(context) {
        this.context = context;
    }
};
RegistrationDateCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext }
];
RegistrationDateCellRendererComponent = __decorate([
    Component({
        template: `
    {{ context.value | c8yDate }}
  `
    })
], RegistrationDateCellRendererComponent);

class RegistrationDateDeviceGridColumn extends BaseDeviceGridColumn {
    constructor() {
        super();
        const self = this;
        this.path = 'creationTime';
        this.name = 'registrationDate';
        this.header = gettext('Registration date');
        this.cellRendererComponent = RegistrationDateCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    registrationDate: {
                        type: 'object',
                        properties: {
                            after: {
                                type: 'string',
                                format: 'datetime'
                            },
                            before: {
                                type: 'string',
                                format: 'datetime'
                            }
                        }
                    }
                }
            },
            form: [
                {
                    key: 'registrationDate.after',
                    title: gettext('Show devices registered after'),
                    maxDateKey: 'registrationDate.before'
                },
                {
                    key: 'registrationDate.before',
                    title: gettext('And before`date`'),
                    minDateKey: 'registrationDate.after'
                }
            ],
            getFilter(model) {
                const filter = {};
                const dates = model && model.registrationDate;
                if (dates && (dates.after || dates.before)) {
                    filter.__and = [];
                    if (dates.after) {
                        const after = self.formatDate(dates.after);
                        filter.__and.push({
                            __or: {
                                [self.path]: { __gt: after },
                                [`${self.path}.date`]: { __gt: after }
                            }
                        });
                    }
                    if (dates.before) {
                        const before = self.formatDate(dates.before);
                        filter.__and.push({
                            __or: {
                                [self.path]: { __lt: before },
                                [`${self.path}.date`]: { __lt: before }
                            }
                        });
                    }
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: `${this.path}.date` }, { path: this.path }]
        };
    }
    formatDate(dateToFormat) {
        return new Date(dateToFormat).toISOString();
    }
}

let SerialNumberCellRendererComponent = class SerialNumberCellRendererComponent {
    constructor(context, deviceGridService) {
        this.context = context;
        this.deviceGridService = deviceGridService;
    }
};
SerialNumberCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext },
    { type: DeviceGridService, decorators: [{ type: Inject, args: [forwardRef(() => DeviceGridService),] }] }
];
SerialNumberCellRendererComponent = __decorate([
    Component({
        template: `
    {{ deviceGridService.getSerialNumber(context.item) }}
  `
    }),
    __param(1, Inject(forwardRef(() => DeviceGridService)))
], SerialNumberCellRendererComponent);

class SerialNumberDeviceGridColumn extends BaseDeviceGridColumn {
    constructor() {
        super();
        const hardwareSerialNumberPath = 'c8y_Hardware.serialNumber';
        const vendingSerialNumberPath = 'com_nsn_startups_vendme_fragments_VendingMachineTypeInfo.serial';
        this.name = 'serialNumber';
        this.header = gettext('Serial number');
        this.cellRendererComponent = SerialNumberCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    serialNumbers: {
                        type: 'array',
                        items: {
                            type: 'string'
                        }
                    }
                }
            },
            form: [
                {
                    key: 'serialNumbers',
                    title: gettext('Show devices with serial number'),
                    add: gettext('Or'),
                    items: [
                        {
                            key: 'serialNumbers[]',
                            notitle: true,
                            placeholder: gettext('e.g. 54321-123, you can use an asterisk (*) as wildcard character')
                        }
                    ]
                }
            ],
            getFilter(model) {
                const filter = {};
                if (model.serialNumbers.length) {
                    filter.__or = {
                        [hardwareSerialNumberPath]: { __in: model.serialNumbers },
                        [vendingSerialNumberPath]: { __in: model.serialNumbers }
                    };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: hardwareSerialNumberPath }, { path: vendingSerialNumberPath }]
        };
    }
}

let StatusCellRendererComponent = class StatusCellRendererComponent {
    constructor(context) {
        this.context = context;
    }
};
StatusCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext }
];
StatusCellRendererComponent = __decorate([
    Component({
        template: `
    <device-status [mo]="context.item"></device-status>
  `
    })
], StatusCellRendererComponent);

class StatusDeviceGridColumn extends BaseDeviceGridColumn {
    constructor() {
        super();
        const availabilityStatusPath = 'c8y_Availability.status';
        const requiredAvailabilityPath = 'c8y_RequiredAvailability';
        const connectionStatusPath = 'c8y_Connection.status';
        this.name = 'status';
        this.header = gettext('Status');
        this.dataType = "icon" /* Icon */;
        this.cellRendererComponent = StatusCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    sendOnline: {
                        type: 'boolean'
                    },
                    sendOffline: {
                        type: 'boolean'
                    },
                    sendUnknown: {
                        type: 'boolean'
                    },
                    sendNotMonitored: {
                        type: 'boolean'
                    },
                    pushOnline: {
                        type: 'boolean'
                    },
                    pushOffline: {
                        type: 'boolean'
                    },
                    pushUnknown: {
                        type: 'boolean'
                    },
                    maintenance: {
                        type: 'boolean'
                    }
                }
            },
            form: [
                {
                    type: 'template',
                    template: `<label><span translate>${gettext('Show devices with send status')}</span>:</label>`
                },
                {
                    key: 'sendOnline',
                    title: gettext('Online')
                },
                {
                    key: 'sendOffline',
                    title: gettext('Offline')
                },
                {
                    key: 'sendUnknown',
                    title: gettext('Unknown')
                },
                {
                    key: 'sendNotMonitored',
                    title: gettext('Not monitored')
                },
                {
                    type: 'template',
                    template: `<label><span translate>${gettext('Show devices with push status')}</span>:</label>`
                },
                {
                    key: 'pushOnline',
                    title: gettext('Online')
                },
                {
                    key: 'pushOffline',
                    title: gettext('Offline')
                },
                {
                    key: 'pushUnknown',
                    title: gettext('Not monitored')
                },
                {
                    type: 'template',
                    template: `<label><span translate>${gettext('Show devices with maintenance status')}</span>:</label>`
                },
                {
                    key: 'maintenance',
                    title: gettext('Device is under maintenance')
                }
            ],
            getFilter(model) {
                const filter = {};
                const ors = [];
                const sendIns = [];
                const pushIns = [];
                if (model) {
                    if (model.sendOnline) {
                        sendIns.push('AVAILABLE');
                    }
                    if (model.maintenance) {
                        sendIns.push('MAINTENANCE');
                    }
                    if (model.sendOffline) {
                        sendIns.push('UNAVAILABLE');
                    }
                    if (model.sendUnknown) {
                        ors.push({
                            __and: [
                                { __not: { __has: availabilityStatusPath } },
                                { __has: requiredAvailabilityPath }
                            ]
                        });
                    }
                    if (model.sendNotMonitored) {
                        ors.push({
                            __and: [
                                { __not: { __has: availabilityStatusPath } },
                                { __not: { __has: requiredAvailabilityPath } }
                            ]
                        });
                    }
                    if (model.pushOnline) {
                        pushIns.push('CONNECTED');
                    }
                    if (model.pushOffline) {
                        pushIns.push('DISCONNECTED');
                    }
                    if (model.pushUnknown) {
                        ors.push({
                            __not: { __has: connectionStatusPath }
                        });
                    }
                    if (sendIns.length) {
                        ors.push({ [availabilityStatusPath]: { __in: sendIns } });
                    }
                    if (pushIns.length) {
                        ors.push({ [connectionStatusPath]: { __in: pushIns } });
                    }
                    if (ors.length) {
                        filter.__or = ors;
                    }
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: availabilityStatusPath }]
        };
    }
}

class SystemIdDeviceGridColumn extends BaseDeviceGridColumn {
    constructor() {
        super();
        const self = this;
        this.path = 'id';
        this.name = 'systemId';
        this.header = gettext('System ID');
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    ids: {
                        type: 'array',
                        items: {
                            type: 'string'
                        }
                    }
                }
            },
            form: [
                {
                    key: 'ids',
                    title: gettext('Show devices with system ID'),
                    add: gettext('Or'),
                    items: [
                        {
                            key: 'ids[]',
                            notitle: true,
                            placeholder: gettext('e.g. 10300, you can use an asterisk (*) as wildcard character')
                        }
                    ]
                }
            ],
            getFilter(model) {
                const filter = {};
                if (model.ids.length) {
                    filter[self.path] = { __in: model.ids };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

let DeviceGridService = class DeviceGridService {
    constructor(inventoryService, translateService) {
        this.inventoryService = inventoryService;
        this.translateService = translateService;
        this.queriesUtil = new QueriesUtil();
    }
    getDefaultColumns() {
        return [
            new StatusDeviceGridColumn(),
            new NameDeviceGridColumn(),
            new ModelDeviceGridColumn(),
            new SerialNumberDeviceGridColumn(),
            new GroupDeviceGridColumn(),
            new RegistrationDateDeviceGridColumn(),
            new SystemIdDeviceGridColumn(),
            new ImeiDeviceGridColumn(),
            new AlarmsDeviceGridColumn()
        ];
    }
    getDefaultPagination() {
        return {
            pageSize: 10,
            currentPage: 1
        };
    }
    getInfiniteScrollPagination() {
        return {
            pageSize: 50,
            currentPage: 1
        };
    }
    getDefaultActionControls() {
        return [
            {
                type: "DELETE" /* Delete */,
                callback: (item) => this.delete(item)
            }
        ];
    }
    getDefaultBulkActionControls() {
        return [];
    }
    getProperName(device) {
        const { id, name } = device;
        return name ? name : this.translateService.instant('Device {{id}}', { id });
    }
    getModel(device) {
        const hardware = this.getHardware(device);
        return hardware && hardware.model;
    }
    getSerialNumber(device) {
        const hardware = this.getHardware(device);
        const serialPropertyName = this.isVendme(device) ? 'serial' : 'serialNumber';
        return hardware && hardware[serialPropertyName];
    }
    getParentsNames(device, featuredParentId) {
        const assetParentsReferences = device.assetParents.references;
        const assetParents = map(assetParentsReferences, 'managedObject');
        const sortedByName = sortBy(assetParents, ['name']);
        const featuredItems = remove(sortedByName, { id: featuredParentId });
        const items = featuredItems.concat(sortedByName);
        const names = map(items, 'name');
        return names.join(', ');
    }
    getDeviceHref(device) {
        return `#/device/${device.id}`;
    }
    getAlarmsHref(device) {
        return `${this.getDeviceHref(device)}/alarms`;
    }
    delete(device) {
        console.log('should delete', device);
    }
    getDevices(columns, pagination) {
        return __awaiter(this, void 0, void 0, function* () {
            const filters = Object.assign({}, this.getDevicesFilters(columns, pagination), { withParents: true });
            return this.inventoryService.list(filters);
        });
    }
    getDevicesCount(columns, pagination) {
        return __awaiter(this, void 0, void 0, function* () {
            const filters = Object.assign({}, this.getDevicesFilters(columns, pagination), { pageSize: 1, currentPage: 1 });
            return (yield this.inventoryService.list(filters)).paging.totalPages;
        });
    }
    getDevicesTotal() {
        return __awaiter(this, void 0, void 0, function* () {
            const filters = {
                q: '',
                pageSize: 1,
                withTotalPages: true
            };
            return (yield this.inventoryService.list(filters)).paging.totalPages;
        });
    }
    getDeviceQueryString(columns) {
        return this.queriesUtil.buildQuery(this.getQueryObj(columns));
    }
    getHardware(device) {
        const hardwarePropertyName = this.isVendme(device)
            ? 'com_nsn_startups_vendme_fragments_VendingMachineTypeInfo'
            : 'c8y_Hardware';
        return device && device[hardwarePropertyName];
    }
    isVendme(device) {
        return device.type === 'com_nsn_startups_vendme_VendingMachine';
    }
    getDevicesFilters(columns, pagination) {
        return {
            q: this.getDeviceQueryString(columns),
            pageSize: pagination.pageSize,
            currentPage: pagination.currentPage,
            withTotalPages: true
        };
    }
    getQueryObj(columns) {
        return transform(columns, (query, column) => this.extendQueryByColumn(query, column), {
            __filter: {},
            __orderby: []
        });
    }
    extendQueryByColumn(query, column) {
        if (column.filterable && column.externalFilterQuery) {
            const getFilter = column.filteringConfig.getFilter || identity;
            const queryObj = getFilter(column.externalFilterQuery);
            if (queryObj.__or) {
                query.__filter.__and = query.__filter.__and || [];
                query.__filter.__and.push(queryObj);
            }
            else if (queryObj.__and && get(query, '__filter.__and')) {
                queryObj.__and.map(obj => query.__filter.__and.push(obj));
            }
            else {
                assign(query.__filter, queryObj);
            }
        }
        if (column.sortable && column.sortOrder) {
            const cs = {};
            forEach(column.sortingConfig.pathSortingConfigs, pathSortingConfig => {
                cs[pathSortingConfig.path] =
                    (column.sortOrder === 'asc' ? 1 : -1) * (pathSortingConfig.sortOrderModifier || 1);
            });
            query.__orderby.push(cs);
        }
        return query;
    }
};
DeviceGridService.ctorParameters = () => [
    { type: InventoryService },
    { type: TranslateService }
];
DeviceGridService = __decorate([
    Injectable()
], DeviceGridService);

let DeviceGridComponent = class DeviceGridComponent {
    constructor(deviceGridService) {
        this.deviceGridService = deviceGridService;
        this.title = gettext('Devices');
        this.loadMoreItemsLabel = gettext('Load more devices');
        this.loadingItemsLabel = gettext('Loading devices…');
        this.noMatchingItemsLabel = gettext('No matching devices.');
        this.selectable = false;
        this.onColumnsChange = new EventEmitter();
        this.onDeviceQueryStringChange = new EventEmitter();
        this.columns = this.deviceGridService.getDefaultColumns();
        this.pagination = this.deviceGridService.getDefaultPagination();
        this.actionControls = this.deviceGridService.getDefaultActionControls();
        this.bulkActionControls = this.deviceGridService.getDefaultBulkActionControls();
        this.serverSideDataCallback = this.onDataSourceModifier.bind(this);
    }
    set _columns(value) {
        if (value) {
            this.columns = value;
        }
        else {
            this.columns = this.deviceGridService.getDefaultColumns();
        }
    }
    set _pagination(value) {
        if (value) {
            this.pagination = value;
        }
        else {
            this.pagination = this.deviceGridService.getDefaultPagination();
        }
    }
    set _infiniteScroll(infiniteScroll) {
        this.infiniteScroll = infiniteScroll;
        this.pagination = this.deviceGridService.getInfiniteScrollPagination();
    }
    set _actionControls(value) {
        if (value) {
            this.actionControls = value;
        }
        else {
            this.actionControls = this.deviceGridService.getDefaultActionControls();
        }
    }
    set _bulkActionControls(value) {
        if (value) {
            this.bulkActionControls = value;
        }
        else {
            this.bulkActionControls = this.deviceGridService.getDefaultBulkActionControls();
        }
    }
    trackByName(_index, column) {
        return column.name;
    }
    onDataSourceModifier(dataSourceModifier) {
        return __awaiter(this, void 0, void 0, function* () {
            const { res, data, paging } = yield this.deviceGridService.getDevices(dataSourceModifier.columns, dataSourceModifier.pagination);
            const filteredSize = yield this.deviceGridService.getDevicesCount(dataSourceModifier.columns, dataSourceModifier.pagination);
            const size = yield this.deviceGridService.getDevicesTotal();
            this.onColumnsChange.emit(dataSourceModifier.columns);
            this.onDeviceQueryStringChange.emit(this.deviceGridService.getDeviceQueryString(dataSourceModifier.columns));
            return {
                res,
                data,
                paging,
                filteredSize,
                size
            };
        });
    }
    updateFiltering(columnNames, action) {
        const { type } = action;
        if (type === FilteringActionType.ResetFilter) {
            this.dataGrid.clearFilters();
        }
        else {
            this.dataGrid.updateFiltering(columnNames, action);
        }
    }
};
DeviceGridComponent.ctorParameters = () => [
    { type: DeviceGridService }
];
__decorate([
    Input()
], DeviceGridComponent.prototype, "title", void 0);
__decorate([
    Input()
], DeviceGridComponent.prototype, "loadMoreItemsLabel", void 0);
__decorate([
    Input()
], DeviceGridComponent.prototype, "loadingItemsLabel", void 0);
__decorate([
    Input()
], DeviceGridComponent.prototype, "noMatchingItemsLabel", void 0);
__decorate([
    Input('columns')
], DeviceGridComponent.prototype, "_columns", null);
__decorate([
    Input('pagination')
], DeviceGridComponent.prototype, "_pagination", null);
__decorate([
    Input('infiniteScroll')
], DeviceGridComponent.prototype, "_infiniteScroll", null);
__decorate([
    Input('actionControls')
], DeviceGridComponent.prototype, "_actionControls", null);
__decorate([
    Input()
], DeviceGridComponent.prototype, "selectable", void 0);
__decorate([
    Input('bulkActionControls')
], DeviceGridComponent.prototype, "_bulkActionControls", null);
__decorate([
    Output()
], DeviceGridComponent.prototype, "onColumnsChange", void 0);
__decorate([
    Output()
], DeviceGridComponent.prototype, "onDeviceQueryStringChange", void 0);
__decorate([
    ViewChild(DataGridComponent, { static: true })
], DeviceGridComponent.prototype, "dataGrid", void 0);
DeviceGridComponent = __decorate([
    Component({
        selector: 'c8y-device-grid',
        template: "<c8y-data-grid\n  [title]=\"title\"\n  [loadMoreItemsLabel]=\"loadMoreItemsLabel\"\n  [loadingItemsLabel]=\"loadingItemsLabel\"\n  [noMatchingItemsLabel]=\"noMatchingItemsLabel\"\n  [columns]=\"columns\"\n  [pagination]=\"pagination\"\n  [infiniteScroll]=\"infiniteScroll\"\n  [actionControls]=\"actionControls\"\n  [selectable]=\"selectable\"\n  [bulkActionControls]=\"bulkActionControls\"\n  [serverSideDataCallback]=\"serverSideDataCallback\"\n>\n  <ng-container *ngFor=\"let column of columns; trackBy: trackByName\">\n    <c8y-column [name]=\"column.name\"></c8y-column>\n  </ng-container>\n</c8y-data-grid>\n"
    })
], DeviceGridComponent);

let DeviceGridModule = class DeviceGridModule {
};
DeviceGridModule = __decorate([
    NgModule({
        imports: [CommonModule, FormsModule, DeviceStatusModule, DataGridModule, AssetSelectorModule],
        declarations: [
            DeviceGridComponent,
            BaseFilteringFormRendererComponent,
            GroupFilteringFormRendererComponent,
            StatusCellRendererComponent,
            NameCellRendererComponent,
            ModelCellRendererComponent,
            SerialNumberCellRendererComponent,
            GroupCellRendererComponent,
            RegistrationDateCellRendererComponent,
            AlarmsCellRendererComponent,
            SchemaFormComponent
        ],
        exports: [
            DeviceGridComponent,
            BaseFilteringFormRendererComponent,
            GroupFilteringFormRendererComponent,
            StatusCellRendererComponent,
            NameCellRendererComponent,
            ModelCellRendererComponent,
            SerialNumberCellRendererComponent,
            GroupCellRendererComponent,
            RegistrationDateCellRendererComponent,
            AlarmsCellRendererComponent,
            SchemaFormComponent
        ],
        entryComponents: [
            DeviceGridComponent,
            BaseFilteringFormRendererComponent,
            GroupFilteringFormRendererComponent,
            StatusCellRendererComponent,
            NameCellRendererComponent,
            ModelCellRendererComponent,
            SerialNumberCellRendererComponent,
            GroupCellRendererComponent,
            RegistrationDateCellRendererComponent,
            AlarmsCellRendererComponent
        ],
        providers: [DeviceGridService]
    })
], DeviceGridModule);

class TypeDeviceGridColumn extends BaseDeviceGridColumn {
    constructor() {
        super();
        this.name = 'type';
        this.path = 'type';
        this.header = gettext('Type');
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    types: {
                        type: 'array',
                        items: {
                            type: 'string'
                        }
                    }
                }
            },
            form: [
                {
                    key: 'types',
                    title: gettext('Show devices with type'),
                    add: gettext('Or'),
                    items: [
                        {
                            key: 'types[]',
                            notitle: true,
                            placeholder: gettext('e.g. MyType, you can use an asterisk (*) as wildcard character')
                        }
                    ]
                }
            ],
            getFilter(model) {
                const filter = {};
                if (model.types.length) {
                    filter.type = { __in: model.types };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = { pathSortingConfigs: [{ path: 'type' }] };
    }
}

class CustomDeviceGridColumn extends BaseDeviceGridColumn {
    constructor() {
        super();
        const self = this;
        this.name = 'custom';
        this.header = gettext('Custom');
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    exists: {
                        type: 'boolean',
                        default: false,
                        title: gettext('Only rows where value is defined')
                    },
                    equals: {
                        type: 'array',
                        items: {
                            type: 'string'
                        }
                    }
                }
            },
            form: [
                {
                    key: 'exists'
                },
                {
                    key: 'equals',
                    title: gettext('Only rows where value equals to:'),
                    add: gettext('Or'),
                    items: [
                        {
                            key: 'equals[]',
                            notitle: true,
                            placeholder: gettext('e.g. value, you can use an asterisk (*) as wildcard character')
                        }
                    ]
                }
            ],
            getFilter(model) {
                const filter = {};
                if (model.exists) {
                    filter.__has = self.path;
                }
                if (model.equals) {
                    filter[self.path] = { __in: model.equals };
                }
                return filter;
            }
        };
        this.sortable = true;
    }
    get sortingConfig() {
        return {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { AlarmsDeviceGridColumn, BaseDeviceGridColumn, CustomDeviceGridColumn, DeviceGridComponent, DeviceGridModule, DeviceGridService, GroupDeviceGridColumn, ImeiDeviceGridColumn, ModelDeviceGridColumn, NameDeviceGridColumn, RegistrationDateDeviceGridColumn, SerialNumberDeviceGridColumn, StatusDeviceGridColumn, SystemIdDeviceGridColumn, TypeDeviceGridColumn, BaseFilteringFormRendererComponent as ɵa, SchemaFormComponent as ɵb, GroupFilteringFormRendererComponent as ɵc, StatusCellRendererComponent as ɵd, NameCellRendererComponent as ɵe, ModelCellRendererComponent as ɵf, SerialNumberCellRendererComponent as ɵg, GroupCellRendererComponent as ɵh, RegistrationDateCellRendererComponent as ɵi, AlarmsCellRendererComponent as ɵj };
//# sourceMappingURL=c8y-ngx-components-device-grid.js.map
