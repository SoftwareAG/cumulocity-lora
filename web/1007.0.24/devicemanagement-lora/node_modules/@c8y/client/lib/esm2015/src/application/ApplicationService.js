var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Service } from '../core';
import { TenantService } from '../tenant';
import { UserService } from '../user';
import { ApplicationBinaryService } from './ApplicationBinaryService';
import { ApplicationType } from './ApplicationType';
export class ApplicationService extends Service {
    constructor() {
        super(...arguments);
        this.baseUrl = 'application';
        this.listUrl = 'applications';
        this.propertyName = 'applications';
        this.channel = '/applications/*';
    }
    /**
     * Creates a new application.
     *
     * @param {IIdentified} entity Application object.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *  const newApp = {
     *    name: 'New application',
     *    type: 'EXTERNAL',
     *    key: 'new-app'
     *  };
     *
     *  (async () => {
     *    const {data, res} = await applicationService.create(newApp);
     *  })();
     * ```
     */
    create(entity) {
        const _super = Object.create(null, {
            create: { get: () => super.create }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return _super.create.call(this, entity);
        });
    }
    clone(entity) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.getDetailUrl(entity)}/clone`;
            const method = 'POST';
            const body = '';
            const headers = { 'content-type': 'application/json', accept: 'application/json' };
            const res = yield this.fetch(url, { method, body, headers });
            const data = yield res.json();
            return { res, data };
        });
    }
    /**
     * Gets the list of existing applications filtered by parameters.
     *
     * @returns Response wrapped in [[IResultList]]
     *
     * @param {object} filter Object containing filters for querying applications.
     *
     * @example
     * ```typescript
     *
     *  const filter: object = {
     *     pageSize: 100,
     *     withTotalPages: true
     *   };
     *
     *   (async () => {
     *     const {data, res, paging} = await applicationService.list(filter);
     *   })();
     * ```
     */
    list(filter = {}) {
        const _super = Object.create(null, {
            list: { get: () => super.list }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return _super.list.call(this, filter);
        });
    }
    /**
     * Gets a list as observable.
     *
     * @param {object} filter Object containing filters for querying
     * @param {object} options To configure the observable
     *
     * @returns Data wrapped as [[ObservableList]]
     *
     * @example
     * ```typescript
     *
     *   const list$ = alarmService.list$();
     *   list$.subscribe((data) => console.log(data));
     * ```
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use [[Realtime]] for realtime connection and
     * rxjs `defer()` or `from()` to composite an observable on your own.
     */
    list$(filter = {}, options = {}) {
        return super.list$(filter, options);
    }
    /**
     * Gets the details of selected application.
     *
     * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *    const applicationId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await applicationService.detail(applicationId);
     *   })();
     * ```
     */
    detail(entityOrId) {
        const _super = Object.create(null, {
            detail: { get: () => super.detail }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return _super.detail.call(this, entityOrId);
        });
    }
    /**
     * Updates existing application.
     * Make sure that you specifiy the application id within the update object.
     *
     * @param {IIdentified} entity Application object.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *  const updateApp = {
     *    id: 38
     *    name: 'Updated application'
     *  };
     *
     *  (async () => {
     *    const {data, res} = await applicationService.update(updateApp);
     *  })();
     * ```
     */
    update(entity) {
        const _super = Object.create(null, {
            update: { get: () => super.update }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return _super.update.call(this, entity);
        });
    }
    /**
     * Removes an application with given id.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {string | number | IIdentified} entityOrId entity or id of the application.
     *
     * @example
     * ```typescript
     *
     *  const removeApp: object = {
     *     id: 38
     *   };
     *
     *   (async () => {
     *     const {data, res} = await applicationService.delete(removeApp);
     *     // data will be null
     *   })();
     * ```
     */
    delete(entityOrId) {
        const _super = Object.create(null, {
            delete: { get: () => super.delete }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return _super.delete.call(this, entityOrId);
        });
    }
    listByName(name) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = { 'content-type': 'application/json' };
            const url = `applicationsByName/${encodeURIComponent(name)}`;
            const res = yield this.fetch(url, { headers });
            const json = yield res.json();
            const data = json[this.propertyName];
            return { res, data };
        });
    }
    listByTenant(tenantOrName, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = { 'content-type': 'application/json' };
            const tenantService = new TenantService(this.client);
            const tenantName = this.getIdString(tenantOrName || (yield tenantService.current()).data.name);
            const url = `applicationsByTenant/${encodeURIComponent(tenantName)}`;
            const res = yield this.fetch(url, { headers, params });
            const json = yield res.json();
            const data = json[this.propertyName];
            return { res, data };
        });
    }
    listByOwner(tenantOrName, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = { 'content-type': 'application/json' };
            const tenantService = new TenantService(this.client);
            const tenantName = this.getIdString(tenantOrName || (yield tenantService.current()).data.name);
            const url = `applicationsByOwner/${encodeURIComponent(tenantName)}`;
            const res = yield this.fetch(url, { headers, params });
            const json = yield res.json();
            const data = json[this.propertyName];
            return { res, data };
        });
    }
    listByUser(userOrId, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = { 'content-type': 'application/json' };
            const userService = new UserService(this.client);
            const userId = this.getIdString(userOrId || (yield userService.current()).data);
            const url = `applicationsByUser/${encodeURIComponent(userId)}`;
            const res = yield this.fetch(url, { headers, params });
            const json = yield res.json();
            const data = json[this.propertyName];
            return { res, data };
        });
    }
    binary(application) {
        return new ApplicationBinaryService(this.client, application);
    }
    getHref(application) {
        if (application.type === ApplicationType.EXTERNAL) {
            return application.externalUrl;
        }
        return `/apps/${application.public ? 'public/' : ''}${application.contextPath}`;
    }
    /**
     * Checks if current user can access specified application.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {string | IApplication} application Application name or contextPath as a
     * string or Application object.
     *
     * @example
     * ```typescript
     *
     *  const checkApp: object = {
     *    name: 'myApplication'
     *  };
     *
     *  (async () => {
     *    const {data, res} = await applicationService.isAvailable(checkApp);
     *  })();
     * ```
     */
    isAvailable(application) {
        return __awaiter(this, void 0, void 0, function* () {
            const { res, data } = yield this.listByUser(undefined, {
                dropOverwrittenApps: true,
                noPaging: true
            });
            const available = (data || []).some((availableApp) => typeof application === 'string'
                ? availableApp.name === application || availableApp.contextPath === application
                : this.isMatch(availableApp, application));
            return { data: available, res };
        });
    }
    isMatch(object, source) {
        return Object.keys(source).every(key => {
            if (Array.isArray(object[key]) && Array.isArray(source[key])) {
                return source[key].every(el => object[key].includes(el));
            }
            else if (typeof object[key] === 'object' &&
                object[key] !== null &&
                typeof source[key] === 'object' &&
                source[key] !== null) {
                return this.isMatch(object[key], source[key]);
            }
            else {
                return object[key] === source[key];
            }
        });
    }
}
//# sourceMappingURL=ApplicationService.js.map