var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Paging } from './Paging';
import { ObservableList, PagingStrategy } from './ObservableList';
export class Service {
    constructor(client, realtime) {
        this.client = client;
        this.realtime = realtime;
        this.cache = new Map();
        const methodsToHide = ['list', 'create', 'update', 'detail', 'delete', 'detail$', 'list$'];
        const prototype = Object.getPrototypeOf(this);
        methodsToHide.forEach(method => {
            if (!prototype.hasOwnProperty(method)) {
                Object.defineProperty(this, method, {
                    get() {
                        return undefined;
                    }
                });
            }
        });
    }
    list(filter = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = { accept: 'application/json' };
            const url = this.listUrl;
            const res = yield this.fetch(url, this.changeFetchOptions({ headers, params: filter }, url));
            const json = yield res.json();
            const data = this.propertyName ? json[this.propertyName] : json;
            const paging = this.getPaging(json, filter);
            return { res, data, paging };
        });
    }
    list$(filter = {}, options = {}) {
        const { source } = filter;
        return new ObservableList(() => this.list(filter), this.getRealtime(source), options, filter).source;
    }
    detail(entityOrId, filter = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = { accept: 'application/json' };
            const url = this.getDetailUrl(entityOrId);
            const res = yield this.fetch(url, this.changeFetchOptions({ headers, params: Object.assign({}, filter) }, url));
            const data = yield res.json();
            return { res, data };
        });
    }
    detail$(entityOrId, options = { pagingStrategy: PagingStrategy.NONE }) {
        const obsList$ = new ObservableList(() => this.detail(entityOrId), this.getRealtime(entityOrId), options);
        return obsList$.composeDetail().source;
    }
    create(entity) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.listUrl;
            const method = 'POST';
            const body = JSON.stringify(this.onBeforeCreate(entity));
            const headers = { 'content-type': 'application/json', accept: 'application/json' };
            const res = yield this.fetch(url, this.changeFetchOptions({ method, body, headers }, url));
            const data = yield res.json();
            return { res, data };
        });
    }
    update(entity) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.getDetailUrl(entity);
            const method = 'PUT';
            const body = JSON.stringify(this.onBeforeUpdate(entity));
            const headers = { 'content-type': 'application/json', accept: 'application/json' };
            const res = yield this.fetch(url, this.changeFetchOptions({ method, body, headers }, url));
            const data = yield res.json();
            return { res, data };
        });
    }
    delete(entityOrId, params) {
        return __awaiter(this, void 0, void 0, function* () {
            const method = 'DELETE';
            const url = this.getDetailUrl(entityOrId);
            const res = yield this.fetch(url, this.changeFetchOptions({ method, params }, url));
            return { res, data: null };
        });
    }
    onBeforeCreate(obj) {
        delete obj.id;
        return obj;
    }
    onBeforeUpdate(objWithId) {
        return objWithId;
    }
    changeFetchOptions(options, url) {
        return options;
    }
    getUrl(url = '') {
        const baseUrl = this.baseUrl.replace(/\/+$/, '');
        const partialUrl = url.replace(/^\/+/, '');
        return `${baseUrl}/${partialUrl}`;
    }
    getDetailUrl(entityOrId) {
        let id;
        if (typeof entityOrId === 'object' && entityOrId.id) {
            id = entityOrId.id;
        }
        else {
            id = entityOrId;
        }
        return `${this.listUrl}/${id}`;
    }
    fetch(url, init) {
        return __awaiter(this, void 0, void 0, function* () {
            const fullUrl = this.getUrl(url);
            const res = yield this.client.fetch(fullUrl, init);
            if (res.status >= 400) {
                let data = null;
                try {
                    data = yield res.json();
                }
                catch (ex) {
                    try {
                        data = yield res.text();
                    }
                    catch (ex) {
                        // do nothing
                    }
                }
                throw { res, data };
            }
            return res;
        });
    }
    mimeType(type) {
        return `application/vnd.com.nsn.cumulocity.${type}+json`;
    }
    getIdString(reference) {
        let id;
        if (typeof reference === 'object') {
            id = reference.id;
        }
        else {
            id = reference;
        }
        return String(id);
    }
    getChannel(entityOrId) {
        return entityOrId ? this.channel.replace('*', this.getIdString(entityOrId)) : this.channel;
    }
    getRealtime(entityOrId) {
        if (this.realtime) {
            return this.realtime.observable(this.getChannel(entityOrId));
        }
    }
    getPaging(json, filter) {
        if (json.statistics) {
            const statistics = Object.assign({}, json.statistics, { nextPage: this.getCurrentPageFromLink(json.next), prevPage: this.getCurrentPageFromLink(json.prev) });
            return new Paging(this, statistics, filter);
        }
        return null;
    }
    getCurrentPageFromLink(link = '') {
        const matches = link.match(/currentPage=(-{0,1}\d+)/);
        return matches && parseInt(matches[1], 10);
    }
}
//# sourceMappingURL=Service.js.map