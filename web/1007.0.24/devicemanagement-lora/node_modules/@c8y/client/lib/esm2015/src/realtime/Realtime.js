import { Observable } from 'rxjs';
import { CometD } from 'isomorphic-cometd';
import { MetaChannel } from './MetaChannel';
export class Realtime {
    /**
     * Allows to set up a realtime (websocket or long-polling) connection to the platform.
     * @param client The fetch client instance to use
     * @param url The URL to connect to
     * @param handshakeCallback A function which is called on succeeded or failed handshake
     */
    constructor(client, url = '/cep/realtime', handshakeCallback) {
        this.client = client;
        this.url = url;
        this.cometd = new CometD();
        this.metaHandshake = msg => {
            if (!msg.successful) {
                throw new Error('Handshake failed');
            }
        };
        this.cometd.websocketEnabled = true;
        this.cometd.addListener(MetaChannel.HANDSHAKE, handshakeCallback || this.metaHandshake);
    }
    /**
     * Subscribes to a realtime channel to listen for data.
     * @param channel The channel to connect to
     * @param callback A function to call when data is received
     */
    subscribe(channel, callback) {
        this.checkConnection();
        return this.cometd.subscribe(channel, callback);
    }
    /**
     * Cancels the listening to a channel.
     * @param subscription The subscription object returned by subscribe()
     */
    unsubscribe(subscription) {
        return this.cometd.unsubscribe(subscription);
    }
    /**
     * Returns an observable which subscribes/unsubscribes automatically.
     * @param channel The name of the channel you want to connect to.
     *
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use rxjs `new Observable()`, `defer()` or `from()`
     * to composite an observable on your own:
     * ```typescript
     * return new Observable<any>((observer) => {
     *   const subscription = this.subscribe(channel, (msg) => {
     *     const data = {
     *       channel: msg.channel,
     *       data: msg.data.data,
     *       id: msg.id,
     *       realtimeAction: msg.data.realtimeAction,
     *     };
     *     return observer.next(data);
     *   });
     *   return () => this.unsubscribe(subscription);
     * });
     * ```
     */
    observable(channel) {
        return new Observable(observer => {
            const subscription = this.subscribe(channel, msg => {
                const data = {
                    channel: msg.channel,
                    data: msg.data.data,
                    id: msg.id,
                    realtimeAction: msg.data.realtimeAction
                };
                return observer.next(data);
            });
            return () => this.unsubscribe(subscription);
        });
    }
    /**
     * Disconnects the current connection.
     */
    disconnect() {
        this.cometd.disconnect();
    }
    checkConnection() {
        const { cometd, client, url } = this;
        if (cometd.isDisconnected()) {
            const { headers } = client.getFetchOptions();
            const config = {
                url: client.getUrl(url),
                requestHeaders: headers
            };
            cometd.configure(config);
            this.handshake(client.getCometdHandshake());
        }
    }
    handshake(config) {
        this.cometd.handshake(config);
    }
}
//# sourceMappingURL=Realtime.js.map