var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var browserPonyfill = createCommonjsModule(function (module) {
var __root__ = (function (root) {
function F() { this.fetch = false; }
F.prototype = root;
return new F();
})(typeof self !== 'undefined' ? self : commonjsGlobal);
(function(self) {

(function(self) {

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob();
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    };

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue+','+value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) { items.push(name); });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) { items.push(value); });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) { items.push([name, value]); });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'omit';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  };

  function decode(body) {
    var form = new FormData();
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=');
        var name = split.shift().replace(/\+/g, ' ');
        var value = split.join('=').replace(/\+/g, ' ');
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    rawHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = 'status' in options ? options.status : 200;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);
      var xhr = new XMLHttpRequest();

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  };
  self.fetch.polyfill = true;
})(typeof self !== 'undefined' ? self : this);
}).call(__root__, void(0));
var fetch = __root__.fetch;
var Response = fetch.Response = __root__.Response;
var Request = fetch.Request = __root__.Request;
var Headers = fetch.Headers = __root__.Headers;
if ('object' === 'object' && module.exports) {
module.exports = fetch;
}
});

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isFunction(x) {
    return typeof x === 'function';
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config = {
    Promise: undefined,
    set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
            var error = /*@__PURE__*/ new Error();
            /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        }
        else if (_enable_super_gross_mode_that_will_cause_bad_things) {
            /*@__PURE__*/ console.log('RxJS: Back to a better error behavior. Thank you. <3');
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
    },
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function hostReportError(err) {
    setTimeout(function () { throw err; });
}

/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */
var empty = {
    closed: true,
    next: function (value) { },
    error: function (err) {
        if (config.useDeprecatedSynchronousErrorHandling) {
            throw err;
        }
        else {
            hostReportError(err);
        }
    },
    complete: function () { }
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isObject(x) {
    return x !== null && typeof x === 'object';
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function UnsubscriptionErrorImpl(errors) {
    Error.call(this);
    this.message = errors ?
        errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
    this.name = 'UnsubscriptionError';
    this.errors = errors;
    return this;
}
UnsubscriptionErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
var UnsubscriptionError = UnsubscriptionErrorImpl;

/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */
var Subscription = /*@__PURE__*/ (function () {
    function Subscription(unsubscribe) {
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        while (_parent) {
            _parent.remove(this);
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction(_unsubscribe)) {
            try {
                _unsubscribe.call(this);
            }
            catch (e) {
                hasErrors = true;
                errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
            }
        }
        if (isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject(sub)) {
                    try {
                        sub.unsubscribe();
                    }
                    catch (e) {
                        hasErrors = true;
                        errors = errors || [];
                        if (e instanceof UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                        }
                        else {
                            errors.push(e);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError(errors);
        }
    };
    Subscription.prototype.add = function (teardown) {
        var subscription = teardown;
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (!(subscription instanceof Subscription)) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default: {
                if (!teardown) {
                    return Subscription.EMPTY;
                }
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
            }
        }
        if (subscription._addParent(this)) {
            var subscriptions = this._subscriptions;
            if (subscriptions) {
                subscriptions.push(subscription);
            }
            else {
                this._subscriptions = [subscription];
            }
        }
        return subscription;
    };
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.prototype._addParent = function (parent) {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        if (_parent === parent) {
            return false;
        }
        else if (!_parent) {
            this._parent = parent;
            return true;
        }
        else if (!_parents) {
            this._parents = [parent];
            return true;
        }
        else if (_parents.indexOf(parent) === -1) {
            _parents.push(parent);
            return true;
        }
        return false;
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError) ? err.errors : err); }, []);
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var rxSubscriber = typeof Symbol === 'function'
    ? /*@__PURE__*/ Symbol('rxSubscriber')
    : '@@rxSubscriber_' + /*@__PURE__*/ Math.random();

/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */
var Subscriber = /*@__PURE__*/ (function (_super) {
    __extends(Subscriber, _super);
    function Subscriber(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
            case 0:
                _this.destination = empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    _this.destination = empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                        _this.destination = destinationOrNext;
                        destinationOrNext.add(_this);
                    }
                    else {
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }
                    break;
                }
            default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                break;
        }
        return _this;
    }
    Subscriber.prototype[rxSubscriber] = function () { return this; };
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
    };
    return Subscriber;
}(Subscription));
var SafeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== empty) {
                context = Object.create(observerOrNext);
                if (isFunction(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = _this.unsubscribe.bind(_this);
            }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
            if (this._error) {
                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                hostReportError(err);
            }
            else {
                if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                }
                else {
                    hostReportError(err);
                }
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            if (config.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                hostReportError(err);
            }
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        if (!config.useDeprecatedSynchronousErrorHandling) {
            throw new Error('bad call');
        }
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            if (config.useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            else {
                hostReportError(err);
                return true;
            }
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */
function canReportError(observer) {
    while (observer) {
        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
        if (closed_1 || isStopped) {
            return false;
        }
        else if (destination && destination instanceof Subscriber) {
            observer = destination;
        }
        else {
            observer = null;
        }
    }
    return true;
}

/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber]) {
            return nextOrObserver[rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber(empty);
    }
    return new Subscriber(nextOrObserver, error, complete);
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var observable = typeof Symbol === 'function' && Symbol.observable || '@@observable';

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function noop() { }

/** PURE_IMPORTS_START _noop PURE_IMPORTS_END */
function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
}
function pipeFromArray(fns) {
    if (!fns) {
        return noop;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}

/** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_internal_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */
var Observable = /*@__PURE__*/ (function () {
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable$$1 = new Observable();
        observable$$1.source = this;
        observable$$1.operator = operator;
        return observable$$1;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber(observerOrNext, error, complete);
        if (operator) {
            sink.add(operator.call(sink, this.source));
        }
        else {
            sink.add(this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                this._subscribe(sink) :
                this._trySubscribe(sink));
        }
        if (config.useDeprecatedSynchronousErrorHandling) {
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            if (config.useDeprecatedSynchronousErrorHandling) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
            }
            if (canReportError(sink)) {
                sink.error(err);
            }
            else {
                console.warn(err);
            }
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscription;
            subscription = _this.subscribe(function (value) {
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    if (subscription) {
                        subscription.unsubscribe();
                    }
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
    };
    Observable.prototype[observable] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipeFromArray(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
        promiseCtor = config.Promise || Promise;
    }
    if (!promiseCtor) {
        throw new Error('no Promise impl found');
    }
    return promiseCtor;
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function ObjectUnsubscribedErrorImpl() {
    Error.call(this);
    this.message = 'object unsubscribed';
    this.name = 'ObjectUnsubscribedError';
    return this;
}
ObjectUnsubscribedErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
var SubjectSubscription = /*@__PURE__*/ (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription));

/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */
var SubjectSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
    }
    return SubjectSubscriber;
}(Subscriber));
var Subject = /*@__PURE__*/ (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype[rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable));
var AnonymousSubject = /*@__PURE__*/ (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function refCount() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
    };
}
var RefCountOperator = /*@__PURE__*/ (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */
var ConnectableObservable = /*@__PURE__*/ (function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        _this._isComplete = false;
        return _this;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new Subscription();
            connection.add(this.source
                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription.EMPTY;
            }
            else {
                this._connection = connection;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return refCount()(this);
    };
    return ConnectableObservable;
}(Observable));
var connectableProto = ConnectableObservable.prototype;
var connectableObservableDescriptor = {
    operator: { value: null },
    _refCount: { value: 0, writable: true },
    _subject: { value: null, writable: true },
    _connection: { value: null, writable: true },
    _subscribe: { value: connectableProto._subscribe },
    _isComplete: { value: connectableProto._isComplete, writable: true },
    getSubject: { value: connectableProto.getSubject },
    connect: { value: connectableProto.connect },
    refCount: { value: connectableProto.refCount }
};
var ConnectableSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(SubjectSubscriber));
var RefCountSubscriber$1 = /*@__PURE__*/ (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount$$1 = connectable._refCount;
        if (refCount$$1 <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount$$1 - 1;
        if (refCount$$1 > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription,_Observable,_Subject PURE_IMPORTS_END */
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
    return function (source) {
        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
    };
}
var GroupByOperator = /*@__PURE__*/ (function () {
    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
    }
    GroupByOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
    };
    return GroupByOperator;
}());
var GroupBySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(GroupBySubscriber, _super);
    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.elementSelector = elementSelector;
        _this.durationSelector = durationSelector;
        _this.subjectSelector = subjectSelector;
        _this.groups = null;
        _this.attemptedToUnsubscribe = false;
        _this.count = 0;
        return _this;
    }
    GroupBySubscriber.prototype._next = function (value) {
        var key;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            this.error(err);
            return;
        }
        this._group(value, key);
    };
    GroupBySubscriber.prototype._group = function (value, key) {
        var groups = this.groups;
        if (!groups) {
            groups = this.groups = new Map();
        }
        var group = groups.get(key);
        var element;
        if (this.elementSelector) {
            try {
                element = this.elementSelector(value);
            }
            catch (err) {
                this.error(err);
            }
        }
        else {
            element = value;
        }
        if (!group) {
            group = (this.subjectSelector ? this.subjectSelector() : new Subject());
            groups.set(key, group);
            var groupedObservable = new GroupedObservable(key, group, this);
            this.destination.next(groupedObservable);
            if (this.durationSelector) {
                var duration = void 0;
                try {
                    duration = this.durationSelector(new GroupedObservable(key, group));
                }
                catch (err) {
                    this.error(err);
                    return;
                }
                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
            }
        }
        if (!group.closed) {
            group.next(element);
        }
    };
    GroupBySubscriber.prototype._error = function (err) {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.error(err);
            });
            groups.clear();
        }
        this.destination.error(err);
    };
    GroupBySubscriber.prototype._complete = function () {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.complete();
            });
            groups.clear();
        }
        this.destination.complete();
    };
    GroupBySubscriber.prototype.removeGroup = function (key) {
        this.groups.delete(key);
    };
    GroupBySubscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.attemptedToUnsubscribe = true;
            if (this.count === 0) {
                _super.prototype.unsubscribe.call(this);
            }
        }
    };
    return GroupBySubscriber;
}(Subscriber));
var GroupDurationSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(GroupDurationSubscriber, _super);
    function GroupDurationSubscriber(key, group, parent) {
        var _this = _super.call(this, group) || this;
        _this.key = key;
        _this.group = group;
        _this.parent = parent;
        return _this;
    }
    GroupDurationSubscriber.prototype._next = function (value) {
        this.complete();
    };
    GroupDurationSubscriber.prototype._unsubscribe = function () {
        var _a = this, parent = _a.parent, key = _a.key;
        this.key = this.parent = null;
        if (parent) {
            parent.removeGroup(key);
        }
    };
    return GroupDurationSubscriber;
}(Subscriber));
var GroupedObservable = /*@__PURE__*/ (function (_super) {
    __extends(GroupedObservable, _super);
    function GroupedObservable(key, groupSubject, refCountSubscription) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.groupSubject = groupSubject;
        _this.refCountSubscription = refCountSubscription;
        return _this;
    }
    GroupedObservable.prototype._subscribe = function (subscriber) {
        var subscription = new Subscription();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
            subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
    };
    return GroupedObservable;
}(Observable));
var InnerRefCountSubscription = /*@__PURE__*/ (function (_super) {
    __extends(InnerRefCountSubscription, _super);
    function InnerRefCountSubscription(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        parent.count++;
        return _this;
    }
    InnerRefCountSubscription.prototype.unsubscribe = function () {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
            _super.prototype.unsubscribe.call(this);
            parent.count -= 1;
            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                parent.unsubscribe();
            }
        }
    };
    return InnerRefCountSubscription;
}(Subscription));

/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */
var BehaviorSubject = /*@__PURE__*/ (function (_super) {
    __extends(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject));

/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
var Action = /*@__PURE__*/ (function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        return _super.call(this) || this;
    }
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return this;
    };
    return Action;
}(Subscription));

/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */
var AsyncAction = /*@__PURE__*/ (function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (this.closed) {
            return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        clearInterval(id);
        return undefined;
    };
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action));

/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
var QueueAction = /*@__PURE__*/ (function (_super) {
    __extends(QueueAction, _super);
    function QueueAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction));

var Scheduler = /*@__PURE__*/ (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = function () { return Date.now(); };
    return Scheduler;
}());

/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */
var AsyncScheduler = /*@__PURE__*/ (function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, function () {
            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                return AsyncScheduler.delegate.now();
            }
            else {
                return now();
            }
        }) || this;
        _this.actions = [];
        _this.active = false;
        _this.scheduled = undefined;
        return _this;
    }
    AsyncScheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
            return AsyncScheduler.delegate.schedule(work, delay, state);
        }
        else {
            return _super.prototype.schedule.call(this, work, delay, state);
        }
    };
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift());
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler));

/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
var QueueScheduler = /*@__PURE__*/ (function (_super) {
    __extends(QueueScheduler, _super);
    function QueueScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler;
}(AsyncScheduler));

/** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */
var queue = /*@__PURE__*/ new QueueScheduler(QueueAction);

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
var EMPTY = /*@__PURE__*/ new Observable(function (subscriber) { return subscriber.complete(); });
function empty$1(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
    return new Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var subscribeToArray = function (array) {
    return function (subscriber) {
        for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
            subscriber.next(array[i]);
        }
        if (!subscriber.closed) {
            subscriber.complete();
        }
    };
};

/** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToArray PURE_IMPORTS_END */
function fromArray(input, scheduler) {
    if (!scheduler) {
        return new Observable(subscribeToArray(input));
    }
    else {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            var i = 0;
            sub.add(scheduler.schedule(function () {
                if (i === input.length) {
                    subscriber.complete();
                    return;
                }
                subscriber.next(input[i++]);
                if (!subscriber.closed) {
                    sub.add(this.schedule());
                }
            }));
            return sub;
        });
    }
}

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
function scalar(value) {
    var result = new Observable(function (subscriber) {
        subscriber.next(value);
        subscriber.complete();
    });
    result._isScalar = true;
    result.value = value;
    return result;
}

/** PURE_IMPORTS_START _util_isScheduler,_fromArray,_empty,_scalar PURE_IMPORTS_END */
function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = args[args.length - 1];
    if (isScheduler(scheduler)) {
        args.pop();
    }
    else {
        scheduler = undefined;
    }
    switch (args.length) {
        case 0:
            return empty$1(scheduler);
        case 1:
            return scheduler ? fromArray(args, scheduler) : scalar(args[0]);
        default:
            return fromArray(args, scheduler);
    }
}

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
function throwError(error, scheduler) {
    if (!scheduler) {
        return new Observable(function (subscriber) { return subscriber.error(error); });
    }
    else {
        return new Observable(function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });
    }
}
function dispatch(_a) {
    var error = _a.error, subscriber = _a.subscriber;
    subscriber.error(error);
}

/** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */
var NotificationKind;
/*@__PURE__*/ (function (NotificationKind) {
    NotificationKind["NEXT"] = "N";
    NotificationKind["ERROR"] = "E";
    NotificationKind["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = /*@__PURE__*/ (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === "N";
    }
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case "N":
                return observer.next && observer.next(this.value);
            case "E":
                return observer.error && observer.error(this.error);
            case "C":
                return observer.complete && observer.complete();
        }
    };
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case "N":
                return next && next(this.value);
            case "E":
                return error && error(this.error);
            case "C":
                return complete && complete();
        }
    };
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case "N":
                return of(this.value);
            case "E":
                return throwError(this.error);
            case "C":
                return empty$1();
        }
        throw new Error('unexpected notification kind value');
    };
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification("N", value);
        }
        return Notification.undefinedValueNotification;
    };
    Notification.createError = function (err) {
        return new Notification("E", undefined, err);
    };
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification("C");
    Notification.undefinedValueNotification = new Notification("N", undefined);
    return Notification;
}());

/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */
function observeOn(scheduler, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
    };
}
var ObserveOnOperator = /*@__PURE__*/ (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());
var ObserveOnSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay;
        return _this;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        var destination = this.destination;
        destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification.createError(err));
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification.createComplete());
        this.unsubscribe();
    };
    return ObserveOnSubscriber;
}(Subscriber));
var ObserveOnMessage = /*@__PURE__*/ (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());

/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */
var ReplaySubject = /*@__PURE__*/ (function (_super) {
    __extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) {
            bufferSize = Number.POSITIVE_INFINITY;
        }
        if (windowTime === void 0) {
            windowTime = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime < 1 ? 1 : windowTime;
        if (windowTime === Number.POSITIVE_INFINITY) {
            _this._infiniteTimeWindow = true;
            _this.next = _this.nextInfiniteTimeWindow;
        }
        else {
            _this.next = _this.nextTimeWindow;
        }
        return _this;
    }
    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
        var _events = this._events;
        _events.push(value);
        if (_events.length > this._bufferSize) {
            _events.shift();
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype.nextTimeWindow = function (value) {
        this._events.push(new ReplayEvent(this._getNow(), value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else if (this.isStopped || this.hasError) {
            subscription = Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
        }
        if (_infiniteTimeWindow) {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i]);
            }
        }
        else {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i].value);
            }
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject));
var ReplayEvent = /*@__PURE__*/ (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());

/** PURE_IMPORTS_START tslib,_Subject,_Subscription PURE_IMPORTS_END */
var AsyncSubject = /*@__PURE__*/ (function (_super) {
    __extends(AsyncSubject, _super);
    function AsyncSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.value = null;
        _this.hasNext = false;
        _this.hasCompleted = false;
        return _this;
    }
    AsyncSubject.prototype._subscribe = function (subscriber) {
        if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription.EMPTY;
        }
        else if (this.hasCompleted && this.hasNext) {
            subscriber.next(this.value);
            subscriber.complete();
            return Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject.prototype.next = function (value) {
        if (!this.hasCompleted) {
            this.value = value;
            this.hasNext = true;
        }
    };
    AsyncSubject.prototype.error = function (error) {
        if (!this.hasCompleted) {
            _super.prototype.error.call(this, error);
        }
    };
    AsyncSubject.prototype.complete = function () {
        this.hasCompleted = true;
        if (this.hasNext) {
            _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
    };
    return AsyncSubject;
}(Subject));

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var nextHandle = 1;
var tasksByHandle = {};
function runIfPresent(handle) {
    var cb = tasksByHandle[handle];
    if (cb) {
        cb();
    }
}
var Immediate = {
    setImmediate: function (cb) {
        var handle = nextHandle++;
        tasksByHandle[handle] = cb;
        Promise.resolve().then(function () { return runIfPresent(handle); });
        return handle;
    },
    clearImmediate: function (handle) {
        delete tasksByHandle[handle];
    },
};

/** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */
var AsapAction = /*@__PURE__*/ (function (_super) {
    __extends(AsapAction, _super);
    function AsapAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
    };
    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            Immediate.clearImmediate(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AsapAction;
}(AsyncAction));

/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
var AsapScheduler = /*@__PURE__*/ (function (_super) {
    __extends(AsapScheduler, _super);
    function AsapScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsapScheduler;
}(AsyncScheduler));

/** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */
var asap = /*@__PURE__*/ new AsapScheduler(AsapAction);

/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
var async = /*@__PURE__*/ new AsyncScheduler(AsyncAction);

/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
var AnimationFrameAction = /*@__PURE__*/ (function (_super) {
    __extends(AnimationFrameAction, _super);
    function AnimationFrameAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));
    };
    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            cancelAnimationFrame(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AnimationFrameAction;
}(AsyncAction));

/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
var AnimationFrameScheduler = /*@__PURE__*/ (function (_super) {
    __extends(AnimationFrameScheduler, _super);
    function AnimationFrameScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AnimationFrameScheduler;
}(AsyncScheduler));

/** PURE_IMPORTS_START _AnimationFrameAction,_AnimationFrameScheduler PURE_IMPORTS_END */
var animationFrame = /*@__PURE__*/ new AnimationFrameScheduler(AnimationFrameAction);

/** PURE_IMPORTS_START tslib,_AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
var VirtualTimeScheduler = /*@__PURE__*/ (function (_super) {
    __extends(VirtualTimeScheduler, _super);
    function VirtualTimeScheduler(SchedulerAction, maxFrames) {
        if (SchedulerAction === void 0) {
            SchedulerAction = VirtualAction;
        }
        if (maxFrames === void 0) {
            maxFrames = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
    }
    VirtualTimeScheduler.prototype.flush = function () {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error, action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
            actions.shift();
            this.frame = action.delay;
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        }
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    VirtualTimeScheduler.frameTimeFactor = 10;
    return VirtualTimeScheduler;
}(AsyncScheduler));
var VirtualAction = /*@__PURE__*/ (function (_super) {
    __extends(VirtualAction, _super);
    function VirtualAction(scheduler, work, index) {
        if (index === void 0) {
            index = scheduler.index += 1;
        }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
    }
    VirtualAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.active = false;
        var action = new VirtualAction(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
    };
    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction.sortActions);
        return true;
    };
    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return undefined;
    };
    VirtualAction.prototype._execute = function (state, delay) {
        if (this.active === true) {
            return _super.prototype._execute.call(this, state, delay);
        }
    };
    VirtualAction.sortActions = function (a, b) {
        if (a.delay === b.delay) {
            if (a.index === b.index) {
                return 0;
            }
            else if (a.index > b.index) {
                return 1;
            }
            else {
                return -1;
            }
        }
        else if (a.delay > b.delay) {
            return 1;
        }
        else {
            return -1;
        }
    };
    return VirtualAction;
}(AsyncAction));

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function identity(x) {
    return x;
}

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
function isObservable(obj) {
    return !!obj && (obj instanceof Observable || (typeof obj.lift === 'function' && typeof obj.subscribe === 'function'));
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function ArgumentOutOfRangeErrorImpl() {
    Error.call(this);
    this.message = 'argument out of range';
    this.name = 'ArgumentOutOfRangeError';
    return this;
}
ArgumentOutOfRangeErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function EmptyErrorImpl() {
    Error.call(this);
    this.message = 'no elements in sequence';
    this.name = 'EmptyError';
    return this;
}
EmptyErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
var EmptyError = EmptyErrorImpl;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function TimeoutErrorImpl() {
    Error.call(this);
    this.message = 'Timeout has occurred';
    this.name = 'TimeoutError';
    return this;
}
TimeoutErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
var TimeoutError = TimeoutErrorImpl;

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
var MapOperator = /*@__PURE__*/ (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
var MapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isArray,_util_isScheduler PURE_IMPORTS_END */
function bindCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if (isScheduler(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            };
        }
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var context = this;
        var subject;
        var params = {
            context: context,
            subject: subject,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
        };
        return new Observable(function (subscriber) {
            if (!scheduler) {
                if (!subject) {
                    subject = new AsyncSubject();
                    var handler = function () {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i] = arguments[_i];
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([handler]));
                    }
                    catch (err) {
                        if (canReportError(subject)) {
                            subject.error(err);
                        }
                        else {
                            console.warn(err);
                        }
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                var state = {
                    args: args, subscriber: subscriber, params: params,
                };
                return scheduler.schedule(dispatch$1, 0, state);
            }
        });
    };
}
function dispatch$1(state) {
    var _this = this;
    var args = state.args, subscriber = state.subscriber, params = state.params;
    var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new AsyncSubject();
        var handler = function () {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
            }
            var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
            _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
        };
        try {
            callbackFunc.apply(context, args.concat([handler]));
        }
        catch (err) {
            subject.error(err);
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext(state) {
    var value = state.value, subject = state.subject;
    subject.next(value);
    subject.complete();
}

/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isScheduler,_util_isArray PURE_IMPORTS_END */
function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if (isScheduler(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            };
        }
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var params = {
            subject: undefined,
            args: args,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
            context: this,
        };
        return new Observable(function (subscriber) {
            var context = params.context;
            var subject = params.subject;
            if (!scheduler) {
                if (!subject) {
                    subject = params.subject = new AsyncSubject();
                    var handler = function () {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i] = arguments[_i];
                        }
                        var err = innerArgs.shift();
                        if (err) {
                            subject.error(err);
                            return;
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([handler]));
                    }
                    catch (err) {
                        if (canReportError(subject)) {
                            subject.error(err);
                        }
                        else {
                            console.warn(err);
                        }
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                return scheduler.schedule(dispatch$2, 0, { params: params, subscriber: subscriber, context: context });
            }
        });
    };
}
function dispatch$2(state) {
    var _this = this;
    var params = state.params, subscriber = state.subscriber, context = state.context;
    var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new AsyncSubject();
        var handler = function () {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
            }
            var err = innerArgs.shift();
            if (err) {
                _this.add(scheduler.schedule(dispatchError$1, 0, { err: err, subject: subject }));
            }
            else {
                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
                _this.add(scheduler.schedule(dispatchNext$1, 0, { value: value, subject: subject }));
            }
        };
        try {
            callbackFunc.apply(context, args.concat([handler]));
        }
        catch (err) {
            this.add(scheduler.schedule(dispatchError$1, 0, { err: err, subject: subject }));
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext$1(arg) {
    var value = arg.value, subject = arg.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError$1(arg) {
    var err = arg.err, subject = arg.subject;
    subject.error(err);
}

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var OuterSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var InnerSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */
var subscribeToPromise = function (promise) {
    return function (subscriber) {
        promise.then(function (value) {
            if (!subscriber.closed) {
                subscriber.next(value);
                subscriber.complete();
            }
        }, function (err) { return subscriber.error(err); })
            .then(null, hostReportError);
        return subscriber;
    };
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
    }
    return Symbol.iterator;
}
var iterator = /*@__PURE__*/ getSymbolIterator();

/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
var subscribeToIterable = function (iterable) {
    return function (subscriber) {
        var iterator$$1 = iterable[iterator]();
        do {
            var item = iterator$$1.next();
            if (item.done) {
                subscriber.complete();
                break;
            }
            subscriber.next(item.value);
            if (subscriber.closed) {
                break;
            }
        } while (true);
        if (typeof iterator$$1.return === 'function') {
            subscriber.add(function () {
                if (iterator$$1.return) {
                    iterator$$1.return();
                }
            });
        }
        return subscriber;
    };
};

/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
var subscribeToObservable = function (obj) {
    return function (subscriber) {
        var obs = obj[observable]();
        if (typeof obs.subscribe !== 'function') {
            throw new TypeError('Provided object does not correctly implement Symbol.observable');
        }
        else {
            return obs.subscribe(subscriber);
        }
    };
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isPromise(value) {
    return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}

/** PURE_IMPORTS_START _Observable,_subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */
var subscribeTo = function (result) {
    if (result instanceof Observable) {
        return function (subscriber) {
            if (result._isScalar) {
                subscriber.next(result.value);
                subscriber.complete();
                return undefined;
            }
            else {
                return result.subscribe(subscriber);
            }
        };
    }
    else if (!!result && typeof result[observable] === 'function') {
        return subscribeToObservable(result);
    }
    else if (isArrayLike(result)) {
        return subscribeToArray(result);
    }
    else if (isPromise(result)) {
        return subscribeToPromise(result);
    }
    else if (!!result && typeof result[iterator] === 'function') {
        return subscribeToIterable(result);
    }
    else {
        var value = isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected."
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        throw new TypeError(msg);
    }
};

/** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo PURE_IMPORTS_END */
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination) {
    if (destination === void 0) {
        destination = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    }
    if (destination.closed) {
        return;
    }
    return subscribeTo(result)(destination);
}

/** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */
var NONE = {};
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = null;
    var scheduler = null;
    if (isScheduler(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        resultSelector = observables.pop();
    }
    if (observables.length === 1 && isArray(observables[0])) {
        observables = observables[0];
    }
    return fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
var CombineLatestOperator = /*@__PURE__*/ (function () {
    function CombineLatestOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
    };
    return CombineLatestOperator;
}());
var CombineLatestSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(NONE);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.resultSelector) {
                this._tryResultSelector(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
        var result;
        try {
            result = this.resultSelector.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
function isInteropObservable(input) {
    return input && typeof input[observable] === 'function';
}

/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
function isIterable(input) {
    return input && typeof input[iterator] === 'function';
}

/** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToPromise PURE_IMPORTS_END */
function fromPromise(input, scheduler) {
    if (!scheduler) {
        return new Observable(subscribeToPromise(input));
    }
    else {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            sub.add(scheduler.schedule(function () {
                return input.then(function (value) {
                    sub.add(scheduler.schedule(function () {
                        subscriber.next(value);
                        sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
                    }));
                }, function (err) {
                    sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
                });
            }));
            return sub;
        });
    }
}

/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator,_util_subscribeToIterable PURE_IMPORTS_END */
function fromIterable(input, scheduler) {
    if (!input) {
        throw new Error('Iterable cannot be null');
    }
    if (!scheduler) {
        return new Observable(subscribeToIterable(input));
    }
    else {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            var iterator$$1;
            sub.add(function () {
                if (iterator$$1 && typeof iterator$$1.return === 'function') {
                    iterator$$1.return();
                }
            });
            sub.add(scheduler.schedule(function () {
                iterator$$1 = input[iterator]();
                sub.add(scheduler.schedule(function () {
                    if (subscriber.closed) {
                        return;
                    }
                    var value;
                    var done;
                    try {
                        var result = iterator$$1.next();
                        value = result.value;
                        done = result.done;
                    }
                    catch (err) {
                        subscriber.error(err);
                        return;
                    }
                    if (done) {
                        subscriber.complete();
                    }
                    else {
                        subscriber.next(value);
                        this.schedule();
                    }
                }));
            }));
            return sub;
        });
    }
}

/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable,_util_subscribeToObservable PURE_IMPORTS_END */
function fromObservable(input, scheduler) {
    if (!scheduler) {
        return new Observable(subscribeToObservable(input));
    }
    else {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            sub.add(scheduler.schedule(function () {
                var observable$$1 = input[observable]();
                sub.add(observable$$1.subscribe({
                    next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                    error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                    complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
                }));
            }));
            return sub;
        });
    }
}

/** PURE_IMPORTS_START _Observable,_util_isPromise,_util_isArrayLike,_util_isInteropObservable,_util_isIterable,_fromArray,_fromPromise,_fromIterable,_fromObservable,_util_subscribeTo PURE_IMPORTS_END */
function from(input, scheduler) {
    if (!scheduler) {
        if (input instanceof Observable) {
            return input;
        }
        return new Observable(subscribeTo(input));
    }
    if (input != null) {
        if (isInteropObservable(input)) {
            return fromObservable(input, scheduler);
        }
        else if (isPromise(input)) {
            return fromPromise(input, scheduler);
        }
        else if (isArrayLike(input)) {
            return fromArray(input, scheduler);
        }
        else if (isIterable(input) || typeof input === 'string') {
            return fromIterable(input, scheduler);
        }
    }
    throw new TypeError((input !== null && typeof input || input) + ' is not observable');
}

/** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber,_map,_observable_from PURE_IMPORTS_END */
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(mergeMap(function (a, i) { return from(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
    }
    else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
}
var MergeMapOperator = /*@__PURE__*/ (function () {
    function MergeMapOperator(project, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };
    return MergeMapOperator;
}());
var MergeMapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
        var destination = this.destination;
        destination.add(innerSubscriber);
        subscribeToResult(this, ish, value, index, innerSubscriber);
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */
function mergeAll(concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return mergeMap(identity, concurrent);
}

/** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */
function concatAll() {
    return mergeAll(1);
}

/** PURE_IMPORTS_START _of,_operators_concatAll PURE_IMPORTS_END */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return concatAll()(of.apply(void 0, observables));
}

/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */
function defer(observableFactory) {
    return new Observable(function (subscriber) {
        var input;
        try {
            input = observableFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = input ? from(input) : empty$1();
        return source.subscribe(subscriber);
    });
}

/** PURE_IMPORTS_START tslib,_Observable,_util_isArray,_empty,_util_subscribeToResult,_OuterSubscriber,_operators_map PURE_IMPORTS_END */
function forkJoin() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    var resultSelector;
    if (typeof sources[sources.length - 1] === 'function') {
        resultSelector = sources.pop();
    }
    if (sources.length === 1 && isArray(sources[0])) {
        sources = sources[0];
    }
    if (sources.length === 0) {
        return EMPTY;
    }
    if (resultSelector) {
        return forkJoin(sources).pipe(map(function (args) { return resultSelector.apply(void 0, args); }));
    }
    return new Observable(function (subscriber) {
        return new ForkJoinSubscriber(subscriber, sources);
    });
}
var ForkJoinSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ForkJoinSubscriber, _super);
    function ForkJoinSubscriber(destination, sources) {
        var _this = _super.call(this, destination) || this;
        _this.sources = sources;
        _this.completed = 0;
        _this.haveValues = 0;
        var len = sources.length;
        _this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            var source = sources[i];
            var innerSubscription = subscribeToResult(_this, source, null, i);
            if (innerSubscription) {
                _this.add(innerSubscription);
            }
        }
        return _this;
    }
    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        if (!innerSub._hasValue) {
            innerSub._hasValue = true;
            this.haveValues++;
        }
    };
    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {
        var _a = this, destination = _a.destination, haveValues = _a.haveValues, values = _a.values;
        var len = values.length;
        if (!innerSub._hasValue) {
            destination.complete();
            return;
        }
        this.completed++;
        if (this.completed !== len) {
            return;
        }
        if (haveValues === len) {
            destination.next(values);
        }
        destination.complete();
    };
    return ForkJoinSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */
function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction(options)) {
        resultSelector = options;
        options = undefined;
    }
    if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new Observable(function (subscriber) {
        function handler(e) {
            if (arguments.length > 1) {
                subscriber.next(Array.prototype.slice.call(arguments));
            }
            else {
                subscriber.next(e);
            }
        }
        setupSubscription(target, eventName, handler, subscriber, options);
    });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
    var unsubscribe;
    if (isEventTarget(sourceObj)) {
        var source_1 = sourceObj;
        sourceObj.addEventListener(eventName, handler, options);
        unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
    }
    else if (isJQueryStyleEventEmitter(sourceObj)) {
        var source_2 = sourceObj;
        sourceObj.on(eventName, handler);
        unsubscribe = function () { return source_2.off(eventName, handler); };
    }
    else if (isNodeStyleEventEmitter(sourceObj)) {
        var source_3 = sourceObj;
        sourceObj.addListener(eventName, handler);
        unsubscribe = function () { return source_3.removeListener(eventName, handler); };
    }
    else if (sourceObj && sourceObj.length) {
        for (var i = 0, len = sourceObj.length; i < len; i++) {
            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
        }
    }
    else {
        throw new TypeError('Invalid event target');
    }
    subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isEventTarget(sourceObj) {
    return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}

/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */
function fromEventPattern(addHandler, removeHandler, resultSelector) {
    if (resultSelector) {
        return fromEventPattern(addHandler, removeHandler).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new Observable(function (subscriber) {
        var handler = function () {
            var e = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                e[_i] = arguments[_i];
            }
            return subscriber.next(e.length === 1 ? e[0] : e);
        };
        var retValue;
        try {
            retValue = addHandler(handler);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!isFunction(removeHandler)) {
            return undefined;
        }
        return function () { return removeHandler(handler, retValue); };
    });
}

/** PURE_IMPORTS_START _Observable,_util_identity,_util_isScheduler PURE_IMPORTS_END */
function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
    var resultSelector;
    var initialState;
    if (arguments.length == 1) {
        var options = initialStateOrOptions;
        initialState = options.initialState;
        condition = options.condition;
        iterate = options.iterate;
        resultSelector = options.resultSelector || identity;
        scheduler = options.scheduler;
    }
    else if (resultSelectorOrObservable === undefined || isScheduler(resultSelectorOrObservable)) {
        initialState = initialStateOrOptions;
        resultSelector = identity;
        scheduler = resultSelectorOrObservable;
    }
    else {
        initialState = initialStateOrOptions;
        resultSelector = resultSelectorOrObservable;
    }
    return new Observable(function (subscriber) {
        var state = initialState;
        if (scheduler) {
            return scheduler.schedule(dispatch$3, 0, {
                subscriber: subscriber,
                iterate: iterate,
                condition: condition,
                resultSelector: resultSelector,
                state: state
            });
        }
        do {
            if (condition) {
                var conditionResult = void 0;
                try {
                    conditionResult = condition(state);
                }
                catch (err) {
                    subscriber.error(err);
                    return undefined;
                }
                if (!conditionResult) {
                    subscriber.complete();
                    break;
                }
            }
            var value = void 0;
            try {
                value = resultSelector(state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
            subscriber.next(value);
            if (subscriber.closed) {
                break;
            }
            try {
                state = iterate(state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
        } while (true);
        return undefined;
    });
}
function dispatch$3(state) {
    var subscriber = state.subscriber, condition = state.condition;
    if (subscriber.closed) {
        return undefined;
    }
    if (state.needIterate) {
        try {
            state.state = state.iterate(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
    }
    else {
        state.needIterate = true;
    }
    if (condition) {
        var conditionResult = void 0;
        try {
            conditionResult = condition(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!conditionResult) {
            subscriber.complete();
            return undefined;
        }
        if (subscriber.closed) {
            return undefined;
        }
    }
    var value;
    try {
        value = state.resultSelector(state.state);
    }
    catch (err) {
        subscriber.error(err);
        return undefined;
    }
    if (subscriber.closed) {
        return undefined;
    }
    subscriber.next(value);
    if (subscriber.closed) {
        return undefined;
    }
    return this.schedule(state);
}

/** PURE_IMPORTS_START _defer,_empty PURE_IMPORTS_END */
function iif(condition, trueResult, falseResult) {
    if (trueResult === void 0) {
        trueResult = EMPTY;
    }
    if (falseResult === void 0) {
        falseResult = EMPTY;
    }
    return defer(function () { return condition() ? trueResult : falseResult; });
}

/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */
function isNumeric(val) {
    return !isArray(val) && (val - parseFloat(val) + 1) >= 0;
}

/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */
function interval(period, scheduler) {
    if (period === void 0) {
        period = 0;
    }
    if (scheduler === void 0) {
        scheduler = async;
    }
    if (!isNumeric(period) || period < 0) {
        period = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== 'function') {
        scheduler = async;
    }
    return new Observable(function (subscriber) {
        subscriber.add(scheduler.schedule(dispatch$4, period, { subscriber: subscriber, counter: 0, period: period }));
        return subscriber;
    });
}
function dispatch$4(state) {
    var subscriber = state.subscriber, counter = state.counter, period = state.period;
    subscriber.next(counter);
    this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);
}

/** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
        return observables[0];
    }
    return mergeAll(concurrent)(fromArray(observables, scheduler));
}

/** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */
var NEVER = /*@__PURE__*/ new Observable(noop);
function never() {
    return NEVER;
}

/** PURE_IMPORTS_START _Observable,_from,_util_isArray,_empty PURE_IMPORTS_END */
function onErrorResumeNext() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (sources.length === 0) {
        return EMPTY;
    }
    var first = sources[0], remainder = sources.slice(1);
    if (sources.length === 1 && isArray(first)) {
        return onErrorResumeNext.apply(void 0, first);
    }
    return new Observable(function (subscriber) {
        var subNext = function () { return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber)); };
        return from(first).subscribe({
            next: function (value) { subscriber.next(value); },
            error: subNext,
            complete: subNext,
        });
    });
}

/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
function pairs(obj, scheduler) {
    if (!scheduler) {
        return new Observable(function (subscriber) {
            var keys = Object.keys(obj);
            for (var i = 0; i < keys.length && !subscriber.closed; i++) {
                var key = keys[i];
                if (obj.hasOwnProperty(key)) {
                    subscriber.next([key, obj[key]]);
                }
            }
            subscriber.complete();
        });
    }
    else {
        return new Observable(function (subscriber) {
            var keys = Object.keys(obj);
            var subscription = new Subscription();
            subscription.add(scheduler.schedule(dispatch$5, 0, { keys: keys, index: 0, subscriber: subscriber, subscription: subscription, obj: obj }));
            return subscription;
        });
    }
}
function dispatch$5(state) {
    var keys = state.keys, index = state.index, subscriber = state.subscriber, subscription = state.subscription, obj = state.obj;
    if (!subscriber.closed) {
        if (index < keys.length) {
            var key = keys[index];
            subscriber.next([key, obj[key]]);
            subscription.add(this.schedule({ keys: keys, index: index + 1, subscriber: subscriber, subscription: subscription, obj: obj }));
        }
        else {
            subscriber.complete();
        }
    }
}

/** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    if (observables.length === 1) {
        if (isArray(observables[0])) {
            observables = observables[0];
        }
        else {
            return observables[0];
        }
    }
    return fromArray(observables, undefined).lift(new RaceOperator());
}
var RaceOperator = /*@__PURE__*/ (function () {
    function RaceOperator() {
    }
    RaceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator;
}());
var RaceSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = subscribeToResult(this, observable, observable, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
function range(start, count, scheduler) {
    if (start === void 0) {
        start = 0;
    }
    return new Observable(function (subscriber) {
        if (count === undefined) {
            count = start;
            start = 0;
        }
        var index = 0;
        var current = start;
        if (scheduler) {
            return scheduler.schedule(dispatch$6, 0, {
                index: index, count: count, start: start, subscriber: subscriber
            });
        }
        else {
            do {
                if (index++ >= count) {
                    subscriber.complete();
                    break;
                }
                subscriber.next(current++);
                if (subscriber.closed) {
                    break;
                }
            } while (true);
        }
        return undefined;
    });
}
function dispatch$6(state) {
    var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;
    if (index >= count) {
        subscriber.complete();
        return;
    }
    subscriber.next(start);
    if (subscriber.closed) {
        return;
    }
    state.index = index + 1;
    state.start = start + 1;
    this.schedule(state);
}

/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */
function timer(dueTime, periodOrScheduler, scheduler) {
    if (dueTime === void 0) {
        dueTime = 0;
    }
    var period = -1;
    if (isNumeric(periodOrScheduler)) {
        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
    }
    else if (isScheduler(periodOrScheduler)) {
        scheduler = periodOrScheduler;
    }
    if (!isScheduler(scheduler)) {
        scheduler = async;
    }
    return new Observable(function (subscriber) {
        var due = isNumeric(dueTime)
            ? dueTime
            : (+dueTime - scheduler.now());
        return scheduler.schedule(dispatch$7, due, {
            index: 0, period: period, subscriber: subscriber
        });
    });
}
function dispatch$7(state) {
    var index = state.index, period = state.period, subscriber = state.subscriber;
    subscriber.next(index);
    if (subscriber.closed) {
        return;
    }
    else if (period === -1) {
        return subscriber.complete();
    }
    state.index = index + 1;
    this.schedule(state, period);
}

/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */
function using(resourceFactory, observableFactory) {
    return new Observable(function (subscriber) {
        var resource;
        try {
            resource = resourceFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var result;
        try {
            result = observableFactory(resource);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = result ? from(result) : EMPTY;
        var subscription = source.subscribe(subscriber);
        return function () {
            subscription.unsubscribe();
            if (resource) {
                resource.unsubscribe();
            }
        };
    });
}

/** PURE_IMPORTS_START tslib,_fromArray,_util_isArray,_Subscriber,_OuterSubscriber,_util_subscribeToResult,_.._internal_symbol_iterator PURE_IMPORTS_END */
function zip() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = observables[observables.length - 1];
    if (typeof resultSelector === 'function') {
        observables.pop();
    }
    return fromArray(observables, undefined).lift(new ZipOperator(resultSelector));
}
var ZipOperator = /*@__PURE__*/ (function () {
    function ZipOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
    };
    return ZipOperator;
}());
var ZipSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, resultSelector, values) {
        if (values === void 0) {
            values = Object.create(null);
        }
        var _this = _super.call(this, destination) || this;
        _this.iterators = [];
        _this.active = 0;
        _this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : null;
        _this.values = values;
        return _this;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        }
        else if (typeof value[iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator]()));
        }
        else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        this.unsubscribe();
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator$$1 = iterators[i];
            if (iterator$$1.stillUnsubscribed) {
                var destination = this.destination;
                destination.add(iterator$$1.subscribe(iterator$$1, i));
            }
            else {
                this.active--;
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        for (var i = 0; i < len; i++) {
            var iterator$$1 = iterators[i];
            if (typeof iterator$$1.hasValue === 'function' && !iterator$$1.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator$$1 = iterators[i];
            var result = iterator$$1.next();
            if (iterator$$1.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.resultSelector) {
            this._tryresultSelector(args);
        }
        else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryresultSelector = function (args) {
        var result;
        try {
            result = this.resultSelector.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber));
var StaticIterator = /*@__PURE__*/ (function () {
    function StaticIterator(iterator$$1) {
        this.iterator = iterator$$1;
        this.nextResult = iterator$$1.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}());
var StaticArrayIterator = /*@__PURE__*/ (function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}());
var ZipBufferIterator = /*@__PURE__*/ (function (_super) {
    __extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        _this.observable = observable;
        _this.stillUnsubscribed = true;
        _this.buffer = [];
        _this.isComplete = false;
        return _this;
    }
    ZipBufferIterator.prototype[iterator] = function () {
        return this;
    };
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        }
        else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        }
        else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(OuterSubscriber));

/** PURE_IMPORTS_START  PURE_IMPORTS_END */

var rxjs_1 = /*#__PURE__*/Object.freeze({
	Observable: Observable,
	ConnectableObservable: ConnectableObservable,
	GroupedObservable: GroupedObservable,
	observable: observable,
	Subject: Subject,
	BehaviorSubject: BehaviorSubject,
	ReplaySubject: ReplaySubject,
	AsyncSubject: AsyncSubject,
	asapScheduler: asap,
	asyncScheduler: async,
	queueScheduler: queue,
	animationFrameScheduler: animationFrame,
	VirtualTimeScheduler: VirtualTimeScheduler,
	VirtualAction: VirtualAction,
	Scheduler: Scheduler,
	Subscription: Subscription,
	Subscriber: Subscriber,
	Notification: Notification,
	pipe: pipe,
	noop: noop,
	identity: identity,
	isObservable: isObservable,
	ArgumentOutOfRangeError: ArgumentOutOfRangeError,
	EmptyError: EmptyError,
	ObjectUnsubscribedError: ObjectUnsubscribedError,
	UnsubscriptionError: UnsubscriptionError,
	TimeoutError: TimeoutError,
	bindCallback: bindCallback,
	bindNodeCallback: bindNodeCallback,
	combineLatest: combineLatest,
	concat: concat,
	defer: defer,
	empty: empty$1,
	forkJoin: forkJoin,
	from: from,
	fromEvent: fromEvent,
	fromEventPattern: fromEventPattern,
	generate: generate,
	iif: iif,
	interval: interval,
	merge: merge,
	never: never,
	of: of,
	onErrorResumeNext: onErrorResumeNext,
	pairs: pairs,
	race: race,
	range: range,
	throwError: throwError,
	timer: timer,
	using: using,
	zip: zip,
	EMPTY: EMPTY,
	NEVER: NEVER,
	config: config
});

var cometd = createCommonjsModule(function (module, exports) {
/*
 * Copyright (c) 2008-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* CometD Version 3.1.4 */

(function(root, factory){
    {
        // CommonJS.
        module.exports = factory();
    }
}(commonjsGlobal, function() {
    /**
     * Utility functions.
     */
    var Utils = {
        isString: function(value) {
            if (value === undefined || value === null) {
                return false;
            }
            return typeof value === 'string' || value instanceof String;
        },
        isArray: function(value) {
            if (value === undefined || value === null) {
                return false;
            }
            return value instanceof Array;
        },
        /**
         * Returns whether the given element is contained into the given array.
         * @param element the element to check presence for
         * @param array the array to check for the element presence
         * @return the index of the element, if present, or a negative index if the element is not present
         */
        inArray: function(element, array) {
            for (var i = 0; i < array.length; ++i) {
                if (element === array[i]) {
                    return i;
                }
            }
            return -1;
        },
        setTimeout: function(cometd, funktion, delay) {
            return window.setTimeout(function() {
                try {
                    cometd._debug('Invoking timed function', funktion);
                    funktion();
                } catch (x) {
                    cometd._debug('Exception invoking timed function', funktion, x);
                }
            }, delay);
        },
        clearTimeout: function(timeoutHandle) {
            window.clearTimeout(timeoutHandle);
        }
    };


    /**
     * A registry for transports used by the CometD object.
     */
    var TransportRegistry = function() {
        var _types = [];
        var _transports = {};

        this.getTransportTypes = function() {
            return _types.slice(0);
        };

        this.findTransportTypes = function(version, crossDomain, url) {
            var result = [];
            for (var i = 0; i < _types.length; ++i) {
                var type = _types[i];
                if (_transports[type].accept(version, crossDomain, url) === true) {
                    result.push(type);
                }
            }
            return result;
        };

        this.negotiateTransport = function(types, version, crossDomain, url) {
            for (var i = 0; i < _types.length; ++i) {
                var type = _types[i];
                for (var j = 0; j < types.length; ++j) {
                    if (type === types[j]) {
                        var transport = _transports[type];
                        if (transport.accept(version, crossDomain, url) === true) {
                            return transport;
                        }
                    }
                }
            }
            return null;
        };

        this.add = function(type, transport, index) {
            var existing = false;
            for (var i = 0; i < _types.length; ++i) {
                if (_types[i] === type) {
                    existing = true;
                    break;
                }
            }

            if (!existing) {
                if (typeof index !== 'number') {
                    _types.push(type);
                } else {
                    _types.splice(index, 0, type);
                }
                _transports[type] = transport;
            }

            return !existing;
        };

        this.find = function(type) {
            for (var i = 0; i < _types.length; ++i) {
                if (_types[i] === type) {
                    return _transports[type];
                }
            }
            return null;
        };

        this.remove = function(type) {
            for (var i = 0; i < _types.length; ++i) {
                if (_types[i] === type) {
                    _types.splice(i, 1);
                    var transport = _transports[type];
                    delete _transports[type];
                    return transport;
                }
            }
            return null;
        };

        this.clear = function() {
            _types = [];
            _transports = {};
        };

        this.reset = function(init) {
            for (var i = 0; i < _types.length; ++i) {
                _transports[_types[i]].reset(init);
            }
        };
    };


    /**
     * Base object with the common functionality for transports.
     */
    var Transport = function() {
        var _type;
        var _cometd;
        var _url;

        /**
         * Function invoked just after a transport has been successfully registered.
         * @param type the type of transport (for example 'long-polling')
         * @param cometd the cometd object this transport has been registered to
         * @see #unregistered()
         */
        this.registered = function(type, cometd) {
            _type = type;
            _cometd = cometd;
        };

        /**
         * Function invoked just after a transport has been successfully unregistered.
         * @see #registered(type, cometd)
         */
        this.unregistered = function() {
            _type = null;
            _cometd = null;
        };

        this._debug = function() {
            _cometd._debug.apply(_cometd, arguments);
        };

        this._mixin = function() {
            return _cometd._mixin.apply(_cometd, arguments);
        };

        this.getConfiguration = function() {
            return _cometd.getConfiguration();
        };

        this.getAdvice = function() {
            return _cometd.getAdvice();
        };

        this.setTimeout = function(funktion, delay) {
            return Utils.setTimeout(_cometd, funktion, delay);
        };

        this.clearTimeout = function(handle) {
            Utils.clearTimeout(handle);
        };

        /**
         * Converts the given response into an array of bayeux messages
         * @param response the response to convert
         * @return an array of bayeux messages obtained by converting the response
         */
        this.convertToMessages = function(response) {
            if (Utils.isString(response)) {
                try {
                    return JSON.parse(response);
                } catch (x) {
                    this._debug('Could not convert to JSON the following string', '"' + response + '"');
                    throw x;
                }
            }
            if (Utils.isArray(response)) {
                return response;
            }
            if (response === undefined || response === null) {
                return [];
            }
            if (response instanceof Object) {
                return [response];
            }
            throw 'Conversion Error ' + response + ', typeof ' + (typeof response);
        };

        /**
         * Returns whether this transport can work for the given version and cross domain communication case.
         * @param version a string indicating the transport version
         * @param crossDomain a boolean indicating whether the communication is cross domain
         * @param url the URL to connect to
         * @return true if this transport can work for the given version and cross domain communication case,
         * false otherwise
         */
        this.accept = function(version, crossDomain, url) {
            throw 'Abstract';
        };

        /**
         * Returns the type of this transport.
         * @see #registered(type, cometd)
         */
        this.getType = function() {
            return _type;
        };

        this.getURL = function() {
            return _url;
        };

        this.setURL = function(url) {
            _url = url;
        };

        this.send = function(envelope, metaConnect) {
            throw 'Abstract';
        };

        this.reset = function(init) {
            this._debug('Transport', _type, 'reset', init ? 'initial' : 'retry');
        };

        this.abort = function() {
            this._debug('Transport', _type, 'aborted');
        };

        this.toString = function() {
            return this.getType();
        };
    };

    Transport.derive = function(baseObject) {
        function F() {
        }

        F.prototype = baseObject;
        return new F();
    };


    /**
     * Base object with the common functionality for transports based on requests.
     * The key responsibility is to allow at most 2 outstanding requests to the server,
     * to avoid that requests are sent behind a long poll.
     * To achieve this, we have one reserved request for the long poll, and all other
     * requests are serialized one after the other.
     */
    var RequestTransport = function() {
        var _super = new Transport();
        var _self = Transport.derive(_super);
        var _requestIds = 0;
        var _metaConnectRequest = null;
        var _requests = [];
        var _envelopes = [];

        function _coalesceEnvelopes(envelope) {
            while (_envelopes.length > 0) {
                var envelopeAndRequest = _envelopes[0];
                var newEnvelope = envelopeAndRequest[0];
                var newRequest = envelopeAndRequest[1];
                if (newEnvelope.url === envelope.url &&
                    newEnvelope.sync === envelope.sync) {
                    _envelopes.shift();
                    envelope.messages = envelope.messages.concat(newEnvelope.messages);
                    this._debug('Coalesced', newEnvelope.messages.length, 'messages from request', newRequest.id);
                    continue;
                }
                break;
            }
        }

        function _transportSend(envelope, request) {
            this.transportSend(envelope, request);
            request.expired = false;

            if (!envelope.sync) {
                var maxDelay = this.getConfiguration().maxNetworkDelay;
                var delay = maxDelay;
                if (request.metaConnect === true) {
                    delay += this.getAdvice().timeout;
                }

                this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for the response, maxNetworkDelay', maxDelay);

                var self = this;
                request.timeout = this.setTimeout(function() {
                    request.expired = true;
                    var errorMessage = 'Request ' + request.id + ' of transport ' + self.getType() + ' exceeded ' + delay + ' ms max network delay';
                    var failure = {
                        reason: errorMessage
                    };
                    var xhr = request.xhr;
                    failure.httpCode = self.xhrStatus(xhr);
                    self.abortXHR(xhr);
                    self._debug(errorMessage);
                    self.complete(request, false, request.metaConnect);
                    envelope.onFailure(xhr, envelope.messages, failure);
                }, delay);
            }
        }

        function _queueSend(envelope) {
            var requestId = ++_requestIds;
            var request = {
                id: requestId,
                metaConnect: false,
                envelope: envelope
            };

            // Consider the metaConnect requests which should always be present
            if (_requests.length < this.getConfiguration().maxConnections - 1) {
                _requests.push(request);
                _transportSend.call(this, envelope, request);
            } else {
                this._debug('Transport', this.getType(), 'queueing request', requestId, 'envelope', envelope);
                _envelopes.push([envelope, request]);
            }
        }

        function _metaConnectComplete(request) {
            var requestId = request.id;
            this._debug('Transport', this.getType(), 'metaConnect complete, request', requestId);
            if (_metaConnectRequest !== null && _metaConnectRequest.id !== requestId) {
                throw 'Longpoll request mismatch, completing request ' + requestId;
            }

            // Reset metaConnect request
            _metaConnectRequest = null;
        }

        function _complete(request, success) {
            var index = Utils.inArray(request, _requests);
            // The index can be negative if the request has been aborted
            if (index >= 0) {
                _requests.splice(index, 1);
            }

            if (_envelopes.length > 0) {
                var envelopeAndRequest = _envelopes.shift();
                var nextEnvelope = envelopeAndRequest[0];
                var nextRequest = envelopeAndRequest[1];
                this._debug('Transport dequeued request', nextRequest.id);
                if (success) {
                    if (this.getConfiguration().autoBatch) {
                        _coalesceEnvelopes.call(this, nextEnvelope);
                    }
                    _queueSend.call(this, nextEnvelope);
                    this._debug('Transport completed request', request.id, nextEnvelope);
                } else {
                    // Keep the semantic of calling response callbacks asynchronously after the request
                    var self = this;
                    this.setTimeout(function() {
                        self.complete(nextRequest, false, nextRequest.metaConnect);
                        var failure = {
                            reason: 'Previous request failed'
                        };
                        var xhr = nextRequest.xhr;
                        failure.httpCode = self.xhrStatus(xhr);
                        nextEnvelope.onFailure(xhr, nextEnvelope.messages, failure);
                    }, 0);
                }
            }
        }

        _self.complete = function(request, success, metaConnect) {
            if (metaConnect) {
                _metaConnectComplete.call(this, request);
            } else {
                _complete.call(this, request, success);
            }
        };

        /**
         * Performs the actual send depending on the transport type details.
         * @param envelope the envelope to send
         * @param request the request information
         */
        _self.transportSend = function(envelope, request) {
            throw 'Abstract';
        };

        _self.transportSuccess = function(envelope, request, responses) {
            if (!request.expired) {
                this.clearTimeout(request.timeout);
                this.complete(request, true, request.metaConnect);
                if (responses && responses.length > 0) {
                    envelope.onSuccess(responses);
                } else {
                    envelope.onFailure(request.xhr, envelope.messages, {
                        httpCode: 204
                    });
                }
            }
        };

        _self.transportFailure = function(envelope, request, failure) {
            if (!request.expired) {
                this.clearTimeout(request.timeout);
                this.complete(request, false, request.metaConnect);
                envelope.onFailure(request.xhr, envelope.messages, failure);
            }
        };

        function _metaConnectSend(envelope) {
            if (_metaConnectRequest !== null) {
                throw 'Concurrent metaConnect requests not allowed, request id=' + _metaConnectRequest.id + ' not yet completed';
            }

            var requestId = ++_requestIds;
            this._debug('Transport', this.getType(), 'metaConnect send, request', requestId, 'envelope', envelope);
            var request = {
                id: requestId,
                metaConnect: true,
                envelope: envelope
            };
            _transportSend.call(this, envelope, request);
            _metaConnectRequest = request;
        }

        _self.send = function(envelope, metaConnect) {
            if (metaConnect) {
                _metaConnectSend.call(this, envelope);
            } else {
                _queueSend.call(this, envelope);
            }
        };

        _self.abort = function() {
            _super.abort();
            for (var i = 0; i < _requests.length; ++i) {
                var request = _requests[i];
                if (request) {
                    this._debug('Aborting request', request);
                    if (!this.abortXHR(request.xhr)) {
                        this.transportFailure(request.envelope, request, {reason: 'abort'});
                    }
                }
            }
            var metaConnectRequest = _metaConnectRequest;
            if (metaConnectRequest) {
                this._debug('Aborting metaConnect request', metaConnectRequest);
                if (!this.abortXHR(metaConnectRequest.xhr)) {
                    this.transportFailure(metaConnectRequest.envelope, metaConnectRequest, {reason: 'abort'});
                }
            }
            this.reset(true);
        };

        _self.reset = function(init) {
            _super.reset(init);
            _metaConnectRequest = null;
            _requests = [];
            _envelopes = [];
        };

        _self.abortXHR = function(xhr) {
            if (xhr) {
                try {
                    var state = xhr.readyState;
                    xhr.abort();
                    return state !== window.XMLHttpRequest.UNSENT;
                } catch (x) {
                    this._debug(x);
                }
            }
            return false;
        };

        _self.xhrStatus = function(xhr) {
            if (xhr) {
                try {
                    return xhr.status;
                } catch (x) {
                    this._debug(x);
                }
            }
            return -1;
        };

        return _self;
    };


    var LongPollingTransport = function() {
        var _super = new RequestTransport();
        var _self = Transport.derive(_super);
        // By default, support cross domain
        var _supportsCrossDomain = true;

        _self.accept = function(version, crossDomain, url) {
            return _supportsCrossDomain || !crossDomain;
        };

        _self.newXMLHttpRequest = function() {
            return new window.XMLHttpRequest();
        };

        _self.xhrSend = function(packet) {
            var xhr = _self.newXMLHttpRequest();
            // Copy external context, to be used in other environments.
            xhr.context = _self.context;
            xhr.withCredentials = true;
            xhr.open('POST', packet.url, packet.sync !== true);
            var headers = packet.headers;
            if (headers) {
                for (var headerName in headers) {
                    if (headers.hasOwnProperty(headerName)) {
                        xhr.setRequestHeader(headerName, headers[headerName]);
                    }
                }
            }
            xhr.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');
            xhr.onload = function() {
                if (xhr.status === 200) {
                    packet.onSuccess(xhr.responseText);
                } else {
                    packet.onError(xhr.statusText);
                }
            };
            xhr.onerror = function() {
                packet.onError(xhr.statusText);
            };
            xhr.send(packet.body);
            return xhr;
        };

        _self.transportSend = function(envelope, request) {
            this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelope);

            var self = this;
            try {
                var sameStack = true;
                request.xhr = this.xhrSend({
                    transport: this,
                    url: envelope.url,
                    sync: envelope.sync,
                    headers: this.getConfiguration().requestHeaders,
                    body: JSON.stringify(envelope.messages),
                    onSuccess: function(response) {
                        self._debug('Transport', self.getType(), 'received response', response);
                        var success = false;
                        try {
                            var received = self.convertToMessages(response);
                            if (received.length === 0) {
                                _supportsCrossDomain = false;
                                self.transportFailure(envelope, request, {
                                    httpCode: 204
                                });
                            } else {
                                success = true;
                                self.transportSuccess(envelope, request, received);
                            }
                        } catch (x) {
                            self._debug(x);
                            if (!success) {
                                _supportsCrossDomain = false;
                                var failure = {
                                    exception: x
                                };
                                failure.httpCode = self.xhrStatus(request.xhr);
                                self.transportFailure(envelope, request, failure);
                            }
                        }
                    },
                    onError: function(reason, exception) {
                        self._debug('Transport', self.getType(), 'received error', reason, exception);
                        _supportsCrossDomain = false;
                        var failure = {
                            reason: reason,
                            exception: exception
                        };
                        failure.httpCode = self.xhrStatus(request.xhr);
                        if (sameStack) {
                            // Keep the semantic of calling response callbacks asynchronously after the request
                            self.setTimeout(function() {
                                self.transportFailure(envelope, request, failure);
                            }, 0);
                        } else {
                            self.transportFailure(envelope, request, failure);
                        }
                    }
                });
                sameStack = false;
            } catch (x) {
                _supportsCrossDomain = false;
                // Keep the semantic of calling response callbacks asynchronously after the request
                this.setTimeout(function() {
                    self.transportFailure(envelope, request, {
                        exception: x
                    });
                }, 0);
            }
        };

        _self.reset = function(init) {
            _super.reset(init);
            _supportsCrossDomain = true;
        };

        return _self;
    };


    var CallbackPollingTransport = function() {
        var _super = new RequestTransport();
        var _self = Transport.derive(_super);
        var jsonp = 0;

        _self.accept = function(version, crossDomain, url) {
            return true;
        };

        _self.jsonpSend = function(packet) {
            var head = document.getElementsByTagName('head')[0];
            var script = document.createElement('script');

            var callbackName = '_cometd_jsonp_' + jsonp++;
            window[callbackName] = function(responseText) {
                head.removeChild(script);
                delete window[callbackName];
                packet.onSuccess(responseText);
            };

            var url = packet.url;
            url += url.indexOf('?') < 0 ? '?' : '&';
            url += 'jsonp=' + callbackName;
            url += '&message=' + encodeURIComponent(packet.body);
            script.src = url;
            script.async = packet.sync !== true;
            script.type = 'application/javascript';
            script.onerror = function(e) {
                packet.onError('jsonp ' + e.type);
            };
            head.appendChild(script);
        };

        function _failTransportFn(envelope, request, x) {
            var self = this;
            return function() {
                self.transportFailure(envelope, request, 'error', x);
            };
        }

        _self.transportSend = function(envelope, request) {
            var self = this;

            // Microsoft Internet Explorer has a 2083 URL max length
            // We must ensure that we stay within that length
            var start = 0;
            var length = envelope.messages.length;
            var lengths = [];
            while (length > 0) {
                // Encode the messages because all brackets, quotes, commas, colons, etc
                // present in the JSON will be URL encoded, taking many more characters
                var json = JSON.stringify(envelope.messages.slice(start, start + length));
                var urlLength = envelope.url.length + encodeURI(json).length;

                var maxLength = this.getConfiguration().maxURILength;
                if (urlLength > maxLength) {
                    if (length === 1) {
                        var x = 'Bayeux message too big (' + urlLength + ' bytes, max is ' + maxLength + ') ' +
                            'for transport ' + this.getType();
                        // Keep the semantic of calling response callbacks asynchronously after the request
                        this.setTimeout(_failTransportFn.call(this, envelope, request, x), 0);
                        return;
                    }

                    --length;
                    continue;
                }

                lengths.push(length);
                start += length;
                length = envelope.messages.length - start;
            }

            // Here we are sure that the messages can be sent within the URL limit

            var envelopeToSend = envelope;
            if (lengths.length > 1) {
                var begin = 0;
                var end = lengths[0];
                this._debug('Transport', this.getType(), 'split', envelope.messages.length, 'messages into', lengths.join(' + '));
                envelopeToSend = this._mixin(false, {}, envelope);
                envelopeToSend.messages = envelope.messages.slice(begin, end);
                envelopeToSend.onSuccess = envelope.onSuccess;
                envelopeToSend.onFailure = envelope.onFailure;

                for (var i = 1; i < lengths.length; ++i) {
                    var nextEnvelope = this._mixin(false, {}, envelope);
                    begin = end;
                    end += lengths[i];
                    nextEnvelope.messages = envelope.messages.slice(begin, end);
                    nextEnvelope.onSuccess = envelope.onSuccess;
                    nextEnvelope.onFailure = envelope.onFailure;
                    this.send(nextEnvelope, request.metaConnect);
                }
            }

            this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelopeToSend);

            try {
                var sameStack = true;
                this.jsonpSend({
                    transport: this,
                    url: envelopeToSend.url,
                    sync: envelopeToSend.sync,
                    headers: this.getConfiguration().requestHeaders,
                    body: JSON.stringify(envelopeToSend.messages),
                    onSuccess: function(responses) {
                        var success = false;
                        try {
                            var received = self.convertToMessages(responses);
                            if (received.length === 0) {
                                self.transportFailure(envelopeToSend, request, {
                                    httpCode: 204
                                });
                            } else {
                                success = true;
                                self.transportSuccess(envelopeToSend, request, received);
                            }
                        } catch (x) {
                            self._debug(x);
                            if (!success) {
                                self.transportFailure(envelopeToSend, request, {
                                    exception: x
                                });
                            }
                        }
                    },
                    onError: function(reason, exception) {
                        var failure = {
                            reason: reason,
                            exception: exception
                        };
                        if (sameStack) {
                            // Keep the semantic of calling response callbacks asynchronously after the request
                            self.setTimeout(function() {
                                self.transportFailure(envelopeToSend, request, failure);
                            }, 0);
                        } else {
                            self.transportFailure(envelopeToSend, request, failure);
                        }
                    }
                });
                sameStack = false;
            } catch (xx) {
                // Keep the semantic of calling response callbacks asynchronously after the request
                this.setTimeout(function() {
                    self.transportFailure(envelopeToSend, request, {
                        exception: xx
                    });
                }, 0);
            }
        };

        return _self;
    };


    var WebSocketTransport = function() {
        var _super = new Transport();
        var _self = Transport.derive(_super);
        var _cometd;
        // By default WebSocket is supported
        var _webSocketSupported = true;
        // Whether we were able to establish a WebSocket connection
        var _webSocketConnected = false;
        var _stickyReconnect = true;
        // The context contains the envelopes that have been sent
        // and the timeouts for the messages that have been sent.
        var _context = null;
        var _connecting = null;
        var _connected = false;
        var _successCallback = null;

        _self.reset = function(init) {
            _super.reset(init);
            _webSocketSupported = true;
            if (init) {
                _webSocketConnected = false;
            }
            _stickyReconnect = true;
            _context = null;
            _connecting = null;
            _connected = false;
        };

        function _forceClose(context, event) {
            if (context) {
                this.webSocketClose(context, event.code, event.reason);
                // Force immediate failure of pending messages to trigger reconnect.
                // This is needed because the server may not reply to our close()
                // and therefore the onclose function is never called.
                this.onClose(context, event);
            }
        }

        function _sameContext(context) {
            return context === _connecting || context === _context;
        }

        function _storeEnvelope(context, envelope, metaConnect) {
            var messageIds = [];
            for (var i = 0; i < envelope.messages.length; ++i) {
                var message = envelope.messages[i];
                if (message.id) {
                    messageIds.push(message.id);
                }
            }
            context.envelopes[messageIds.join(',')] = [envelope, metaConnect];
            this._debug('Transport', this.getType(), 'stored envelope, envelopes', context.envelopes);
        }

        function _websocketConnect(context) {
            // We may have multiple attempts to open a WebSocket
            // connection, for example a /meta/connect request that
            // may take time, along with a user-triggered publish.
            // Early return if we are already connecting.
            if (_connecting) {
                return;
            }

            // Mangle the URL, changing the scheme from 'http' to 'ws'.
            var url = _cometd.getURL().replace(/^http/, 'ws');
            this._debug('Transport', this.getType(), 'connecting to URL', url);

            try {
                var protocol = _cometd.getConfiguration().protocol;
                context.webSocket = protocol ? new window.WebSocket(url, protocol) : new window.WebSocket(url);
                _connecting = context;
            } catch (x) {
                _webSocketSupported = false;
                this._debug('Exception while creating WebSocket object', x);
                throw x;
            }

            // By default use sticky reconnects.
            _stickyReconnect = _cometd.getConfiguration().stickyReconnect !== false;

            var self = this;
            var connectTimeout = _cometd.getConfiguration().connectTimeout;
            if (connectTimeout > 0) {
                context.connectTimer = this.setTimeout(function() {
                    _cometd._debug('Transport', self.getType(), 'timed out while connecting to URL', url, ':', connectTimeout, 'ms');
                    // The connection was not opened, close anyway.
                    _forceClose.call(self, context, {code: 1000, reason: 'Connect Timeout'});
                }, connectTimeout);
            }

            var onopen = function() {
                _cometd._debug('WebSocket onopen', context);
                if (context.connectTimer) {
                    self.clearTimeout(context.connectTimer);
                }

                if (_sameContext(context)) {
                    _connecting = null;
                    _context = context;
                    _webSocketConnected = true;
                    self.onOpen(context);
                } else {
                    // We have a valid connection already, close this one.
                    _cometd._warn('Closing extra WebSocket connection', this, 'active connection', _context);
                    _forceClose.call(self, context, {code: 1000, reason: 'Extra Connection'});
                }
            };

            // This callback is invoked when the server sends the close frame.
            // The close frame for a connection may arrive *after* another
            // connection has been opened, so we must make sure that actions
            // are performed only if it's the same connection.
            var onclose = function(event) {
                event = event || {code: 1000};
                _cometd._debug('WebSocket onclose', context, event, 'connecting', _connecting, 'current', _context);

                if (context.connectTimer) {
                    self.clearTimeout(context.connectTimer);
                }

                self.onClose(context, event);
            };

            var onmessage = function(wsMessage) {
                _cometd._debug('WebSocket onmessage', wsMessage, context);
                self.onMessage(context, wsMessage);
            };

            context.webSocket.onopen = onopen;
            context.webSocket.onclose = onclose;
            context.webSocket.onerror = function() {
                // Clients should call onclose(), but if they do not we do it here for safety.
                onclose({code: 1000, reason: 'Error'});
            };
            context.webSocket.onmessage = onmessage;

            this._debug('Transport', this.getType(), 'configured callbacks on', context);
        }

        function _webSocketSend(context, envelope, metaConnect) {
            var json = JSON.stringify(envelope.messages);
            context.webSocket.send(json);
            this._debug('Transport', this.getType(), 'sent', envelope, 'metaConnect =', metaConnect);

            // Manage the timeout waiting for the response.
            var maxDelay = this.getConfiguration().maxNetworkDelay;
            var delay = maxDelay;
            if (metaConnect) {
                delay += this.getAdvice().timeout;
                _connected = true;
            }

            var self = this;
            var messageIds = [];
            for (var i = 0; i < envelope.messages.length; ++i) {
                (function() {
                    var message = envelope.messages[i];
                    if (message.id) {
                        messageIds.push(message.id);
                        context.timeouts[message.id] = self.setTimeout(function() {
                            _cometd._debug('Transport', self.getType(), 'timing out message', message.id, 'after', delay, 'on', context);
                            _forceClose.call(self, context, {code: 1000, reason: 'Message Timeout'});
                        }, delay);
                    }
                })();
            }

            this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for messages', messageIds, 'maxNetworkDelay', maxDelay, ', timeouts:', context.timeouts);
        }

        _self._notifySuccess = function(fn, messages) {
            fn.call(this, messages);
        };

        _self._notifyFailure = function(fn, context, messages, failure) {
            fn.call(this, context, messages, failure);
        };

        function _send(context, envelope, metaConnect) {
            try {
                if (context === null) {
                    context = _connecting || {
                            envelopes: {},
                            timeouts: {}
                        };
                    _storeEnvelope.call(this, context, envelope, metaConnect);
                    _websocketConnect.call(this, context);
                } else {
                    _storeEnvelope.call(this, context, envelope, metaConnect);
                    _webSocketSend.call(this, context, envelope, metaConnect);
                }
            } catch (x) {
                // Keep the semantic of calling response callbacks asynchronously after the request.
                var self = this;
                this.setTimeout(function() {
                    _forceClose.call(self, context, {
                        code: 1000,
                        reason: 'Exception',
                        exception: x
                    });
                }, 0);
            }
        }

        _self.onOpen = function(context) {
            var envelopes = context.envelopes;
            this._debug('Transport', this.getType(), 'opened', context, 'pending messages', envelopes);
            for (var key in envelopes) {
                if (envelopes.hasOwnProperty(key)) {
                    var element = envelopes[key];
                    var envelope = element[0];
                    var metaConnect = element[1];
                    // Store the success callback, which is independent from the envelope,
                    // so that it can be used to notify arrival of messages.
                    _successCallback = envelope.onSuccess;
                    _webSocketSend.call(this, context, envelope, metaConnect);
                }
            }
        };

        _self.onMessage = function(context, wsMessage) {
            this._debug('Transport', this.getType(), 'received websocket message', wsMessage, context);

            var close = false;
            var messages = this.convertToMessages(wsMessage.data);
            var messageIds = [];
            for (var i = 0; i < messages.length; ++i) {
                var message = messages[i];

                // Detect if the message is a response to a request we made.
                // If it's a meta message, for sure it's a response; otherwise it's
                // a publish message and publish responses don't have the data field.
                if (/^\/meta\//.test(message.channel) || message.data === undefined) {
                    if (message.id) {
                        messageIds.push(message.id);

                        var timeout = context.timeouts[message.id];
                        if (timeout) {
                            this.clearTimeout(timeout);
                            delete context.timeouts[message.id];
                            this._debug('Transport', this.getType(), 'removed timeout for message', message.id, ', timeouts', context.timeouts);
                        }
                    }
                }

                if ('/meta/connect' === message.channel) {
                    _connected = false;
                }
                if ('/meta/disconnect' === message.channel && !_connected) {
                    close = true;
                }
            }

            // Remove the envelope corresponding to the messages.
            var removed = false;
            var envelopes = context.envelopes;
            for (var j = 0; j < messageIds.length; ++j) {
                var id = messageIds[j];
                for (var key in envelopes) {
                    if (envelopes.hasOwnProperty(key)) {
                        var ids = key.split(',');
                        var index = Utils.inArray(id, ids);
                        if (index >= 0) {
                            removed = true;
                            ids.splice(index, 1);
                            var envelope = envelopes[key][0];
                            var metaConnect = envelopes[key][1];
                            delete envelopes[key];
                            if (ids.length > 0) {
                                envelopes[ids.join(',')] = [envelope, metaConnect];
                            }
                            break;
                        }
                    }
                }
            }
            if (removed) {
                this._debug('Transport', this.getType(), 'removed envelope, envelopes', envelopes);
            }

            this._notifySuccess(_successCallback, messages);

            if (close) {
                this.webSocketClose(context, 1000, 'Disconnect');
            }
        };

        _self.onClose = function(context, event) {
            this._debug('Transport', this.getType(), 'closed', context, event);

            if (_sameContext(context)) {
                // Remember if we were able to connect.
                // This close event could be due to server shutdown,
                // and if it restarts we want to try websocket again.
                _webSocketSupported = _stickyReconnect && _webSocketConnected;
                _connecting = null;
                _context = null;
            }

            var timeouts = context.timeouts;
            context.timeouts = {};
            for (var id in timeouts) {
                if (timeouts.hasOwnProperty(id)) {
                    this.clearTimeout(timeouts[id]);
                }
            }

            var envelopes = context.envelopes;
            context.envelopes = {};
            for (var key in envelopes) {
                if (envelopes.hasOwnProperty(key)) {
                    var envelope = envelopes[key][0];
                    var metaConnect = envelopes[key][1];
                    if (metaConnect) {
                        _connected = false;
                    }
                    var failure = {
                        websocketCode: event.code,
                        reason: event.reason
                    };
                    if (event.exception) {
                        failure.exception = event.exception;
                    }
                    this._notifyFailure(envelope.onFailure, context, envelope.messages, failure);
                }
            }
        };

        _self.registered = function(type, cometd) {
            _super.registered(type, cometd);
            _cometd = cometd;
        };

        _self.accept = function(version, crossDomain, url) {
            this._debug('Transport', this.getType(), 'accept, supported:', _webSocketSupported);
            // Using !! to return a boolean (and not the WebSocket object).
            return _webSocketSupported && !!window.WebSocket && _cometd.websocketEnabled !== false;
        };

        _self.send = function(envelope, metaConnect) {
            this._debug('Transport', this.getType(), 'sending', envelope, 'metaConnect =', metaConnect);
            _send.call(this, _context, envelope, metaConnect);
        };

        _self.webSocketClose = function(context, code, reason) {
            try {
                if (context.webSocket) {
                    context.webSocket.close(code, reason);
                }
            } catch (x) {
                this._debug(x);
            }
        };

        _self.abort = function() {
            _super.abort();
            _forceClose.call(this, _context, {code: 1000, reason: 'Abort'});
            this.reset(true);
        };

        return _self;
    };


    /**
     * The constructor for a CometD object, identified by an optional name.
     * The default name is the string 'default'.
     * @param name the optional name of this cometd object
     */
    var CometD = function (name) {
        var _cometd = this;
        var _name = name || 'default';
        var _crossDomain = false;
        var _transports = new TransportRegistry();
        var _transport;
        var _status = 'disconnected';
        var _messageId = 0;
        var _clientId = null;
        var _batch = 0;
        var _messageQueue = [];
        var _internalBatch = false;
        var _listenerId = 0;
        var _listeners = {};
        var _backoff = 0;
        var _scheduledSend = null;
        var _extensions = [];
        var _advice = {};
        var _handshakeProps;
        var _handshakeCallback;
        var _callbacks = {};
        var _remoteCalls = {};
        var _reestablish = false;
        var _connected = false;
        var _unconnectTime = 0;
        var _handshakeMessages = 0;
        var _config = {
            protocol: null,
            stickyReconnect: true,
            connectTimeout: 0,
            maxConnections: 2,
            backoffIncrement: 1000,
            maxBackoff: 60000,
            logLevel: 'info',
            maxNetworkDelay: 10000,
            requestHeaders: {},
            appendMessageTypeToURL: true,
            autoBatch: false,
            urls: {},
            maxURILength: 2000,
            advice: {
                timeout: 60000,
                interval: 0,
                reconnect: undefined,
                maxInterval: 0
            }
        };

        function _fieldValue(object, name) {
            try {
                return object[name];
            } catch (x) {
                return undefined;
            }
        }

        /**
         * Mixes in the given objects into the target object by copying the properties.
         * @param deep if the copy must be deep
         * @param target the target object
         * @param objects the objects whose properties are copied into the target
         */
        this._mixin = function(deep, target, objects) {
            var result = target || {};

            // Skip first 2 parameters (deep and target), and loop over the others
            for (var i = 2; i < arguments.length; ++i) {
                var object = arguments[i];

                if (object === undefined || object === null) {
                    continue;
                }

                for (var propName in object) {
                    if (object.hasOwnProperty(propName)) {
                        var prop = _fieldValue(object, propName);
                        var targ = _fieldValue(result, propName);

                        // Avoid infinite loops
                        if (prop === target) {
                            continue;
                        }
                        // Do not mixin undefined values
                        if (prop === undefined) {
                            continue;
                        }

                        if (deep && typeof prop === 'object' && prop !== null) {
                            if (prop instanceof Array) {
                                result[propName] = this._mixin(deep, targ instanceof Array ? targ : [], prop);
                            } else {
                                var source = typeof targ === 'object' && !(targ instanceof Array) ? targ : {};
                                result[propName] = this._mixin(deep, source, prop);
                            }
                        } else {
                            result[propName] = prop;
                        }
                    }
                }
            }

            return result;
        };

        function _isString(value) {
            return Utils.isString(value);
        }

        function _isFunction(value) {
            if (value === undefined || value === null) {
                return false;
            }
            return typeof value === 'function';
        }

        function _zeroPad(value, length) {
            var result = '';
            while (--length > 0) {
                if (value >= Math.pow(10, length)) {
                    break;
                }
                result += '0';
            }
            result += value;
            return result;
        }

        function _log(level, args) {
            if (window.console) {
                var logger = window.console[level];
                if (_isFunction(logger)) {
                    var now = new Date();
                    [].splice.call(args, 0, 0, _zeroPad(now.getHours(), 2) + ':' + _zeroPad(now.getMinutes(), 2) + ':' +
                        _zeroPad(now.getSeconds(), 2) + '.' + _zeroPad(now.getMilliseconds(), 3));
                    logger.apply(window.console, args);
                }
            }
        }

        this._warn = function() {
            _log('warn', arguments);
        };

        this._info = function() {
            if (_config.logLevel !== 'warn') {
                _log('info', arguments);
            }
        };

        this._debug = function() {
            if (_config.logLevel === 'debug') {
                _log('debug', arguments);
            }
        };

        function _splitURL(url) {
            // [1] = protocol://,
            // [2] = host:port,
            // [3] = host,
            // [4] = IPv6_host,
            // [5] = IPv4_host,
            // [6] = :port,
            // [7] = port,
            // [8] = uri,
            // [9] = rest (query / fragment)
            return /(^https?:\/\/)?(((\[[^\]]+\])|([^:\/\?#]+))(:(\d+))?)?([^\?#]*)(.*)?/.exec(url);
        }

        /**
         * Returns whether the given hostAndPort is cross domain.
         * The default implementation checks against window.location.host
         * but this function can be overridden to make it work in non-browser
         * environments.
         *
         * @param hostAndPort the host and port in format host:port
         * @return whether the given hostAndPort is cross domain
         */
        this._isCrossDomain = function(hostAndPort) {
            if (window.location && window.location.host) {
                if (hostAndPort) {
                    return hostAndPort !== window.location.host;
                }
            }
            return false;
        };

        function _configure(configuration) {
            _cometd._debug('Configuring cometd object with', configuration);
            // Support old style param, where only the Bayeux server URL was passed
            if (_isString(configuration)) {
                configuration = { url: configuration };
            }
            if (!configuration) {
                configuration = {};
            }

            _config = _cometd._mixin(false, _config, configuration);

            var url = _cometd.getURL();
            if (!url) {
                throw 'Missing required configuration parameter \'url\' specifying the Bayeux server URL';
            }

            // Check if we're cross domain.
            var urlParts = _splitURL(url);
            var hostAndPort = urlParts[2];
            var uri = urlParts[8];
            var afterURI = urlParts[9];
            _crossDomain = _cometd._isCrossDomain(hostAndPort);

            // Check if appending extra path is supported
            if (_config.appendMessageTypeToURL) {
                if (afterURI !== undefined && afterURI.length > 0) {
                    _cometd._info('Appending message type to URI ' + uri + afterURI + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
                    _config.appendMessageTypeToURL = false;
                } else {
                    var uriSegments = uri.split('/');
                    var lastSegmentIndex = uriSegments.length - 1;
                    if (uri.match(/\/$/)) {
                        lastSegmentIndex -= 1;
                    }
                    if (uriSegments[lastSegmentIndex].indexOf('.') >= 0) {
                        // Very likely the CometD servlet's URL pattern is mapped to an extension, such as *.cometd
                        // It will be difficult to add the extra path in this case
                        _cometd._info('Appending message type to URI ' + uri + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
                        _config.appendMessageTypeToURL = false;
                    }
                }
            }
        }

        function _removeListener(subscription) {
            if (subscription) {
                var subscriptions = _listeners[subscription.channel];
                if (subscriptions && subscriptions[subscription.id]) {
                    delete subscriptions[subscription.id];
                    _cometd._debug('Removed', subscription.listener ? 'listener' : 'subscription', subscription);
                }
            }
        }

        function _removeSubscription(subscription) {
            if (subscription && !subscription.listener) {
                _removeListener(subscription);
            }
        }

        function _clearSubscriptions() {
            for (var channel in _listeners) {
                if (_listeners.hasOwnProperty(channel)) {
                    var subscriptions = _listeners[channel];
                    if (subscriptions) {
                        for (var id in subscriptions) {
                            if (subscriptions.hasOwnProperty(id)) {
                                _removeSubscription(subscriptions[id]);
                            }
                        }
                    }
                }
            }
        }

        function _setStatus(newStatus) {
            if (_status !== newStatus) {
                _cometd._debug('Status', _status, '->', newStatus);
                _status = newStatus;
            }
        }

        function _isDisconnected() {
            return _status === 'disconnecting' || _status === 'disconnected';
        }

        function _nextMessageId() {
            var result = ++_messageId;
            return '' + result;
        }

        function _applyExtension(scope, callback, name, message, outgoing) {
            try {
                return callback.call(scope, message);
            } catch (x) {
                var handler = _cometd.onExtensionException;
                if (_isFunction(handler)) {
                    _cometd._debug('Invoking extension exception handler', name, x);
                    try {
                        handler.call(_cometd, x, name, outgoing, message);
                    } catch (xx) {
                        _cometd._info('Exception during execution of extension exception handler', name, xx);
                    }
                } else {
                    _cometd._info('Exception during execution of extension', name, x);
                }
                return message;
            }
        }

        function _applyIncomingExtensions(message) {
            for (var i = 0; i < _extensions.length; ++i) {
                if (message === undefined || message === null) {
                    break;
                }

                var extension = _extensions[i];
                var callback = extension.extension.incoming;
                if (_isFunction(callback)) {
                    var result = _applyExtension(extension.extension, callback, extension.name, message, false);
                    message = result === undefined ? message : result;
                }
            }
            return message;
        }

        function _applyOutgoingExtensions(message) {
            for (var i = _extensions.length - 1; i >= 0 ; --i) {
                if (message === undefined || message === null) {
                    break;
                }

                var extension = _extensions[i];
                var callback = extension.extension.outgoing;
                if (_isFunction(callback)) {
                    var result = _applyExtension(extension.extension, callback, extension.name, message, true);
                    message = result === undefined ? message : result;
                }
            }
            return message;
        }

        function _notify(channel, message) {
            var subscriptions = _listeners[channel];
            if (subscriptions) {
                for (var id in subscriptions) {
                    if (subscriptions.hasOwnProperty(id)) {
                        var subscription = subscriptions[id];
                        // Subscriptions may come and go, so the array may have 'holes'
                        if (subscription) {
                            try {
                                subscription.callback.call(subscription.scope, message);
                            } catch (x) {
                                var handler = _cometd.onListenerException;
                                if (_isFunction(handler)) {
                                    _cometd._debug('Invoking listener exception handler', subscription, x);
                                    try {
                                        handler.call(_cometd, x, subscription, subscription.listener, message);
                                    } catch (xx) {
                                        _cometd._info('Exception during execution of listener exception handler', subscription, xx);
                                    }
                                } else {
                                    _cometd._info('Exception during execution of listener', subscription, message, x);
                                }
                            }
                        }
                    }
                }
            }
        }

        function _notifyListeners(channel, message) {
            // Notify direct listeners
            _notify(channel, message);

            // Notify the globbing listeners
            var channelParts = channel.split('/');
            var last = channelParts.length - 1;
            for (var i = last; i > 0; --i) {
                var channelPart = channelParts.slice(0, i).join('/') + '/*';
                // We don't want to notify /foo/* if the channel is /foo/bar/baz,
                // so we stop at the first non recursive globbing
                if (i === last) {
                    _notify(channelPart, message);
                }
                // Add the recursive globber and notify
                channelPart += '*';
                _notify(channelPart, message);
            }
        }

        function _cancelDelayedSend() {
            if (_scheduledSend !== null) {
                Utils.clearTimeout(_scheduledSend);
            }
            _scheduledSend = null;
        }

        function _delayedSend(operation, delay) {
            _cancelDelayedSend();
            var time = _advice.interval + delay;
            _cometd._debug('Function scheduled in', time, 'ms, interval =', _advice.interval, 'backoff =', _backoff, operation);
            _scheduledSend = Utils.setTimeout(_cometd, operation, time);
        }

        // Needed to break cyclic dependencies between function definitions
        var _handleMessages;
        var _handleFailure;

        /**
         * Delivers the messages to the CometD server
         * @param sync whether the send is synchronous
         * @param messages the array of messages to send
         * @param metaConnect true if this send is on /meta/connect
         * @param extraPath an extra path to append to the Bayeux server URL
         */
        function _send(sync, messages, metaConnect, extraPath) {
            // We must be sure that the messages have a clientId.
            // This is not guaranteed since the handshake may take time to return
            // (and hence the clientId is not known yet) and the application
            // may create other messages.
            for (var i = 0; i < messages.length; ++i) {
                var message = messages[i];
                var messageId = message.id;

                if (_clientId) {
                    message.clientId = _clientId;
                }

                message = _applyOutgoingExtensions(message);
                if (message !== undefined && message !== null) {
                    // Extensions may have modified the message id, but we need to own it.
                    message.id = messageId;
                    messages[i] = message;
                } else {
                    delete _callbacks[messageId];
                    messages.splice(i--, 1);
                }
            }

            if (messages.length === 0) {
                return;
            }

            var url = _cometd.getURL();
            if (_config.appendMessageTypeToURL) {
                // If url does not end with '/', then append it
                if (!url.match(/\/$/)) {
                    url = url + '/';
                }
                if (extraPath) {
                    url = url + extraPath;
                }
            }

            var envelope = {
                url: url,
                sync: sync,
                messages: messages,
                onSuccess: function(rcvdMessages) {
                    try {
                        _handleMessages.call(_cometd, rcvdMessages);
                    } catch (x) {
                        _cometd._info('Exception during handling of messages', x);
                    }
                },
                onFailure: function(conduit, messages, failure) {
                    try {
                        var transport = _cometd.getTransport();
                        failure.connectionType = transport ? transport.getType() : "unknown";
                        _handleFailure.call(_cometd, conduit, messages, failure);
                    } catch (x) {
                        _cometd._info('Exception during handling of failure', x);
                    }
                }
            };
            _cometd._debug('Send', envelope);
            _transport.send(envelope, metaConnect);
        }

        function _queueSend(message) {
            if (_batch > 0 || _internalBatch === true) {
                _messageQueue.push(message);
            } else {
                _send(false, [message], false);
            }
        }

        /**
         * Sends a complete bayeux message.
         * This method is exposed as a public so that extensions may use it
         * to send bayeux message directly, for example in case of re-sending
         * messages that have already been sent but that for some reason must
         * be resent.
         */
        this.send = _queueSend;

        function _resetBackoff() {
            _backoff = 0;
        }

        function _increaseBackoff() {
            if (_backoff < _config.maxBackoff) {
                _backoff += _config.backoffIncrement;
            }
            return _backoff;
        }

        /**
         * Starts a the batch of messages to be sent in a single request.
         * @see #_endBatch(sendMessages)
         */
        function _startBatch() {
            ++_batch;
            _cometd._debug('Starting batch, depth', _batch);
        }

        function _flushBatch() {
            var messages = _messageQueue;
            _messageQueue = [];
            if (messages.length > 0) {
                _send(false, messages, false);
            }
        }

        /**
         * Ends the batch of messages to be sent in a single request,
         * optionally sending messages present in the message queue depending
         * on the given argument.
         * @see #_startBatch()
         */
        function _endBatch() {
            --_batch;
            _cometd._debug('Ending batch, depth', _batch);
            if (_batch < 0) {
                throw 'Calls to startBatch() and endBatch() are not paired';
            }

            if (_batch === 0 && !_isDisconnected() && !_internalBatch) {
                _flushBatch();
            }
        }

        /**
         * Sends the connect message
         */
        function _connect() {
            if (!_isDisconnected()) {
                var bayeuxMessage = {
                    id: _nextMessageId(),
                    channel: '/meta/connect',
                    connectionType: _transport.getType()
                };

                // In case of reload or temporary loss of connection
                // we want the next successful connect to return immediately
                // instead of being held by the server, so that connect listeners
                // can be notified that the connection has been re-established
                if (!_connected) {
                    bayeuxMessage.advice = { timeout: 0 };
                }

                _setStatus('connecting');
                _cometd._debug('Connect sent', bayeuxMessage);
                _send(false, [bayeuxMessage], true, 'connect');
                _setStatus('connected');
            }
        }

        function _delayedConnect(delay) {
            _setStatus('connecting');
            _delayedSend(function() {
                _connect();
            }, delay);
        }

        function _updateAdvice(newAdvice) {
            if (newAdvice) {
                _advice = _cometd._mixin(false, {}, _config.advice, newAdvice);
                _cometd._debug('New advice', _advice);
            }
        }

        function _disconnect(abort) {
            _cancelDelayedSend();
            if (abort && _transport) {
                _transport.abort();
            }
            _clientId = null;
            _setStatus('disconnected');
            _batch = 0;
            _resetBackoff();
            _transport = null;
            _reestablish = false;
            _connected = false;

            // Fail any existing queued message
            if (_messageQueue.length > 0) {
                var messages = _messageQueue;
                _messageQueue = [];
                _handleFailure.call(_cometd, undefined, messages, {
                    reason: 'Disconnected'
                });
            }
        }

        function _notifyTransportException(oldTransport, newTransport, failure) {
            var handler = _cometd.onTransportException;
            if (_isFunction(handler)) {
                _cometd._debug('Invoking transport exception handler', oldTransport, newTransport, failure);
                try {
                    handler.call(_cometd, failure, oldTransport, newTransport);
                } catch (x) {
                    _cometd._info('Exception during execution of transport exception handler', x);
                }
            }
        }

        /**
         * Sends the initial handshake message
         */
        function _handshake(handshakeProps, handshakeCallback) {
            if (_isFunction(handshakeProps)) {
                handshakeCallback = handshakeProps;
                handshakeProps = undefined;
            }

            _clientId = null;

            _clearSubscriptions();

            // Reset the transports if we're not retrying the handshake
            if (_isDisconnected()) {
                _transports.reset(true);
            }

            // Reset the advice.
            _updateAdvice({});

            _batch = 0;

            // Mark the start of an internal batch.
            // This is needed because handshake and connect are async.
            // It may happen that the application calls init() then subscribe()
            // and the subscribe message is sent before the connect message, if
            // the subscribe message is not held until the connect message is sent.
            // So here we start a batch to hold temporarily any message until
            // the connection is fully established.
            _internalBatch = true;

            // Save the properties provided by the user, so that
            // we can reuse them during automatic re-handshake
            _handshakeProps = handshakeProps;
            _handshakeCallback = handshakeCallback;

            var version = '1.0';

            // Figure out the transports to send to the server
            var url = _cometd.getURL();
            var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);

            var bayeuxMessage = {
                id: _nextMessageId(),
                version: version,
                minimumVersion: version,
                channel: '/meta/handshake',
                supportedConnectionTypes: transportTypes,
                advice: {
                    timeout: _advice.timeout,
                    interval: _advice.interval
                }
            };
            // Do not allow the user to override important fields.
            var message = _cometd._mixin(false, {}, _handshakeProps, bayeuxMessage);

            // Save the callback.
            _cometd._putCallback(message.id, handshakeCallback);

            // Pick up the first available transport as initial transport
            // since we don't know if the server supports it
            if (!_transport) {
                _transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);
                if (!_transport) {
                    var failure = 'Could not find initial transport among: ' + _transports.getTransportTypes();
                    _cometd._warn(failure);
                    throw failure;
                }
            }

            _cometd._debug('Initial transport is', _transport.getType());

            // We started a batch to hold the application messages,
            // so here we must bypass it and send immediately.
            _setStatus('handshaking');
            _cometd._debug('Handshake sent', message);
            _send(false, [message], false, 'handshake');
        }

        function _delayedHandshake(delay) {
            _setStatus('handshaking');

            // We will call _handshake() which will reset _clientId, but we want to avoid
            // that between the end of this method and the call to _handshake() someone may
            // call publish() (or other methods that call _queueSend()).
            _internalBatch = true;

            _delayedSend(function() {
                _handshake(_handshakeProps, _handshakeCallback);
            }, delay);
        }

        function _notifyCallback(callback, message) {
            try {
                callback.call(_cometd, message);
            } catch (x) {
                var handler = _cometd.onCallbackException;
                if (_isFunction(handler)) {
                    _cometd._debug('Invoking callback exception handler', x);
                    try {
                        handler.call(_cometd, x, message);
                    } catch (xx) {
                        _cometd._info('Exception during execution of callback exception handler', xx);
                    }
                } else {
                    _cometd._info('Exception during execution of message callback', x);
                }
            }
        }

        this._getCallback = function(messageId) {
            return _callbacks[messageId];
        };

        this._putCallback = function(messageId, callback) {
            var result = this._getCallback(messageId);
            if (_isFunction(callback)) {
                _callbacks[messageId] = callback;
            }
            return result;
        };

        function _handleCallback(message) {
            var callback = _cometd._getCallback([message.id]);
            if (_isFunction(callback)) {
                delete _callbacks[message.id];
                _notifyCallback(callback, message);
            }
        }

        function _handleRemoteCall(message) {
            var context = _remoteCalls[message.id];
            delete _remoteCalls[message.id];
            if (context) {
                _cometd._debug('Handling remote call response for', message, 'with context', context);

                // Clear the timeout, if present.
                var timeout = context.timeout;
                if (timeout) {
                    Utils.clearTimeout(timeout);
                }

                var callback = context.callback;
                if (_isFunction(callback)) {
                    _notifyCallback(callback, message);
                    return true;
                }
            }
            return false;
        }

        this.onTransportFailure = function(message, failureInfo, failureHandler) {
            this._debug('Transport failure', failureInfo, 'for', message);

            var transports = this.getTransportRegistry();
            var url = this.getURL();
            var crossDomain = this._isCrossDomain(_splitURL(url)[2]);
            var version = '1.0';
            var transportTypes = transports.findTransportTypes(version, crossDomain, url);

            if (failureInfo.action === 'none') {
                if (message.channel === '/meta/handshake') {
                    if (!failureInfo.transport) {
                        var failure = 'Could not negotiate transport, client=[' + transportTypes + '], server=[' + message.supportedConnectionTypes + ']';
                        this._warn(failure);
                        _notifyTransportException(_transport.getType(), null, {
                            reason: failure,
                            connectionType: _transport.getType(),
                            transport: _transport
                        });
                    }
                }
            } else {
                failureInfo.delay = this.getBackoffPeriod();
                // Different logic depending on whether we are handshaking or connecting.
                if (message.channel === '/meta/handshake') {
                    if (!failureInfo.transport) {
                        // The transport is invalid, try to negotiate again.
                        var newTransport = transports.negotiateTransport(transportTypes, version, crossDomain, url);
                        if (!newTransport) {
                            this._warn('Could not negotiate transport, client=[' + transportTypes + ']');
                            _notifyTransportException(_transport.getType(), null, message.failure);
                            failureInfo.action = 'none';
                        } else {
                            this._debug('Transport', _transport.getType(), '->', newTransport.getType());
                            _notifyTransportException(_transport.getType(), newTransport.getType(), message.failure);
                            failureInfo.action = 'handshake';
                            failureInfo.transport = newTransport;
                        }
                    }

                    if (failureInfo.action !== 'none') {
                        this.increaseBackoffPeriod();
                    }
                } else {
                    var now = new Date().getTime();

                    if (_unconnectTime === 0) {
                        _unconnectTime = now;
                    }

                    if (failureInfo.action === 'retry') {
                        failureInfo.delay = this.increaseBackoffPeriod();
                        // Check whether we may switch to handshaking.
                        var maxInterval = _advice.maxInterval;
                        if (maxInterval > 0) {
                            var expiration = _advice.timeout + _advice.interval + maxInterval;
                            var unconnected = now - _unconnectTime;
                            if (unconnected + _backoff > expiration) {
                                failureInfo.action = 'handshake';
                            }
                        }
                    }

                    if (failureInfo.action === 'handshake') {
                        failureInfo.delay = 0;
                        transports.reset(false);
                        this.resetBackoffPeriod();
                    }
                }
            }

            failureHandler.call(_cometd, failureInfo);
        };

        function _handleTransportFailure(failureInfo) {
            _cometd._debug('Transport failure handling', failureInfo);

            if (failureInfo.transport) {
                _transport = failureInfo.transport;
            }

            if (failureInfo.url) {
                _transport.setURL(failureInfo.url);
            }

            var action = failureInfo.action;
            var delay = failureInfo.delay || 0;
            switch (action) {
                case 'handshake':
                    _delayedHandshake(delay);
                    break;
                case 'retry':
                    _delayedConnect(delay);
                    break;
                case 'none':
                    _disconnect(true);
                    break;
                default:
                    throw 'Unknown action ' + action;
            }
        }

        function _failHandshake(message, failureInfo) {
            _handleCallback(message);
            _notifyListeners('/meta/handshake', message);
            _notifyListeners('/meta/unsuccessful', message);

            // The listeners may have disconnected.
            if (_isDisconnected()) {
                failureInfo.action = 'none';
            }

            _cometd.onTransportFailure.call(_cometd, message, failureInfo, _handleTransportFailure);
        }

        function _handshakeResponse(message) {
            var url = _cometd.getURL();
            if (message.successful) {
                var crossDomain = _cometd._isCrossDomain(_splitURL(url)[2]);
                var newTransport = _transports.negotiateTransport(message.supportedConnectionTypes, message.version, crossDomain, url);
                if (newTransport === null) {
                    message.successful = false;
                    _failHandshake(message, {
                        cause: 'negotiation',
                        action: 'none',
                        transport: null
                    });
                    return;
                } else if (_transport !== newTransport) {
                    _cometd._debug('Transport', _transport.getType(), '->', newTransport.getType());
                    _transport = newTransport;
                }

                _clientId = message.clientId;

                // End the internal batch and allow held messages from the application
                // to go to the server (see _handshake() where we start the internal batch).
                _internalBatch = false;
                _flushBatch();

                // Here the new transport is in place, as well as the clientId, so
                // the listeners can perform a publish() if they want.
                // Notify the listeners before the connect below.
                message.reestablish = _reestablish;
                _reestablish = true;

                _handleCallback(message);
                _notifyListeners('/meta/handshake', message);

                _handshakeMessages = message['x-messages'] || 0;

                var action = _isDisconnected() ? 'none' : _advice.reconnect || 'retry';
                switch (action) {
                    case 'retry':
                        _resetBackoff();
                        if (_handshakeMessages === 0) {
                            _delayedConnect(0);
                        } else {
                            _cometd._debug('Processing', _handshakeMessages, 'handshake-delivered messages');
                        }
                        break;
                    case 'none':
                        _disconnect(true);
                        break;
                    default:
                        throw 'Unrecognized advice action ' + action;
                }
            } else {
                _failHandshake(message, {
                    cause: 'unsuccessful',
                    action: _advice.reconnect || 'handshake',
                    transport: _transport
                });
            }
        }

        function _handshakeFailure(message) {
            _failHandshake(message, {
                cause: 'failure',
                action: 'handshake',
                transport: null
            });
        }

        function _failConnect(message, failureInfo) {
            // Notify the listeners after the status change but before the next action.
            _notifyListeners('/meta/connect', message);
            _notifyListeners('/meta/unsuccessful', message);

            // The listeners may have disconnected.
            if (_isDisconnected()) {
                failureInfo.action = 'none';
            }

            _cometd.onTransportFailure.call(_cometd, message, failureInfo, _handleTransportFailure);
        }

        function _connectResponse(message) {
            _connected = message.successful;

            if (_connected) {
                _notifyListeners('/meta/connect', message);

                // Normally, the advice will say "reconnect: 'retry', interval: 0"
                // and the server will hold the request, so when a response returns
                // we immediately call the server again (long polling).
                // Listeners can call disconnect(), so check the state after they run.
                var action = _isDisconnected() ? 'none' : _advice.reconnect || 'retry';
                switch (action) {
                    case 'retry':
                        _resetBackoff();
                        _delayedConnect(_backoff);
                        break;
                    case 'none':
                        _disconnect(false);
                        break;
                    default:
                        throw 'Unrecognized advice action ' + action;
                }
            } else {
                _failConnect(message, {
                    cause: 'unsuccessful',
                    action: _advice.reconnect || 'retry',
                    transport: _transport
                });
            }
        }

        function _connectFailure(message) {
            _connected = false;

            _failConnect(message, {
                cause: 'failure',
                action: 'retry',
                transport: null
            });
        }

        function _failDisconnect(message) {
            _disconnect(true);
            _handleCallback(message);
            _notifyListeners('/meta/disconnect', message);
            _notifyListeners('/meta/unsuccessful', message);
        }

        function _disconnectResponse(message) {
            if (message.successful) {
                // Wait for the /meta/connect to arrive.
                _disconnect(false);
                _handleCallback(message);
                _notifyListeners('/meta/disconnect', message);
            } else {
                _failDisconnect(message);
            }
        }

        function _disconnectFailure(message) {
            _failDisconnect(message);
        }

        function _failSubscribe(message) {
            var subscriptions = _listeners[message.subscription];
            if (subscriptions) {
                for (var id in subscriptions) {
                    if (subscriptions.hasOwnProperty(id)) {
                        var subscription = subscriptions[id];
                        if (subscription && !subscription.listener) {
                            delete subscriptions[id];
                            _cometd._debug('Removed failed subscription', subscription);
                        }
                    }
                }
            }
            _handleCallback(message);
            _notifyListeners('/meta/subscribe', message);
            _notifyListeners('/meta/unsuccessful', message);
        }

        function _subscribeResponse(message) {
            if (message.successful) {
                _handleCallback(message);
                _notifyListeners('/meta/subscribe', message);
            } else {
                _failSubscribe(message);
            }
        }

        function _subscribeFailure(message) {
            _failSubscribe(message);
        }

        function _failUnsubscribe(message) {
            _handleCallback(message);
            _notifyListeners('/meta/unsubscribe', message);
            _notifyListeners('/meta/unsuccessful', message);
        }

        function _unsubscribeResponse(message) {
            if (message.successful) {
                _handleCallback(message);
                _notifyListeners('/meta/unsubscribe', message);
            } else {
                _failUnsubscribe(message);
            }
        }

        function _unsubscribeFailure(message) {
            _failUnsubscribe(message);
        }

        function _failMessage(message) {
            if (!_handleRemoteCall(message)) {
                _handleCallback(message);
                _notifyListeners('/meta/publish', message);
                _notifyListeners('/meta/unsuccessful', message);
            }
        }

        function _messageResponse(message) {
            if (message.data !== undefined) {
                if (!_handleRemoteCall(message)) {
                    _notifyListeners(message.channel, message);
                    if (_handshakeMessages > 0) {
                        --_handshakeMessages;
                        if (_handshakeMessages === 0) {
                            _cometd._debug('Processed last handshake-delivered message');
                            _delayedConnect(0);
                        }
                    }
                }
            } else {
                if (message.successful === undefined) {
                    _cometd._warn('Unknown Bayeux Message', message);
                } else {
                    if (message.successful) {
                        _handleCallback(message);
                        _notifyListeners('/meta/publish', message);
                    } else {
                        _failMessage(message);
                    }
                }
            }
        }

        function _messageFailure(failure) {
            _failMessage(failure);
        }

        function _receive(message) {
            _unconnectTime = 0;

            message = _applyIncomingExtensions(message);
            if (message === undefined || message === null) {
                return;
            }

            _updateAdvice(message.advice);

            var channel = message.channel;
            switch (channel) {
                case '/meta/handshake':
                    _handshakeResponse(message);
                    break;
                case '/meta/connect':
                    _connectResponse(message);
                    break;
                case '/meta/disconnect':
                    _disconnectResponse(message);
                    break;
                case '/meta/subscribe':
                    _subscribeResponse(message);
                    break;
                case '/meta/unsubscribe':
                    _unsubscribeResponse(message);
                    break;
                default:
                    _messageResponse(message);
                    break;
            }
        }

        /**
         * Receives a message.
         * This method is exposed as a public so that extensions may inject
         * messages simulating that they had been received.
         */
        this.receive = _receive;

        _handleMessages = function(rcvdMessages) {
            _cometd._debug('Received', rcvdMessages);

            for (var i = 0; i < rcvdMessages.length; ++i) {
                var message = rcvdMessages[i];
                _receive(message);
            }
        };

        _handleFailure = function(conduit, messages, failure) {
            _cometd._debug('handleFailure', conduit, messages, failure);

            failure.transport = conduit;
            for (var i = 0; i < messages.length; ++i) {
                var message = messages[i];
                var failureMessage = {
                    id: message.id,
                    successful: false,
                    channel: message.channel,
                    failure: failure
                };
                failure.message = message;
                switch (message.channel) {
                    case '/meta/handshake':
                        _handshakeFailure(failureMessage);
                        break;
                    case '/meta/connect':
                        _connectFailure(failureMessage);
                        break;
                    case '/meta/disconnect':
                        _disconnectFailure(failureMessage);
                        break;
                    case '/meta/subscribe':
                        failureMessage.subscription = message.subscription;
                        _subscribeFailure(failureMessage);
                        break;
                    case '/meta/unsubscribe':
                        failureMessage.subscription = message.subscription;
                        _unsubscribeFailure(failureMessage);
                        break;
                    default:
                        _messageFailure(failureMessage);
                        break;
                }
            }
        };

        function _hasSubscriptions(channel) {
            var subscriptions = _listeners[channel];
            if (subscriptions) {
                for (var id in subscriptions) {
                    if (subscriptions.hasOwnProperty(id)) {
                        if (subscriptions[id]) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function _resolveScopedCallback(scope, callback) {
            var delegate = {
                scope: scope,
                method: callback
            };
            if (_isFunction(scope)) {
                delegate.scope = undefined;
                delegate.method = scope;
            } else {
                if (_isString(callback)) {
                    if (!scope) {
                        throw 'Invalid scope ' + scope;
                    }
                    delegate.method = scope[callback];
                    if (!_isFunction(delegate.method)) {
                        throw 'Invalid callback ' + callback + ' for scope ' + scope;
                    }
                } else if (!_isFunction(callback)) {
                    throw 'Invalid callback ' + callback;
                }
            }
            return delegate;
        }

        function _addListener(channel, scope, callback, isListener) {
            // The data structure is a map<channel, subscription[]>, where each subscription
            // holds the callback to be called and its scope.

            var delegate = _resolveScopedCallback(scope, callback);
            _cometd._debug('Adding', isListener ? 'listener' : 'subscription', 'on', channel, 'with scope', delegate.scope, 'and callback', delegate.method);

            var id = ++_listenerId;
            var subscription = {
                id: id,
                channel: channel,
                scope: delegate.scope,
                callback: delegate.method,
                listener: isListener
            };

            var subscriptions = _listeners[channel];
            if (!subscriptions) {
                subscriptions = {};
                _listeners[channel] = subscriptions;
            }

            subscriptions[id] = subscription;

            _cometd._debug('Added', isListener ? 'listener' : 'subscription', subscription);

            return subscription;
        }

        //
        // PUBLIC API
        //

        /**
         * Registers the given transport under the given transport type.
         * The optional index parameter specifies the "priority" at which the
         * transport is registered (where 0 is the max priority).
         * If a transport with the same type is already registered, this function
         * does nothing and returns false.
         * @param type the transport type
         * @param transport the transport object
         * @param index the index at which this transport is to be registered
         * @return true if the transport has been registered, false otherwise
         * @see #unregisterTransport(type)
         */
        this.registerTransport = function(type, transport, index) {
            var result = _transports.add(type, transport, index);
            if (result) {
                this._debug('Registered transport', type);

                if (_isFunction(transport.registered)) {
                    transport.registered(type, this);
                }
            }
            return result;
        };

        /**
         * Unregisters the transport with the given transport type.
         * @param type the transport type to unregister
         * @return the transport that has been unregistered,
         * or null if no transport was previously registered under the given transport type
         */
        this.unregisterTransport = function(type) {
            var transport = _transports.remove(type);
            if (transport !== null) {
                this._debug('Unregistered transport', type);

                if (_isFunction(transport.unregistered)) {
                    transport.unregistered();
                }
            }
            return transport;
        };

        this.unregisterTransports = function() {
            _transports.clear();
        };

        /**
         * @return an array of all registered transport types
         */
        this.getTransportTypes = function() {
            return _transports.getTransportTypes();
        };

        this.findTransport = function(name) {
            return _transports.find(name);
        };

        /**
         * @returns the TransportRegistry object
         */
        this.getTransportRegistry = function() {
            return _transports;
        };

        /**
         * Configures the initial Bayeux communication with the Bayeux server.
         * Configuration is passed via an object that must contain a mandatory field <code>url</code>
         * of type string containing the URL of the Bayeux server.
         * @param configuration the configuration object
         */
        this.configure = function(configuration) {
            _configure.call(this, configuration);
        };

        /**
         * Configures and establishes the Bayeux communication with the Bayeux server
         * via a handshake and a subsequent connect.
         * @param configuration the configuration object
         * @param handshakeProps an object to be merged with the handshake message
         * @see #configure(configuration)
         * @see #handshake(handshakeProps)
         */
        this.init = function(configuration, handshakeProps) {
            this.configure(configuration);
            this.handshake(handshakeProps);
        };

        /**
         * Establishes the Bayeux communication with the Bayeux server
         * via a handshake and a subsequent connect.
         * @param handshakeProps an object to be merged with the handshake message
         * @param handshakeCallback a function to be invoked when the handshake is acknowledged
         */
        this.handshake = function(handshakeProps, handshakeCallback) {
            if (_status !== 'disconnected') {
                throw 'Illegal state: handshaken';
            }
            _handshake(handshakeProps, handshakeCallback);
        };

        /**
         * Disconnects from the Bayeux server.
         * It is possible to suggest to attempt a synchronous disconnect, but this feature
         * may only be available in certain transports (for example, long-polling may support
         * it, callback-polling certainly does not).
         * @param sync whether attempt to perform a synchronous disconnect
         * @param disconnectProps an object to be merged with the disconnect message
         * @param disconnectCallback a function to be invoked when the disconnect is acknowledged
         */
        this.disconnect = function(sync, disconnectProps, disconnectCallback) {
            if (_isDisconnected()) {
                return;
            }

            if (typeof sync !== 'boolean') {
                disconnectCallback = disconnectProps;
                disconnectProps = sync;
                sync = false;
            }
            if (_isFunction(disconnectProps)) {
                disconnectCallback = disconnectProps;
                disconnectProps = undefined;
            }

            var bayeuxMessage = {
                id: _nextMessageId(),
                channel: '/meta/disconnect'
            };
            // Do not allow the user to override important fields.
            var message = this._mixin(false, {}, disconnectProps, bayeuxMessage);

            // Save the callback.
            _cometd._putCallback(message.id, disconnectCallback);

            _setStatus('disconnecting');
            _send(sync === true, [message], false, 'disconnect');
        };

        /**
         * Marks the start of a batch of application messages to be sent to the server
         * in a single request, obtaining a single response containing (possibly) many
         * application reply messages.
         * Messages are held in a queue and not sent until {@link #endBatch()} is called.
         * If startBatch() is called multiple times, then an equal number of endBatch()
         * calls must be made to close and send the batch of messages.
         * @see #endBatch()
         */
        this.startBatch = function() {
            _startBatch();
        };

        /**
         * Marks the end of a batch of application messages to be sent to the server
         * in a single request.
         * @see #startBatch()
         */
        this.endBatch = function() {
            _endBatch();
        };

        /**
         * Executes the given callback in the given scope, surrounded by a {@link #startBatch()}
         * and {@link #endBatch()} calls.
         * @param scope the scope of the callback, may be omitted
         * @param callback the callback to be executed within {@link #startBatch()} and {@link #endBatch()} calls
         */
        this.batch = function(scope, callback) {
            var delegate = _resolveScopedCallback(scope, callback);
            this.startBatch();
            try {
                delegate.method.call(delegate.scope);
                this.endBatch();
            } catch (x) {
                this._info('Exception during execution of batch', x);
                this.endBatch();
                throw x;
            }
        };

        /**
         * Adds a listener for bayeux messages, performing the given callback in the given scope
         * when a message for the given channel arrives.
         * @param channel the channel the listener is interested to
         * @param scope the scope of the callback, may be omitted
         * @param callback the callback to call when a message is sent to the channel
         * @returns the subscription handle to be passed to {@link #removeListener(object)}
         * @see #removeListener(subscription)
         */
        this.addListener = function(channel, scope, callback) {
            if (arguments.length < 2) {
                throw 'Illegal arguments number: required 2, got ' + arguments.length;
            }
            if (!_isString(channel)) {
                throw 'Illegal argument type: channel must be a string';
            }

            return _addListener(channel, scope, callback, true);
        };

        /**
         * Removes the subscription obtained with a call to {@link #addListener(string, object, function)}.
         * @param subscription the subscription to unsubscribe.
         * @see #addListener(channel, scope, callback)
         */
        this.removeListener = function(subscription) {
            // Beware of subscription.id == 0, which is falsy => cannot use !subscription.id
            if (!subscription || !subscription.channel || !("id" in subscription)) {
                throw 'Invalid argument: expected subscription, not ' + subscription;
            }

            _removeListener(subscription);
        };

        /**
         * Removes all listeners registered with {@link #addListener(channel, scope, callback)} or
         * {@link #subscribe(channel, scope, callback)}.
         */
        this.clearListeners = function() {
            _listeners = {};
        };

        /**
         * Subscribes to the given channel, performing the given callback in the given scope
         * when a message for the channel arrives.
         * @param channel the channel to subscribe to
         * @param scope the scope of the callback, may be omitted
         * @param callback the callback to call when a message is sent to the channel
         * @param subscribeProps an object to be merged with the subscribe message
         * @param subscribeCallback a function to be invoked when the subscription is acknowledged
         * @return the subscription handle to be passed to {@link #unsubscribe(object)}
         */
        this.subscribe = function(channel, scope, callback, subscribeProps, subscribeCallback) {
            if (arguments.length < 2) {
                throw 'Illegal arguments number: required 2, got ' + arguments.length;
            }
            if (!_isString(channel)) {
                throw 'Illegal argument type: channel must be a string';
            }
            if (_isDisconnected()) {
                throw 'Illegal state: disconnected';
            }

            // Normalize arguments
            if (_isFunction(scope)) {
                subscribeCallback = subscribeProps;
                subscribeProps = callback;
                callback = scope;
                scope = undefined;
            }
            if (_isFunction(subscribeProps)) {
                subscribeCallback = subscribeProps;
                subscribeProps = undefined;
            }

            // Only send the message to the server if this client has not yet subscribed to the channel
            var send = !_hasSubscriptions(channel);

            var subscription = _addListener(channel, scope, callback, false);

            if (send) {
                // Send the subscription message after the subscription registration to avoid
                // races where the server would send a message to the subscribers, but here
                // on the client the subscription has not been added yet to the data structures
                var bayeuxMessage = {
                    id: _nextMessageId(),
                    channel: '/meta/subscribe',
                    subscription: channel
                };
                // Do not allow the user to override important fields.
                var message = this._mixin(false, {}, subscribeProps, bayeuxMessage);

                // Save the callback.
                _cometd._putCallback(message.id, subscribeCallback);

                _queueSend(message);
            }

            return subscription;
        };

        /**
         * Unsubscribes the subscription obtained with a call to {@link #subscribe(string, object, function)}.
         * @param subscription the subscription to unsubscribe.
         * @param unsubscribeProps an object to be merged with the unsubscribe message
         * @param unsubscribeCallback a function to be invoked when the unsubscription is acknowledged
         */
        this.unsubscribe = function(subscription, unsubscribeProps, unsubscribeCallback) {
            if (arguments.length < 1) {
                throw 'Illegal arguments number: required 1, got ' + arguments.length;
            }
            if (_isDisconnected()) {
                throw 'Illegal state: disconnected';
            }

            if (_isFunction(unsubscribeProps)) {
                unsubscribeCallback = unsubscribeProps;
                unsubscribeProps = undefined;
            }

            // Remove the local listener before sending the message
            // This ensures that if the server fails, this client does not get notifications
            this.removeListener(subscription);

            var channel = subscription.channel;
            // Only send the message to the server if this client unsubscribes the last subscription
            if (!_hasSubscriptions(channel)) {
                var bayeuxMessage = {
                    id: _nextMessageId(),
                    channel: '/meta/unsubscribe',
                    subscription: channel
                };
                // Do not allow the user to override important fields.
                var message = this._mixin(false, {}, unsubscribeProps, bayeuxMessage);

                // Save the callback.
                _cometd._putCallback(message.id, unsubscribeCallback);

                _queueSend(message);
            }
        };

        this.resubscribe = function(subscription, subscribeProps) {
            _removeSubscription(subscription);
            if (subscription) {
                return this.subscribe(subscription.channel, subscription.scope, subscription.callback, subscribeProps);
            }
            return undefined;
        };

        /**
         * Removes all subscriptions added via {@link #subscribe(channel, scope, callback, subscribeProps)},
         * but does not remove the listeners added via {@link addListener(channel, scope, callback)}.
         */
        this.clearSubscriptions = function() {
            _clearSubscriptions();
        };

        /**
         * Publishes a message on the given channel, containing the given content.
         * @param channel the channel to publish the message to
         * @param content the content of the message
         * @param publishProps an object to be merged with the publish message
         * @param publishCallback a function to be invoked when the publish is acknowledged by the server
         */
        this.publish = function(channel, content, publishProps, publishCallback) {
            if (arguments.length < 1) {
                throw 'Illegal arguments number: required 1, got ' + arguments.length;
            }
            if (!_isString(channel)) {
                throw 'Illegal argument type: channel must be a string';
            }
            if (/^\/meta\//.test(channel)) {
                throw 'Illegal argument: cannot publish to meta channels';
            }
            if (_isDisconnected()) {
                throw 'Illegal state: disconnected';
            }

            if (_isFunction(content)) {
                publishCallback = content;
                content = {};
                publishProps = undefined;
            } else if (_isFunction(publishProps)) {
                publishCallback = publishProps;
                publishProps = undefined;
            }

            var bayeuxMessage = {
                id: _nextMessageId(),
                channel: channel,
                data: content
            };
            // Do not allow the user to override important fields.
            var message = this._mixin(false, {}, publishProps, bayeuxMessage);

            // Save the callback.
            _cometd._putCallback(message.id, publishCallback);

            _queueSend(message);
        };

        /**
         * Publishes a message with binary data on the given channel.
         * The binary data chunk may be an ArrayBuffer, a DataView, a TypedArray
         * (such as Uint8Array) or a plain integer array.
         * The meta data object may contain additional application data such as
         * a file name, a mime type, etc.
         * @param channel the channel to publish the message to
         * @param data the binary data to publish
         * @param last whether the binary data chunk is the last
         * @param meta an object containing meta data associated to the binary chunk
         * @param callback a function to be invoked when the publish is acknowledged by the server
         */
        this.publishBinary = function(channel, data, last, meta, callback) {
            if (_isFunction(data)) {
                callback = data;
                data = new ArrayBuffer(0);
                last = true;
                meta = undefined;
            } else if (_isFunction(last)) {
                callback = last;
                last = true;
                meta = undefined;
            } else if (_isFunction(meta)) {
                callback = meta;
                meta = undefined;
            }
            var content = {
                meta: meta,
                data: data,
                last: last
            };
            var ext = {
                ext: {
                    binary: {
                    }
                }
            };
            this.publish(channel, content, ext, callback);
        };

        this.remoteCall = function(target, content, timeout, callProps, callback) {
            if (arguments.length < 1) {
                throw 'Illegal arguments number: required 1, got ' + arguments.length;
            }
            if (!_isString(target)) {
                throw 'Illegal argument type: target must be a string';
            }
            if (_isDisconnected()) {
                throw 'Illegal state: disconnected';
            }

            if (_isFunction(content)) {
                callback = content;
                content = {};
                timeout = _config.maxNetworkDelay;
                callProps = undefined;
            } else if (_isFunction(timeout)) {
                callback = timeout;
                timeout = _config.maxNetworkDelay;
                callProps = undefined;
            } else if (_isFunction(callProps)) {
                callback = callProps;
                callProps = undefined;
            }

            if (typeof timeout !== 'number') {
                throw 'Illegal argument type: timeout must be a number';
            }

            if (!target.match(/^\//)) {
                target = '/' + target;
            }
            var channel = '/service' + target;

            var bayeuxMessage = {
                id: _nextMessageId(),
                channel: channel,
                data: content
            };
            var message = this._mixin(false, {}, callProps, bayeuxMessage);

            var context = {
                callback: callback
            };
            if (timeout > 0) {
                context.timeout = Utils.setTimeout(_cometd, function() {
                    _cometd._debug('Timing out remote call', message, 'after', timeout, 'ms');
                    _failMessage({
                        id: message.id,
                        error: '406::timeout',
                        successful: false,
                        failure: {
                            message : message,
                            reason: 'Remote Call Timeout'
                        }
                    });
                }, timeout);
                _cometd._debug('Scheduled remote call timeout', message, 'in', timeout, 'ms');
            }
            _remoteCalls[message.id] = context;

            _queueSend(message);
        };

        this.remoteCallBinary = function(target, data, last, meta, timeout, callback) {
            if (_isFunction(data)) {
                callback = data;
                data = new ArrayBuffer(0);
                last = true;
                meta = undefined;
                timeout = _config.maxNetworkDelay;
            } else if (_isFunction(last)) {
                callback = last;
                last = true;
                meta = undefined;
                timeout = _config.maxNetworkDelay;
            } else if (_isFunction(meta)) {
                callback = meta;
                meta = undefined;
                timeout = _config.maxNetworkDelay;
            } else if (_isFunction(timeout)) {
                callback = timeout;
                timeout = _config.maxNetworkDelay;
            }

            var content = {
                meta: meta,
                data: data,
                last: last
            };
            var ext = {
                ext: {
                    binary: {
                    }
                }
            };

            this.remoteCall(target, content, timeout, ext, callback);
        };

        /**
         * Returns a string representing the status of the bayeux communication with the Bayeux server.
         */
        this.getStatus = function() {
            return _status;
        };

        /**
         * Returns whether this instance has been disconnected.
         */
        this.isDisconnected = _isDisconnected;

        /**
         * Sets the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.
         * Default value is 1 second, which means if there is a persistent failure the retries will happen
         * after 1 second, then after 2 seconds, then after 3 seconds, etc. So for example with 15 seconds of
         * elapsed time, there will be 5 retries (at 1, 3, 6, 10 and 15 seconds elapsed).
         * @param period the backoff period to set
         * @see #getBackoffIncrement()
         */
        this.setBackoffIncrement = function(period) {
            _config.backoffIncrement = period;
        };

        /**
         * Returns the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.
         * @see #setBackoffIncrement(period)
         */
        this.getBackoffIncrement = function() {
            return _config.backoffIncrement;
        };

        /**
         * Returns the backoff period to wait before retrying an unsuccessful or failed message.
         */
        this.getBackoffPeriod = function() {
            return _backoff;
        };

        /**
         * Increases the backoff period up to the maximum value configured.
         * @returns the backoff period after increment
         * @see getBackoffIncrement
         */
        this.increaseBackoffPeriod = function() {
            return _increaseBackoff();
        };

        /**
         * Resets the backoff period to zero.
         */
        this.resetBackoffPeriod = function() {
            _resetBackoff();
        };

        /**
         * Sets the log level for console logging.
         * Valid values are the strings 'error', 'warn', 'info' and 'debug', from
         * less verbose to more verbose.
         * @param level the log level string
         */
        this.setLogLevel = function(level) {
            _config.logLevel = level;
        };

        /**
         * Registers an extension whose callbacks are called for every incoming message
         * (that comes from the server to this client implementation) and for every
         * outgoing message (that originates from this client implementation for the
         * server).
         * The format of the extension object is the following:
         * <pre>
         * {
     *     incoming: function(message) { ... },
     *     outgoing: function(message) { ... }
     * }
         * </pre>
         * Both properties are optional, but if they are present they will be called
         * respectively for each incoming message and for each outgoing message.
         * @param name the name of the extension
         * @param extension the extension to register
         * @return true if the extension was registered, false otherwise
         * @see #unregisterExtension(name)
         */
        this.registerExtension = function(name, extension) {
            if (arguments.length < 2) {
                throw 'Illegal arguments number: required 2, got ' + arguments.length;
            }
            if (!_isString(name)) {
                throw 'Illegal argument type: extension name must be a string';
            }

            var existing = false;
            for (var i = 0; i < _extensions.length; ++i) {
                var existingExtension = _extensions[i];
                if (existingExtension.name === name) {
                    existing = true;
                    break;
                }
            }
            if (!existing) {
                _extensions.push({
                    name: name,
                    extension: extension
                });
                this._debug('Registered extension', name);

                // Callback for extensions
                if (_isFunction(extension.registered)) {
                    extension.registered(name, this);
                }

                return true;
            } else {
                this._info('Could not register extension with name', name, 'since another extension with the same name already exists');
                return false;
            }
        };

        /**
         * Unregister an extension previously registered with
         * {@link #registerExtension(name, extension)}.
         * @param name the name of the extension to unregister.
         * @return true if the extension was unregistered, false otherwise
         */
        this.unregisterExtension = function(name) {
            if (!_isString(name)) {
                throw 'Illegal argument type: extension name must be a string';
            }

            var unregistered = false;
            for (var i = 0; i < _extensions.length; ++i) {
                var extension = _extensions[i];
                if (extension.name === name) {
                    _extensions.splice(i, 1);
                    unregistered = true;
                    this._debug('Unregistered extension', name);

                    // Callback for extensions
                    var ext = extension.extension;
                    if (_isFunction(ext.unregistered)) {
                        ext.unregistered();
                    }

                    break;
                }
            }
            return unregistered;
        };

        /**
         * Find the extension registered with the given name.
         * @param name the name of the extension to find
         * @return the extension found or null if no extension with the given name has been registered
         */
        this.getExtension = function(name) {
            for (var i = 0; i < _extensions.length; ++i) {
                var extension = _extensions[i];
                if (extension.name === name) {
                    return extension.extension;
                }
            }
            return null;
        };

        /**
         * Returns the name assigned to this CometD object, or the string 'default'
         * if no name has been explicitly passed as parameter to the constructor.
         */
        this.getName = function() {
            return _name;
        };

        /**
         * Returns the clientId assigned by the Bayeux server during handshake.
         */
        this.getClientId = function() {
            return _clientId;
        };

        /**
         * Returns the URL of the Bayeux server.
         */
        this.getURL = function() {
            if (_transport) {
                var url = _transport.getURL();
                if (url) {
                    return url;
                }
                url = _config.urls[_transport.getType()];
                if (url) {
                    return url;
                }
            }
            return _config.url;
        };

        this.getTransport = function() {
            return _transport;
        };

        this.getConfiguration = function() {
            return this._mixin(true, {}, _config);
        };

        this.getAdvice = function() {
            return this._mixin(true, {}, _advice);
        };

        // Initialize transports.
        if (window.WebSocket) {
            this.registerTransport('websocket', new WebSocketTransport());
        }
        this.registerTransport('long-polling', new LongPollingTransport());
        this.registerTransport('callback-polling', new CallbackPollingTransport());
    };

    var _z85EncodeTable = [
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
        'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
        'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D',
        'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
        'Y', 'Z', '.', '-', ':', '+', '=', '^', '!', '/',
        '*', '?', '&', '<', '>', '(', ')', '[', ']', '{',
        '}', '@', '%', '$', '#'
    ];
    var _z85DecodeTable = [
        0x00, 0x44, 0x00, 0x54, 0x53, 0x52, 0x48, 0x00,
        0x4B, 0x4C, 0x46, 0x41, 0x00, 0x3F, 0x3E, 0x45,
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x40, 0x00, 0x49, 0x42, 0x4A, 0x47,
        0x51, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A,
        0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32,
        0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A,
        0x3B, 0x3C, 0x3D, 0x4D, 0x00, 0x4E, 0x43, 0x00,
        0x00, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
        0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
        0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
        0x21, 0x22, 0x23, 0x4F, 0x00, 0x50, 0x00, 0x00
    ];
    var Z85 = {
        encode: function(bytes) {
            var buffer = null;
            if (bytes instanceof ArrayBuffer) {
                buffer = bytes;
            } else if (bytes.buffer instanceof ArrayBuffer) {
                buffer = bytes.buffer;
            } else if (Array.isArray(bytes)) {
                buffer = new Uint8Array(bytes).buffer;
            }
            if (buffer == null) {
                throw 'Cannot Z85 encode ' + bytes;
            }

            var length = buffer.byteLength;
            var remainder = length % 4;
            var padding = 4 - (remainder === 0 ? 4 : remainder);
            var view = new DataView(buffer);
            var result = '';
            var value = 0;
            for (var i = 0; i < length + padding; ++i) {
                var isPadding = i >= length;
                value = value * 256 + (isPadding ? 0 : view.getUint8(i));
                if ((i + 1) % 4 === 0) {
                    var divisor = 85 * 85 * 85 * 85;
                    for (var j = 5; j > 0; --j) {
                        if (!isPadding || j > padding) {
                            var code = Math.floor(value / divisor) % 85;
                            result += _z85EncodeTable[code];
                        }
                        divisor /= 85;
                    }
                    value = 0;
                }
            }

            return result;
        },
        decode: function(string) {
            var remainder = string.length % 5;
            var padding = 5 - (remainder === 0 ? 5 : remainder);
            for (var p = 0; p < padding; ++p) {
                string += _z85EncodeTable[_z85EncodeTable.length - 1];
            }
            var length = string.length;

            var buffer = new ArrayBuffer((length * 4 / 5) - padding);
            var view = new DataView(buffer);
            var value = 0;
            var charIdx = 0;
            var byteIdx = 0;
            for (var i = 0; i < length; ++i) {
                var code = string.charCodeAt(charIdx++) - 32;
                value = value * 85 + _z85DecodeTable[code];
                if (charIdx % 5 === 0) {
                    var divisor = 256 * 256 * 256;
                    while (divisor >= 1) {
                        if (byteIdx < view.byteLength) {
                            view.setUint8(byteIdx++, Math.floor(value / divisor) % 256);
                        }
                        divisor /= 256;
                    }
                    value = 0;
                }
            }

            return buffer;
        }
    };

    return {
        CometD: CometD,
        Transport: Transport,
        RequestTransport: RequestTransport,
        LongPollingTransport: LongPollingTransport,
        CallbackPollingTransport: CallbackPollingTransport,
        WebSocketTransport: WebSocketTransport,
        Utils: Utils,
        Z85: Z85
    };
}));
});

var browser = {
  CometD: cometd.CometD,
  default: cometd
};

var MetaChannel_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var MetaChannel;
(function (MetaChannel) {
    MetaChannel["HANDSHAKE"] = "/meta/handshake";
    MetaChannel["CONNECT"] = "/meta/connect";
    MetaChannel["SUBSCRIBE"] = "/meta/subscribe";
    MetaChannel["UNSUBSCRIBE"] = "/meta/unsubscribe";
})(MetaChannel = exports.MetaChannel || (exports.MetaChannel = {}));

});

unwrapExports(MetaChannel_1);
var MetaChannel_2 = MetaChannel_1.MetaChannel;

var Realtime_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });



var Realtime = /** @class */ (function () {
    /**
     * Allows to set up a realtime (websocket or long-polling) connection to the platform.
     * @param client The fetch client instance to use
     * @param url The URL to connect to
     * @param handshakeCallback A function which is called on succeeded or failed handshake
     */
    function Realtime(client, url, handshakeCallback) {
        if (url === void 0) { url = '/cep/realtime'; }
        this.client = client;
        this.url = url;
        this.cometd = new browser.CometD();
        this.metaHandshake = function (msg) {
            if (!msg.successful) {
                throw new Error('Handshake failed');
            }
        };
        this.cometd.websocketEnabled = true;
        this.cometd.addListener(MetaChannel_1.MetaChannel.HANDSHAKE, handshakeCallback || this.metaHandshake);
    }
    /**
     * Subscribes to a realtime channel to listen for data.
     * @param channel The channel to connect to
     * @param callback A function to call when data is received
     */
    Realtime.prototype.subscribe = function (channel, callback) {
        this.checkConnection();
        return this.cometd.subscribe(channel, callback);
    };
    /**
     * Cancels the listening to a channel.
     * @param subscription The subscription object returned by subscribe()
     */
    Realtime.prototype.unsubscribe = function (subscription) {
        return this.cometd.unsubscribe(subscription);
    };
    /**
     * Returns an observable which subscribes/unsubscribes automatically.
     * @param channel The name of the channel you want to connect to.
     *
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use rxjs `new Observable()`, `defer()` or `from()`
     * to composite an observable on your own:
     * ```typescript
     * return new Observable<any>((observer) => {
     *   const subscription = this.subscribe(channel, (msg) => {
     *     const data = {
     *       channel: msg.channel,
     *       data: msg.data.data,
     *       id: msg.id,
     *       realtimeAction: msg.data.realtimeAction,
     *     };
     *     return observer.next(data);
     *   });
     *   return () => this.unsubscribe(subscription);
     * });
     * ```
     */
    Realtime.prototype.observable = function (channel) {
        var _this = this;
        return new rxjs_1.Observable(function (observer) {
            var subscription = _this.subscribe(channel, function (msg) {
                var data = {
                    channel: msg.channel,
                    data: msg.data.data,
                    id: msg.id,
                    realtimeAction: msg.data.realtimeAction
                };
                return observer.next(data);
            });
            return function () { return _this.unsubscribe(subscription); };
        });
    };
    /**
     * Disconnects the current connection.
     */
    Realtime.prototype.disconnect = function () {
        this.cometd.disconnect();
    };
    Realtime.prototype.checkConnection = function () {
        var _a = this, cometd = _a.cometd, client = _a.client, url = _a.url;
        if (cometd.isDisconnected()) {
            var headers = client.getFetchOptions().headers;
            var config = {
                url: client.getUrl(url),
                requestHeaders: headers
            };
            cometd.configure(config);
            this.handshake(client.getCometdHandshake());
        }
    };
    Realtime.prototype.handshake = function (config) {
        this.cometd.handshake(config);
    };
    return Realtime;
}());
exports.Realtime = Realtime;

});

unwrapExports(Realtime_1);
var Realtime_2 = Realtime_1.Realtime;

var realtime = createCommonjsModule(function (module, exports) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(Realtime_1);

});

unwrapExports(realtime);

var Paging_1 = createCommonjsModule(function (module, exports) {
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Paging allows you to query the next and previous data chunks
 * in a convenient way. You can also go to a specific page or just read
 * page information about the current data chunk.
 * Note that page numbers are generated by backend
 * and may be used as offset rather than a continuous range of positive numbers
 * (e.g. in case of users with restricted permissions).
 */
var Paging = /** @class */ (function () {
    function Paging(service, statistics, filter) {
        this.filter = filter;
        this.service = service;
        this.currentPage = statistics.currentPage;
        this.nextPage = statistics.nextPage;
        this.prevPage = statistics.prevPage;
        this.pageSize = statistics.pageSize;
        this.totalPages = statistics.totalPages;
    }
    /**
     * Gets the next page of available data from the server.
     * @param filter
     */
    Paging.prototype.next = function (filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.list(this.getFilter(filter, this.nextPage))];
            });
        });
    };
    /**
     * Gets the previous page of available data from server.
     * @param filter
     */
    Paging.prototype.prev = function (filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.list(this.getFilter(filter, this.prevPage))];
            });
        });
    };
    /**
     * Method used by next(), prev() and goto() to call the service.list method.
     * It is public so it can be overriden in special cases (like children objects
     * in inventory).
     * @param filter
     */
    Paging.prototype.list = function (filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.service.list(filter)];
            });
        });
    };
    /**
     * Goes to the page that you define as page parameter.
     * @param page
     * @param filter
     */
    Paging.prototype.goto = function (page, filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.list(this.getFilter(filter, page))];
            });
        });
    };
    Paging.prototype.getFilter = function (filter, page) {
        return Object.assign(filter, this.filter, { currentPage: page });
    };
    return Paging;
}());
exports.Paging = Paging;

});

unwrapExports(Paging_1);
var Paging_2 = Paging_1.Paging;

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function audit(durationSelector) {
    return function auditOperatorFunction(source) {
        return source.lift(new AuditOperator(durationSelector));
    };
}
var AuditOperator = /*@__PURE__*/ (function () {
    function AuditOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    AuditOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
    };
    return AuditOperator;
}());
var AuditSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(AuditSubscriber, _super);
    function AuditSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
    }
    AuditSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
            var duration = void 0;
            try {
                var durationSelector = this.durationSelector;
                duration = durationSelector(value);
            }
            catch (err) {
                return this.destination.error(err);
            }
            var innerSubscription = subscribeToResult(this, duration);
            if (!innerSubscription || innerSubscription.closed) {
                this.clearThrottle();
            }
            else {
                this.add(this.throttled = innerSubscription);
            }
        }
    };
    AuditSubscriber.prototype.clearThrottle = function () {
        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
        if (hasValue) {
            this.value = null;
            this.hasValue = false;
            this.destination.next(value);
        }
    };
    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        this.clearThrottle();
    };
    AuditSubscriber.prototype.notifyComplete = function () {
        this.clearThrottle();
    };
    return AuditSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _scheduler_async,_audit,_observable_timer PURE_IMPORTS_END */
function auditTime(duration, scheduler) {
    if (scheduler === void 0) {
        scheduler = async;
    }
    return audit(function () { return timer(duration, scheduler); });
}

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function buffer(closingNotifier) {
    return function bufferOperatorFunction(source) {
        return source.lift(new BufferOperator(closingNotifier));
    };
}
var BufferOperator = /*@__PURE__*/ (function () {
    function BufferOperator(closingNotifier) {
        this.closingNotifier = closingNotifier;
    }
    BufferOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
    };
    return BufferOperator;
}());
var BufferSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferSubscriber, _super);
    function BufferSubscriber(destination, closingNotifier) {
        var _this = _super.call(this, destination) || this;
        _this.buffer = [];
        _this.add(subscribeToResult(_this, closingNotifier));
        return _this;
    }
    BufferSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var buffer = this.buffer;
        this.buffer = [];
        this.destination.next(buffer);
    };
    return BufferSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function bufferCount(bufferSize, startBufferEvery) {
    if (startBufferEvery === void 0) {
        startBufferEvery = null;
    }
    return function bufferCountOperatorFunction(source) {
        return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
    };
}
var BufferCountOperator = /*@__PURE__*/ (function () {
    function BufferCountOperator(bufferSize, startBufferEvery) {
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        if (!startBufferEvery || bufferSize === startBufferEvery) {
            this.subscriberClass = BufferCountSubscriber;
        }
        else {
            this.subscriberClass = BufferSkipCountSubscriber;
        }
    }
    BufferCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
    };
    return BufferCountOperator;
}());
var BufferCountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferCountSubscriber, _super);
    function BufferCountSubscriber(destination, bufferSize) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.buffer = [];
        return _this;
    }
    BufferCountSubscriber.prototype._next = function (value) {
        var buffer = this.buffer;
        buffer.push(value);
        if (buffer.length == this.bufferSize) {
            this.destination.next(buffer);
            this.buffer = [];
        }
    };
    BufferCountSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer.length > 0) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    return BufferCountSubscriber;
}(Subscriber));
var BufferSkipCountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferSkipCountSubscriber, _super);
    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.startBufferEvery = startBufferEvery;
        _this.buffers = [];
        _this.count = 0;
        return _this;
    }
    BufferSkipCountSubscriber.prototype._next = function (value) {
        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;
        this.count++;
        if (count % startBufferEvery === 0) {
            buffers.push([]);
        }
        for (var i = buffers.length; i--;) {
            var buffer = buffers[i];
            buffer.push(value);
            if (buffer.length === bufferSize) {
                buffers.splice(i, 1);
                this.destination.next(buffer);
            }
        }
    };
    BufferSkipCountSubscriber.prototype._complete = function () {
        var _a = this, buffers = _a.buffers, destination = _a.destination;
        while (buffers.length > 0) {
            var buffer = buffers.shift();
            if (buffer.length > 0) {
                destination.next(buffer);
            }
        }
        _super.prototype._complete.call(this);
    };
    return BufferSkipCountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_scheduler_async,_Subscriber,_util_isScheduler PURE_IMPORTS_END */
function bufferTime(bufferTimeSpan) {
    var length = arguments.length;
    var scheduler = async;
    if (isScheduler(arguments[arguments.length - 1])) {
        scheduler = arguments[arguments.length - 1];
        length--;
    }
    var bufferCreationInterval = null;
    if (length >= 2) {
        bufferCreationInterval = arguments[1];
    }
    var maxBufferSize = Number.POSITIVE_INFINITY;
    if (length >= 3) {
        maxBufferSize = arguments[2];
    }
    return function bufferTimeOperatorFunction(source) {
        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
    };
}
var BufferTimeOperator = /*@__PURE__*/ (function () {
    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
    }
    BufferTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
    };
    return BufferTimeOperator;
}());
var Context = /*@__PURE__*/ (function () {
    function Context() {
        this.buffer = [];
    }
    return Context;
}());
var BufferTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferTimeSubscriber, _super);
    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.bufferTimeSpan = bufferTimeSpan;
        _this.bufferCreationInterval = bufferCreationInterval;
        _this.maxBufferSize = maxBufferSize;
        _this.scheduler = scheduler;
        _this.contexts = [];
        var context = _this.openContext();
        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (_this.timespanOnly) {
            var timeSpanOnlyState = { subscriber: _this, context: context, bufferTimeSpan: bufferTimeSpan };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
        else {
            var closeState = { subscriber: _this, context: context };
            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
        return _this;
    }
    BufferTimeSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i = 0; i < len; i++) {
            var context_1 = contexts[i];
            var buffer = context_1.buffer;
            buffer.push(value);
            if (buffer.length == this.maxBufferSize) {
                filledBufferContext = context_1;
            }
        }
        if (filledBufferContext) {
            this.onBufferFull(filledBufferContext);
        }
    };
    BufferTimeSubscriber.prototype._error = function (err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
    };
    BufferTimeSubscriber.prototype._complete = function () {
        var _a = this, contexts = _a.contexts, destination = _a.destination;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            destination.next(context_2.buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferTimeSubscriber.prototype._unsubscribe = function () {
        this.contexts = null;
    };
    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
            context = this.openContext();
            var bufferTimeSpan = this.bufferTimeSpan;
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
    };
    BufferTimeSubscriber.prototype.openContext = function () {
        var context = new Context();
        this.contexts.push(context);
        return context;
    };
    BufferTimeSubscriber.prototype.closeContext = function (context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
            contexts.splice(contexts.indexOf(context), 1);
        }
    };
    return BufferTimeSubscriber;
}(Subscriber));
function dispatchBufferTimeSpanOnly(state) {
    var subscriber = state.subscriber;
    var prevContext = state.context;
    if (prevContext) {
        subscriber.closeContext(prevContext);
    }
    if (!subscriber.closed) {
        state.context = subscriber.openContext();
        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
    }
}
function dispatchBufferCreation(state) {
    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
    var context = subscriber.openContext();
    var action = this;
    if (!subscriber.closed) {
        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
        action.schedule(state, bufferCreationInterval);
    }
}
function dispatchBufferClose(arg) {
    var subscriber = arg.subscriber, context = arg.context;
    subscriber.closeContext(context);
}

/** PURE_IMPORTS_START tslib,_Subscription,_util_subscribeToResult,_OuterSubscriber PURE_IMPORTS_END */
function bufferToggle(openings, closingSelector) {
    return function bufferToggleOperatorFunction(source) {
        return source.lift(new BufferToggleOperator(openings, closingSelector));
    };
}
var BufferToggleOperator = /*@__PURE__*/ (function () {
    function BufferToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    BufferToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return BufferToggleOperator;
}());
var BufferToggleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferToggleSubscriber, _super);
    function BufferToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(subscribeToResult(_this, openings));
        return _this;
    }
    BufferToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        for (var i = 0; i < len; i++) {
            contexts[i].buffer.push(value);
        }
    };
    BufferToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_1 = contexts.shift();
            context_1.subscription.unsubscribe();
            context_1.buffer = null;
            context_1.subscription = null;
        }
        this.contexts = null;
        _super.prototype._error.call(this, err);
    };
    BufferToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            this.destination.next(context_2.buffer);
            context_2.subscription.unsubscribe();
            context_2.buffer = null;
            context_2.subscription = null;
        }
        this.contexts = null;
        _super.prototype._complete.call(this);
    };
    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
    };
    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
        this.closeBuffer(innerSub.context);
    };
    BufferToggleSubscriber.prototype.openBuffer = function (value) {
        try {
            var closingSelector = this.closingSelector;
            var closingNotifier = closingSelector.call(this, value);
            if (closingNotifier) {
                this.trySubscribe(closingNotifier);
            }
        }
        catch (err) {
            this._error(err);
        }
    };
    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
        var contexts = this.contexts;
        if (contexts && context) {
            var buffer = context.buffer, subscription = context.subscription;
            this.destination.next(buffer);
            contexts.splice(contexts.indexOf(context), 1);
            this.remove(subscription);
            subscription.unsubscribe();
        }
    };
    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
        var contexts = this.contexts;
        var buffer = [];
        var subscription = new Subscription();
        var context = { buffer: buffer, subscription: subscription };
        contexts.push(context);
        var innerSubscription = subscribeToResult(this, closingNotifier, context);
        if (!innerSubscription || innerSubscription.closed) {
            this.closeBuffer(context);
        }
        else {
            innerSubscription.context = context;
            this.add(innerSubscription);
            subscription.add(innerSubscription);
        }
    };
    return BufferToggleSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscription,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function bufferWhen(closingSelector) {
    return function (source) {
        return source.lift(new BufferWhenOperator(closingSelector));
    };
}
var BufferWhenOperator = /*@__PURE__*/ (function () {
    function BufferWhenOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    BufferWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
    };
    return BufferWhenOperator;
}());
var BufferWhenSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferWhenSubscriber, _super);
    function BufferWhenSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.subscribing = false;
        _this.openBuffer();
        return _this;
    }
    BufferWhenSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferWhenSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferWhenSubscriber.prototype._unsubscribe = function () {
        this.buffer = null;
        this.subscribing = false;
    };
    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openBuffer();
    };
    BufferWhenSubscriber.prototype.notifyComplete = function () {
        if (this.subscribing) {
            this.complete();
        }
        else {
            this.openBuffer();
        }
    };
    BufferWhenSubscriber.prototype.openBuffer = function () {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
            this.remove(closingSubscription);
            closingSubscription.unsubscribe();
        }
        var buffer = this.buffer;
        if (this.buffer) {
            this.destination.next(buffer);
        }
        this.buffer = [];
        var closingNotifier;
        try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector();
        }
        catch (err) {
            return this.error(err);
        }
        closingSubscription = new Subscription();
        this.closingSubscription = closingSubscription;
        this.add(closingSubscription);
        this.subscribing = true;
        closingSubscription.add(subscribeToResult(this, closingNotifier));
        this.subscribing = false;
    };
    return BufferWhenSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function catchError(selector) {
    return function catchErrorOperatorFunction(source) {
        var operator = new CatchOperator(selector);
        var caught = source.lift(operator);
        return (operator.caught = caught);
    };
}
var CatchOperator = /*@__PURE__*/ (function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}());
var CatchSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        var _this = _super.call(this, destination) || this;
        _this.selector = selector;
        _this.caught = caught;
        return _this;
    }
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
            this.add(innerSubscriber);
            subscribeToResult(this, result, undefined, undefined, innerSubscriber);
        }
    };
    return CatchSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _observable_combineLatest PURE_IMPORTS_END */
function combineAll(project) {
    return function (source) { return source.lift(new CombineLatestOperator(project)); };
}

/** PURE_IMPORTS_START _util_isArray,_observable_combineLatest,_observable_from PURE_IMPORTS_END */
function combineLatest$1() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var project = null;
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    if (observables.length === 1 && isArray(observables[0])) {
        observables = observables[0].slice();
    }
    return function (source) { return source.lift.call(from([source].concat(observables)), new CombineLatestOperator(project)); };
}

/** PURE_IMPORTS_START _observable_concat PURE_IMPORTS_END */
function concat$1() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function (source) { return source.lift.call(concat.apply(void 0, [source].concat(observables))); };
}

/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */
function concatMap(project, resultSelector) {
    return mergeMap(project, resultSelector, 1);
}

/** PURE_IMPORTS_START _concatMap PURE_IMPORTS_END */
function concatMapTo(innerObservable, resultSelector) {
    return concatMap(function () { return innerObservable; }, resultSelector);
}

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function count(predicate) {
    return function (source) { return source.lift(new CountOperator(predicate, source)); };
}
var CountOperator = /*@__PURE__*/ (function () {
    function CountOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    CountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
    };
    return CountOperator;
}());
var CountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(CountSubscriber, _super);
    function CountSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.count = 0;
        _this.index = 0;
        return _this;
    }
    CountSubscriber.prototype._next = function (value) {
        if (this.predicate) {
            this._tryPredicate(value);
        }
        else {
            this.count++;
        }
    };
    CountSubscriber.prototype._tryPredicate = function (value) {
        var result;
        try {
            result = this.predicate(value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.count++;
        }
    };
    CountSubscriber.prototype._complete = function () {
        this.destination.next(this.count);
        this.destination.complete();
    };
    return CountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function debounce(durationSelector) {
    return function (source) { return source.lift(new DebounceOperator(durationSelector)); };
}
var DebounceOperator = /*@__PURE__*/ (function () {
    function DebounceOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    DebounceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
    };
    return DebounceOperator;
}());
var DebounceSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DebounceSubscriber, _super);
    function DebounceSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        _this.durationSubscription = null;
        return _this;
    }
    DebounceSubscriber.prototype._next = function (value) {
        try {
            var result = this.durationSelector.call(this, value);
            if (result) {
                this._tryNext(value, result);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DebounceSubscriber.prototype._complete = function () {
        this.emitValue();
        this.destination.complete();
    };
    DebounceSubscriber.prototype._tryNext = function (value, duration) {
        var subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;
        if (subscription) {
            subscription.unsubscribe();
            this.remove(subscription);
        }
        subscription = subscribeToResult(this, duration);
        if (subscription && !subscription.closed) {
            this.add(this.durationSubscription = subscription);
        }
    };
    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    DebounceSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    DebounceSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            var value = this.value;
            var subscription = this.durationSubscription;
            if (subscription) {
                this.durationSubscription = null;
                subscription.unsubscribe();
                this.remove(subscription);
            }
            this.value = null;
            this.hasValue = false;
            _super.prototype._next.call(this, value);
        }
    };
    return DebounceSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) {
        scheduler = async;
    }
    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };
}
var DebounceTimeOperator = /*@__PURE__*/ (function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}());
var DebounceTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.dueTime = dueTime;
        _this.scheduler = scheduler;
        _this.debouncedSubscription = null;
        _this.lastValue = null;
        _this.hasValue = false;
        return _this;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$2, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            var lastValue = this.lastValue;
            this.lastValue = null;
            this.hasValue = false;
            this.destination.next(lastValue);
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber));
function dispatchNext$2(subscriber) {
    subscriber.debouncedNext();
}

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function defaultIfEmpty(defaultValue) {
    if (defaultValue === void 0) {
        defaultValue = null;
    }
    return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };
}
var DefaultIfEmptyOperator = /*@__PURE__*/ (function () {
    function DefaultIfEmptyOperator(defaultValue) {
        this.defaultValue = defaultValue;
    }
    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
    };
    return DefaultIfEmptyOperator;
}());
var DefaultIfEmptySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DefaultIfEmptySubscriber, _super);
    function DefaultIfEmptySubscriber(destination, defaultValue) {
        var _this = _super.call(this, destination) || this;
        _this.defaultValue = defaultValue;
        _this.isEmpty = true;
        return _this;
    }
    DefaultIfEmptySubscriber.prototype._next = function (value) {
        this.isEmpty = false;
        this.destination.next(value);
    };
    DefaultIfEmptySubscriber.prototype._complete = function () {
        if (this.isEmpty) {
            this.destination.next(this.defaultValue);
        }
        this.destination.complete();
    };
    return DefaultIfEmptySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}

/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */
function delay(delay, scheduler) {
    if (scheduler === void 0) {
        scheduler = async;
    }
    var absoluteDelay = isDate(delay);
    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };
}
var DelayOperator = /*@__PURE__*/ (function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}());
var DelaySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.delay = delay;
        _this.scheduler = scheduler;
        _this.queue = [];
        _this.active = false;
        _this.errored = false;
        return _this;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        }
        else {
            this.unsubscribe();
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        var destination = this.destination;
        destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(Notification.createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
        this.unsubscribe();
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(Notification.createComplete());
        this.unsubscribe();
    };
    return DelaySubscriber;
}(Subscriber));
var DelayMessage = /*@__PURE__*/ (function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}());

/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function delayWhen(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
        return function (source) {
            return new SubscriptionDelayObservable(source, subscriptionDelay)
                .lift(new DelayWhenOperator(delayDurationSelector));
        };
    }
    return function (source) { return source.lift(new DelayWhenOperator(delayDurationSelector)); };
}
var DelayWhenOperator = /*@__PURE__*/ (function () {
    function DelayWhenOperator(delayDurationSelector) {
        this.delayDurationSelector = delayDurationSelector;
    }
    DelayWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
    };
    return DelayWhenOperator;
}());
var DelayWhenSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DelayWhenSubscriber, _super);
    function DelayWhenSubscriber(destination, delayDurationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.delayDurationSelector = delayDurationSelector;
        _this.completed = false;
        _this.delayNotifierSubscriptions = [];
        _this.index = 0;
        return _this;
    }
    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        var value = this.removeSubscription(innerSub);
        if (value) {
            this.destination.next(value);
        }
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype._next = function (value) {
        var index = this.index++;
        try {
            var delayNotifier = this.delayDurationSelector(value, index);
            if (delayNotifier) {
                this.tryDelay(delayNotifier, value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DelayWhenSubscriber.prototype._complete = function () {
        this.completed = true;
        this.tryComplete();
        this.unsubscribe();
    };
    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
        subscription.unsubscribe();
        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
        if (subscriptionIdx !== -1) {
            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
        }
        return subscription.outerValue;
    };
    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
        var notifierSubscription = subscribeToResult(this, delayNotifier, value);
        if (notifierSubscription && !notifierSubscription.closed) {
            var destination = this.destination;
            destination.add(notifierSubscription);
            this.delayNotifierSubscriptions.push(notifierSubscription);
        }
    };
    DelayWhenSubscriber.prototype.tryComplete = function () {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
            this.destination.complete();
        }
    };
    return DelayWhenSubscriber;
}(OuterSubscriber));
var SubscriptionDelayObservable = /*@__PURE__*/ (function (_super) {
    __extends(SubscriptionDelayObservable, _super);
    function SubscriptionDelayObservable(source, subscriptionDelay) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subscriptionDelay = subscriptionDelay;
        return _this;
    }
    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
    };
    return SubscriptionDelayObservable;
}(Observable));
var SubscriptionDelaySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SubscriptionDelaySubscriber, _super);
    function SubscriptionDelaySubscriber(parent, source) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.source = source;
        _this.sourceSubscribed = false;
        return _this;
    }
    SubscriptionDelaySubscriber.prototype._next = function (unused) {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype._error = function (err) {
        this.unsubscribe();
        this.parent.error(err);
    };
    SubscriptionDelaySubscriber.prototype._complete = function () {
        this.unsubscribe();
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
        if (!this.sourceSubscribed) {
            this.sourceSubscribed = true;
            this.unsubscribe();
            this.source.subscribe(this.parent);
        }
    };
    return SubscriptionDelaySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function dematerialize() {
    return function dematerializeOperatorFunction(source) {
        return source.lift(new DeMaterializeOperator());
    };
}
var DeMaterializeOperator = /*@__PURE__*/ (function () {
    function DeMaterializeOperator() {
    }
    DeMaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DeMaterializeSubscriber(subscriber));
    };
    return DeMaterializeOperator;
}());
var DeMaterializeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DeMaterializeSubscriber, _super);
    function DeMaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    DeMaterializeSubscriber.prototype._next = function (value) {
        value.observe(this.destination);
    };
    return DeMaterializeSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function distinct(keySelector, flushes) {
    return function (source) { return source.lift(new DistinctOperator(keySelector, flushes)); };
}
var DistinctOperator = /*@__PURE__*/ (function () {
    function DistinctOperator(keySelector, flushes) {
        this.keySelector = keySelector;
        this.flushes = flushes;
    }
    DistinctOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
    };
    return DistinctOperator;
}());
var DistinctSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DistinctSubscriber, _super);
    function DistinctSubscriber(destination, keySelector, flushes) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.values = new Set();
        if (flushes) {
            _this.add(subscribeToResult(_this, flushes));
        }
        return _this;
    }
    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values.clear();
    };
    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DistinctSubscriber.prototype._next = function (value) {
        if (this.keySelector) {
            this._useKeySelector(value);
        }
        else {
            this._finalizeNext(value, value);
        }
    };
    DistinctSubscriber.prototype._useKeySelector = function (value) {
        var key;
        var destination = this.destination;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this._finalizeNext(key, value);
    };
    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
        var values = this.values;
        if (!values.has(key)) {
            values.add(key);
            this.destination.next(value);
        }
    };
    return DistinctSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function distinctUntilChanged(compare, keySelector) {
    return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };
}
var DistinctUntilChangedOperator = /*@__PURE__*/ (function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}());
var DistinctUntilChangedSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.hasKey = false;
        if (typeof compare === 'function') {
            _this.compare = compare;
        }
        return _this;
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var key;
        try {
            var keySelector = this.keySelector;
            key = keySelector ? keySelector(value) : value;
        }
        catch (err) {
            return this.destination.error(err);
        }
        var result = false;
        if (this.hasKey) {
            try {
                var compare = this.compare;
                result = compare(this.key, key);
            }
            catch (err) {
                return this.destination.error(err);
            }
        }
        else {
            this.hasKey = true;
        }
        if (!result) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _distinctUntilChanged PURE_IMPORTS_END */
function distinctUntilKeyChanged(key, compare) {
    return distinctUntilChanged(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });
}

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
var FilterOperator = /*@__PURE__*/ (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
var FilterSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
    }
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */
function tap(nextOrObserver, error, complete) {
    return function tapOperatorFunction(source) {
        return source.lift(new DoOperator(nextOrObserver, error, complete));
    };
}
var DoOperator = /*@__PURE__*/ (function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}());
var TapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TapSubscriber, _super);
    function TapSubscriber(destination, observerOrNext, error, complete) {
        var _this = _super.call(this, destination) || this;
        _this._tapNext = noop;
        _this._tapError = noop;
        _this._tapComplete = noop;
        _this._tapError = error || noop;
        _this._tapComplete = complete || noop;
        if (isFunction(observerOrNext)) {
            _this._context = _this;
            _this._tapNext = observerOrNext;
        }
        else if (observerOrNext) {
            _this._context = observerOrNext;
            _this._tapNext = observerOrNext.next || noop;
            _this._tapError = observerOrNext.error || noop;
            _this._tapComplete = observerOrNext.complete || noop;
        }
        return _this;
    }
    TapSubscriber.prototype._next = function (value) {
        try {
            this._tapNext.call(this._context, value);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(value);
    };
    TapSubscriber.prototype._error = function (err) {
        try {
            this._tapError.call(this._context, err);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.error(err);
    };
    TapSubscriber.prototype._complete = function () {
        try {
            this._tapComplete.call(this._context);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        return this.destination.complete();
    };
    return TapSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _tap,_util_EmptyError PURE_IMPORTS_END */
var throwIfEmpty = function (errorFactory) {
    if (errorFactory === void 0) {
        errorFactory = defaultErrorFactory;
    }
    return tap({
        hasValue: false,
        next: function () { this.hasValue = true; },
        complete: function () {
            if (!this.hasValue) {
                throw errorFactory();
            }
        }
    });
};
function defaultErrorFactory() {
    return new EmptyError();
}

/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
function take(count) {
    return function (source) {
        if (count === 0) {
            return empty$1();
        }
        else {
            return source.lift(new TakeOperator(count));
        }
    };
}
var TakeOperator = /*@__PURE__*/ (function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError;
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}());
var TakeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _util_ArgumentOutOfRangeError,_filter,_throwIfEmpty,_defaultIfEmpty,_take PURE_IMPORTS_END */
function elementAt(index, defaultValue) {
    if (index < 0) {
        throw new ArgumentOutOfRangeError();
    }
    var hasDefaultValue = arguments.length >= 2;
    return function (source) {
        return source.pipe(filter(function (v, i) { return i === index; }), take(1), hasDefaultValue
            ? defaultIfEmpty(defaultValue)
            : throwIfEmpty(function () { return new ArgumentOutOfRangeError(); }));
    };
}

/** PURE_IMPORTS_START _observable_fromArray,_observable_scalar,_observable_empty,_observable_concat,_util_isScheduler PURE_IMPORTS_END */
function endWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
    }
    return function (source) {
        var scheduler = array[array.length - 1];
        if (isScheduler(scheduler)) {
            array.pop();
        }
        else {
            scheduler = null;
        }
        var len = array.length;
        if (len === 1 && !scheduler) {
            return concat(source, scalar(array[0]));
        }
        else if (len > 0) {
            return concat(source, fromArray(array, scheduler));
        }
        else {
            return concat(source, empty$1(scheduler));
        }
    };
}

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function every(predicate, thisArg) {
    return function (source) { return source.lift(new EveryOperator(predicate, thisArg, source)); };
}
var EveryOperator = /*@__PURE__*/ (function () {
    function EveryOperator(predicate, thisArg, source) {
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
    }
    EveryOperator.prototype.call = function (observer, source) {
        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
    };
    return EveryOperator;
}());
var EverySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(EverySubscriber, _super);
    function EverySubscriber(destination, predicate, thisArg, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.source = source;
        _this.index = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
        this.destination.next(everyValueMatch);
        this.destination.complete();
    };
    EverySubscriber.prototype._next = function (value) {
        var result = false;
        try {
            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (!result) {
            this.notifyComplete(false);
        }
    };
    EverySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return EverySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function exhaust() {
    return function (source) { return source.lift(new SwitchFirstOperator()); };
}
var SwitchFirstOperator = /*@__PURE__*/ (function () {
    function SwitchFirstOperator() {
    }
    SwitchFirstOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchFirstSubscriber(subscriber));
    };
    return SwitchFirstOperator;
}());
var SwitchFirstSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SwitchFirstSubscriber, _super);
    function SwitchFirstSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasCompleted = false;
        _this.hasSubscription = false;
        return _this;
    }
    SwitchFirstSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.hasSubscription = true;
            this.add(subscribeToResult(this, value));
        }
    };
    SwitchFirstSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */
function exhaustMap(project, resultSelector) {
    if (resultSelector) {
        return function (source) { return source.pipe(exhaustMap(function (a, i) { return from(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) {
        return source.lift(new ExhaustMapOperator(project));
    };
}
var ExhaustMapOperator = /*@__PURE__*/ (function () {
    function ExhaustMapOperator(project) {
        this.project = project;
    }
    ExhaustMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
    };
    return ExhaustMapOperator;
}());
var ExhaustMapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ExhaustMapSubscriber, _super);
    function ExhaustMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.hasSubscription = false;
        _this.hasCompleted = false;
        _this.index = 0;
        return _this;
    }
    ExhaustMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    ExhaustMapSubscriber.prototype.tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.hasSubscription = true;
        this._innerSub(result, value, index);
    };
    ExhaustMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
        var destination = this.destination;
        destination.add(innerSubscriber);
        subscribeToResult(this, result, value, index, innerSubscriber);
    };
    ExhaustMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    ExhaustMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    ExhaustMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    ExhaustMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var destination = this.destination;
        destination.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return ExhaustMapSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function expand(project, concurrent, scheduler) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (scheduler === void 0) {
        scheduler = undefined;
    }
    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
    return function (source) { return source.lift(new ExpandOperator(project, concurrent, scheduler)); };
}
var ExpandOperator = /*@__PURE__*/ (function () {
    function ExpandOperator(project, concurrent, scheduler) {
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
    }
    ExpandOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
    };
    return ExpandOperator;
}());
var ExpandSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ExpandSubscriber, _super);
    function ExpandSubscriber(destination, project, concurrent, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.scheduler = scheduler;
        _this.index = 0;
        _this.active = 0;
        _this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
            _this.buffer = [];
        }
        return _this;
    }
    ExpandSubscriber.dispatch = function (arg) {
        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
        subscriber.subscribeToProjection(result, value, index);
    };
    ExpandSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (destination.closed) {
            this._complete();
            return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
            destination.next(value);
            try {
                var project = this.project;
                var result = project(value, index);
                if (!this.scheduler) {
                    this.subscribeToProjection(result, value, index);
                }
                else {
                    var state = { subscriber: this, result: result, value: value, index: index };
                    var destination_1 = this.destination;
                    destination_1.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
                }
            }
            catch (e) {
                destination.error(e);
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
        this.active++;
        var destination = this.destination;
        destination.add(subscribeToResult(this, result, value, index));
    };
    ExpandSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this._next(innerValue);
    };
    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        var destination = this.destination;
        destination.remove(innerSub);
        this.active--;
        if (buffer && buffer.length > 0) {
            this._next(buffer.shift());
        }
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return ExpandSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */
function finalize(callback) {
    return function (source) { return source.lift(new FinallyOperator(callback)); };
}
var FinallyOperator = /*@__PURE__*/ (function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}());
var FinallySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        var _this = _super.call(this, destination) || this;
        _this.add(new Subscription(callback));
        return _this;
    }
    return FinallySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function find(predicate, thisArg) {
    if (typeof predicate !== 'function') {
        throw new TypeError('predicate is not a function');
    }
    return function (source) { return source.lift(new FindValueOperator(predicate, source, false, thisArg)); };
}
var FindValueOperator = /*@__PURE__*/ (function () {
    function FindValueOperator(predicate, source, yieldIndex, thisArg) {
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
    }
    FindValueOperator.prototype.call = function (observer, source) {
        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
    };
    return FindValueOperator;
}());
var FindValueSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(FindValueSubscriber, _super);
    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.yieldIndex = yieldIndex;
        _this.thisArg = thisArg;
        _this.index = 0;
        return _this;
    }
    FindValueSubscriber.prototype.notifyComplete = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
        this.unsubscribe();
    };
    FindValueSubscriber.prototype._next = function (value) {
        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
        var index = this.index++;
        try {
            var result = predicate.call(thisArg || this, value, index, this.source);
            if (result) {
                this.notifyComplete(this.yieldIndex ? index : value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    FindValueSubscriber.prototype._complete = function () {
        this.notifyComplete(this.yieldIndex ? -1 : undefined);
    };
    return FindValueSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _operators_find PURE_IMPORTS_END */
function findIndex(predicate, thisArg) {
    return function (source) { return source.lift(new FindValueOperator(predicate, source, true, thisArg)); };
}

/** PURE_IMPORTS_START _util_EmptyError,_filter,_take,_defaultIfEmpty,_throwIfEmpty,_util_identity PURE_IMPORTS_END */
function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(predicate ? filter(function (v, i) { return predicate(v, i, source); }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function () { return new EmptyError(); })); };
}

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function ignoreElements() {
    return function ignoreElementsOperatorFunction(source) {
        return source.lift(new IgnoreElementsOperator());
    };
}
var IgnoreElementsOperator = /*@__PURE__*/ (function () {
    function IgnoreElementsOperator() {
    }
    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
    };
    return IgnoreElementsOperator;
}());
var IgnoreElementsSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(IgnoreElementsSubscriber, _super);
    function IgnoreElementsSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IgnoreElementsSubscriber.prototype._next = function (unused) {
    };
    return IgnoreElementsSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function isEmpty() {
    return function (source) { return source.lift(new IsEmptyOperator()); };
}
var IsEmptyOperator = /*@__PURE__*/ (function () {
    function IsEmptyOperator() {
    }
    IsEmptyOperator.prototype.call = function (observer, source) {
        return source.subscribe(new IsEmptySubscriber(observer));
    };
    return IsEmptyOperator;
}());
var IsEmptySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(IsEmptySubscriber, _super);
    function IsEmptySubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
        var destination = this.destination;
        destination.next(isEmpty);
        destination.complete();
    };
    IsEmptySubscriber.prototype._next = function (value) {
        this.notifyComplete(false);
    };
    IsEmptySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return IsEmptySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
function takeLast(count) {
    return function takeLastOperatorFunction(source) {
        if (count === 0) {
            return empty$1();
        }
        else {
            return source.lift(new TakeLastOperator(count));
        }
    };
}
var TakeLastOperator = /*@__PURE__*/ (function () {
    function TakeLastOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError;
        }
    }
    TakeLastOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
    };
    return TakeLastOperator;
}());
var TakeLastSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.ring = new Array();
        _this.count = 0;
        return _this;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        }
        else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = (count++) % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _util_EmptyError,_filter,_takeLast,_throwIfEmpty,_defaultIfEmpty,_util_identity PURE_IMPORTS_END */
function last(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(predicate ? filter(function (v, i) { return predicate(v, i, source); }) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function () { return new EmptyError(); })); };
}

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function mapTo(value) {
    return function (source) { return source.lift(new MapToOperator(value)); };
}
var MapToOperator = /*@__PURE__*/ (function () {
    function MapToOperator(value) {
        this.value = value;
    }
    MapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
    };
    return MapToOperator;
}());
var MapToSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        var _this = _super.call(this, destination) || this;
        _this.value = value;
        return _this;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */
function materialize() {
    return function materializeOperatorFunction(source) {
        return source.lift(new MaterializeOperator());
    };
}
var MaterializeOperator = /*@__PURE__*/ (function () {
    function MaterializeOperator() {
    }
    MaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MaterializeSubscriber(subscriber));
    };
    return MaterializeOperator;
}());
var MaterializeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MaterializeSubscriber, _super);
    function MaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    MaterializeSubscriber.prototype._next = function (value) {
        this.destination.next(Notification.createNext(value));
    };
    MaterializeSubscriber.prototype._error = function (err) {
        var destination = this.destination;
        destination.next(Notification.createError(err));
        destination.complete();
    };
    MaterializeSubscriber.prototype._complete = function () {
        var destination = this.destination;
        destination.next(Notification.createComplete());
        destination.complete();
    };
    return MaterializeSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function scan(accumulator, seed) {
    var hasSeed = false;
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return function scanOperatorFunction(source) {
        return source.lift(new ScanOperator(accumulator, seed, hasSeed));
    };
}
var ScanOperator = /*@__PURE__*/ (function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) {
            hasSeed = false;
        }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}());
var ScanSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this._seed = _seed;
        _this.hasSeed = hasSeed;
        _this.index = 0;
        return _this;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _scan,_takeLast,_defaultIfEmpty,_util_pipe PURE_IMPORTS_END */
function reduce(accumulator, seed) {
    if (arguments.length >= 2) {
        return function reduceOperatorFunctionWithSeed(source) {
            return pipe(scan(accumulator, seed), takeLast(1), defaultIfEmpty(seed))(source);
        };
    }
    return function reduceOperatorFunction(source) {
        return pipe(scan(function (acc, value, index) { return accumulator(acc, value, index + 1); }), takeLast(1))(source);
    };
}

/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */
function max(comparer) {
    var max = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) > 0 ? x : y; }
        : function (x, y) { return x > y ? x : y; };
    return reduce(max);
}

/** PURE_IMPORTS_START _observable_merge PURE_IMPORTS_END */
function merge$1() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function (source) { return source.lift.call(merge.apply(void 0, [source].concat(observables))); };
}

/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */
function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'function') {
        return mergeMap(function () { return innerObservable; }, resultSelector, concurrent);
    }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return mergeMap(function () { return innerObservable; }, concurrent);
}

/** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber PURE_IMPORTS_END */
function mergeScan(accumulator, seed, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return function (source) { return source.lift(new MergeScanOperator(accumulator, seed, concurrent)); };
}
var MergeScanOperator = /*@__PURE__*/ (function () {
    function MergeScanOperator(accumulator, seed, concurrent) {
        this.accumulator = accumulator;
        this.seed = seed;
        this.concurrent = concurrent;
    }
    MergeScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
    };
    return MergeScanOperator;
}());
var MergeScanSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MergeScanSubscriber, _super);
    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this.acc = acc;
        _this.concurrent = concurrent;
        _this.hasValue = false;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeScanSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var index = this.index++;
            var destination = this.destination;
            var ish = void 0;
            try {
                var accumulator = this.accumulator;
                ish = accumulator(this.acc, value, index);
            }
            catch (e) {
                return destination.error(e);
            }
            this.active++;
            this._innerSub(ish, value, index);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {
        var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
        var destination = this.destination;
        destination.add(innerSubscriber);
        subscribeToResult(this, ish, value, index, innerSubscriber);
    };
    MergeScanSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var destination = this.destination;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
    };
    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        var destination = this.destination;
        destination.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    return MergeScanSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */
function min(comparer) {
    var min = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) < 0 ? x : y; }
        : function (x, y) { return x < y ? x : y; };
    return reduce(min);
}

/** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */
function multicast(subjectOrSubjectFactory, selector) {
    return function multicastOperatorFunction(source) {
        var subjectFactory;
        if (typeof subjectOrSubjectFactory === 'function') {
            subjectFactory = subjectOrSubjectFactory;
        }
        else {
            subjectFactory = function subjectFactory() {
                return subjectOrSubjectFactory;
            };
        }
        if (typeof selector === 'function') {
            return source.lift(new MulticastOperator(subjectFactory, selector));
        }
        var connectable = Object.create(source, connectableObservableDescriptor);
        connectable.source = source;
        connectable.subjectFactory = subjectFactory;
        return connectable;
    };
}
var MulticastOperator = /*@__PURE__*/ (function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}());

/** PURE_IMPORTS_START tslib,_observable_from,_util_isArray,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function onErrorResumeNext$1() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i] = arguments[_i];
    }
    if (nextSources.length === 1 && isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    return function (source) { return source.lift(new OnErrorResumeNextOperator(nextSources)); };
}
var OnErrorResumeNextOperator = /*@__PURE__*/ (function () {
    function OnErrorResumeNextOperator(nextSources) {
        this.nextSources = nextSources;
    }
    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
    };
    return OnErrorResumeNextOperator;
}());
var OnErrorResumeNextSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(OnErrorResumeNextSubscriber, _super);
    function OnErrorResumeNextSubscriber(destination, nextSources) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.nextSources = nextSources;
        return _this;
    }
    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._error = function (err) {
        this.subscribeToNextSource();
        this.unsubscribe();
    };
    OnErrorResumeNextSubscriber.prototype._complete = function () {
        this.subscribeToNextSource();
        this.unsubscribe();
    };
    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
        var next = this.nextSources.shift();
        if (!!next) {
            var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
            var destination = this.destination;
            destination.add(innerSubscriber);
            subscribeToResult(this, next, undefined, undefined, innerSubscriber);
        }
        else {
            this.destination.complete();
        }
    };
    return OnErrorResumeNextSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function pairwise() {
    return function (source) { return source.lift(new PairwiseOperator()); };
}
var PairwiseOperator = /*@__PURE__*/ (function () {
    function PairwiseOperator() {
    }
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}());
var PairwiseSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasPrev = false;
        return _this;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        if (this.hasPrev) {
            this.destination.next([this.prev, value]);
        }
        else {
            this.hasPrev = true;
        }
        this.prev = value;
    };
    return PairwiseSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function not(pred, thisArg) {
    function notPred() {
        return !(notPred.pred.apply(notPred.thisArg, arguments));
    }
    notPred.pred = pred;
    notPred.thisArg = thisArg;
    return notPred;
}

/** PURE_IMPORTS_START _util_not,_filter PURE_IMPORTS_END */
function partition(predicate, thisArg) {
    return function (source) {
        return [
            filter(predicate, thisArg)(source),
            filter(not(predicate, thisArg))(source)
        ];
    };
}

/** PURE_IMPORTS_START _map PURE_IMPORTS_END */
function pluck() {
    var properties = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        properties[_i] = arguments[_i];
    }
    var length = properties.length;
    if (length === 0) {
        throw new Error('list of properties cannot be empty.');
    }
    return function (source) { return map(plucker(properties, length))(source); };
}
function plucker(props, length) {
    var mapper = function (x) {
        var currentProp = x;
        for (var i = 0; i < length; i++) {
            var p = currentProp[props[i]];
            if (typeof p !== 'undefined') {
                currentProp = p;
            }
            else {
                return undefined;
            }
        }
        return currentProp;
    };
    return mapper;
}

/** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */
function publish(selector) {
    return selector ?
        multicast(function () { return new Subject(); }, selector) :
        multicast(new Subject());
}

/** PURE_IMPORTS_START _BehaviorSubject,_multicast PURE_IMPORTS_END */
function publishBehavior(value) {
    return function (source) { return multicast(new BehaviorSubject(value))(source); };
}

/** PURE_IMPORTS_START _AsyncSubject,_multicast PURE_IMPORTS_END */
function publishLast() {
    return function (source) { return multicast(new AsyncSubject())(source); };
}

/** PURE_IMPORTS_START _ReplaySubject,_multicast PURE_IMPORTS_END */
function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {
    if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {
        scheduler = selectorOrScheduler;
    }
    var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;
    var subject = new ReplaySubject(bufferSize, windowTime, scheduler);
    return function (source) { return multicast(function () { return subject; }, selector)(source); };
}

/** PURE_IMPORTS_START _util_isArray,_observable_race PURE_IMPORTS_END */
function race$1() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function raceOperatorFunction(source) {
        if (observables.length === 1 && isArray(observables[0])) {
            observables = observables[0];
        }
        return source.lift.call(race.apply(void 0, [source].concat(observables)));
    };
}

/** PURE_IMPORTS_START tslib,_Subscriber,_observable_empty PURE_IMPORTS_END */
function repeat(count) {
    if (count === void 0) {
        count = -1;
    }
    return function (source) {
        if (count === 0) {
            return empty$1();
        }
        else if (count < 0) {
            return source.lift(new RepeatOperator(-1, source));
        }
        else {
            return source.lift(new RepeatOperator(count - 1, source));
        }
    };
}
var RepeatOperator = /*@__PURE__*/ (function () {
    function RepeatOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RepeatOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
    };
    return RepeatOperator;
}());
var RepeatSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RepeatSubscriber, _super);
    function RepeatSubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RepeatSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.complete.call(this);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RepeatSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function repeatWhen(notifier) {
    return function (source) { return source.lift(new RepeatWhenOperator(notifier)); };
}
var RepeatWhenOperator = /*@__PURE__*/ (function () {
    function RepeatWhenOperator(notifier) {
        this.notifier = notifier;
    }
    RepeatWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
    };
    return RepeatWhenOperator;
}());
var RepeatWhenSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RepeatWhenSubscriber, _super);
    function RepeatWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        _this.sourceIsBeingSubscribedTo = true;
        return _this;
    }
    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.sourceIsBeingSubscribedTo = true;
        this.source.subscribe(this);
    };
    RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        if (this.sourceIsBeingSubscribedTo === false) {
            return _super.prototype.complete.call(this);
        }
    };
    RepeatWhenSubscriber.prototype.complete = function () {
        this.sourceIsBeingSubscribedTo = false;
        if (!this.isStopped) {
            if (!this.retries) {
                this.subscribeToRetries();
            }
            if (!this.retriesSubscription || this.retriesSubscription.closed) {
                return _super.prototype.complete.call(this);
            }
            this._unsubscribeAndRecycle();
            this.notifications.next();
        }
    };
    RepeatWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
        if (notifications) {
            notifications.unsubscribe();
            this.notifications = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        _super.prototype._unsubscribeAndRecycle.call(this);
        this._unsubscribe = _unsubscribe;
        return this;
    };
    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
        this.notifications = new Subject();
        var retries;
        try {
            var notifier = this.notifier;
            retries = notifier(this.notifications);
        }
        catch (e) {
            return _super.prototype.complete.call(this);
        }
        this.retries = retries;
        this.retriesSubscription = subscribeToResult(this, retries);
    };
    return RepeatWhenSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function retry(count) {
    if (count === void 0) {
        count = -1;
    }
    return function (source) { return source.lift(new RetryOperator(count, source)); };
}
var RetryOperator = /*@__PURE__*/ (function () {
    function RetryOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RetryOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
    };
    return RetryOperator;
}());
var RetrySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RetrySubscriber, _super);
    function RetrySubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RetrySubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.error.call(this, err);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RetrySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function retryWhen(notifier) {
    return function (source) { return source.lift(new RetryWhenOperator(notifier, source)); };
}
var RetryWhenOperator = /*@__PURE__*/ (function () {
    function RetryWhenOperator(notifier, source) {
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
    };
    return RetryWhenOperator;
}());
var RetryWhenSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RetryWhenSubscriber, _super);
    function RetryWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        return _this;
    }
    RetryWhenSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var errors = this.errors;
            var retries = this.retries;
            var retriesSubscription = this.retriesSubscription;
            if (!retries) {
                errors = new Subject();
                try {
                    var notifier = this.notifier;
                    retries = notifier(errors);
                }
                catch (e) {
                    return _super.prototype.error.call(this, e);
                }
                retriesSubscription = subscribeToResult(this, retries);
            }
            else {
                this.errors = null;
                this.retriesSubscription = null;
            }
            this._unsubscribeAndRecycle();
            this.errors = errors;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            errors.next(err);
        }
    };
    RetryWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
        if (errors) {
            errors.unsubscribe();
            this.errors = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        this._unsubscribeAndRecycle();
        this._unsubscribe = _unsubscribe;
        this.source.subscribe(this);
    };
    return RetryWhenSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function sample(notifier) {
    return function (source) { return source.lift(new SampleOperator(notifier)); };
}
var SampleOperator = /*@__PURE__*/ (function () {
    function SampleOperator(notifier) {
        this.notifier = notifier;
    }
    SampleOperator.prototype.call = function (subscriber, source) {
        var sampleSubscriber = new SampleSubscriber(subscriber);
        var subscription = source.subscribe(sampleSubscriber);
        subscription.add(subscribeToResult(sampleSubscriber, this.notifier));
        return subscription;
    };
    return SampleOperator;
}());
var SampleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SampleSubscriber, _super);
    function SampleSubscriber() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hasValue = false;
        return _this;
    }
    SampleSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
    };
    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    SampleSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.value);
        }
    };
    return SampleSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */
function sampleTime(period, scheduler) {
    if (scheduler === void 0) {
        scheduler = async;
    }
    return function (source) { return source.lift(new SampleTimeOperator(period, scheduler)); };
}
var SampleTimeOperator = /*@__PURE__*/ (function () {
    function SampleTimeOperator(period, scheduler) {
        this.period = period;
        this.scheduler = scheduler;
    }
    SampleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
    };
    return SampleTimeOperator;
}());
var SampleTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SampleTimeSubscriber, _super);
    function SampleTimeSubscriber(destination, period, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.period = period;
        _this.scheduler = scheduler;
        _this.hasValue = false;
        _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period: period }));
        return _this;
    }
    SampleTimeSubscriber.prototype._next = function (value) {
        this.lastValue = value;
        this.hasValue = true;
    };
    SampleTimeSubscriber.prototype.notifyNext = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.lastValue);
        }
    };
    return SampleTimeSubscriber;
}(Subscriber));
function dispatchNotification(state) {
    var subscriber = state.subscriber, period = state.period;
    subscriber.notifyNext();
    this.schedule(state, period);
}

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function sequenceEqual(compareTo, comparator) {
    return function (source) { return source.lift(new SequenceEqualOperator(compareTo, comparator)); };
}
var SequenceEqualOperator = /*@__PURE__*/ (function () {
    function SequenceEqualOperator(compareTo, comparator) {
        this.compareTo = compareTo;
        this.comparator = comparator;
    }
    SequenceEqualOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
    };
    return SequenceEqualOperator;
}());
var SequenceEqualSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SequenceEqualSubscriber, _super);
    function SequenceEqualSubscriber(destination, compareTo, comparator) {
        var _this = _super.call(this, destination) || this;
        _this.compareTo = compareTo;
        _this.comparator = comparator;
        _this._a = [];
        _this._b = [];
        _this._oneComplete = false;
        _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
        return _this;
    }
    SequenceEqualSubscriber.prototype._next = function (value) {
        if (this._oneComplete && this._b.length === 0) {
            this.emit(false);
        }
        else {
            this._a.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype._complete = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
        this.unsubscribe();
    };
    SequenceEqualSubscriber.prototype.checkValues = function () {
        var _c = this, _a = _c._a, _b = _c._b, comparator = _c.comparator;
        while (_a.length > 0 && _b.length > 0) {
            var a = _a.shift();
            var b = _b.shift();
            var areEqual = false;
            try {
                areEqual = comparator ? comparator(a, b) : a === b;
            }
            catch (e) {
                this.destination.error(e);
            }
            if (!areEqual) {
                this.emit(false);
            }
        }
    };
    SequenceEqualSubscriber.prototype.emit = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    SequenceEqualSubscriber.prototype.nextB = function (value) {
        if (this._oneComplete && this._a.length === 0) {
            this.emit(false);
        }
        else {
            this._b.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype.completeB = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
    };
    return SequenceEqualSubscriber;
}(Subscriber));
var SequenceEqualCompareToSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SequenceEqualCompareToSubscriber, _super);
    function SequenceEqualCompareToSubscriber(destination, parent) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        return _this;
    }
    SequenceEqualCompareToSubscriber.prototype._next = function (value) {
        this.parent.nextB(value);
    };
    SequenceEqualCompareToSubscriber.prototype._error = function (err) {
        this.parent.error(err);
        this.unsubscribe();
    };
    SequenceEqualCompareToSubscriber.prototype._complete = function () {
        this.parent.completeB();
        this.unsubscribe();
    };
    return SequenceEqualCompareToSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */
function shareSubjectFactory() {
    return new Subject();
}
function share() {
    return function (source) { return refCount()(multicast(shareSubjectFactory)(source)); };
}

/** PURE_IMPORTS_START _ReplaySubject PURE_IMPORTS_END */
function shareReplay(configOrBufferSize, windowTime, scheduler) {
    var config;
    if (configOrBufferSize && typeof configOrBufferSize === 'object') {
        config = configOrBufferSize;
    }
    else {
        config = {
            bufferSize: configOrBufferSize,
            windowTime: windowTime,
            refCount: false,
            scheduler: scheduler
        };
    }
    return function (source) { return source.lift(shareReplayOperator(config)); };
}
function shareReplayOperator(_a) {
    var _b = _a.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a.windowTime, windowTime = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a.refCount, scheduler = _a.scheduler;
    var subject;
    var refCount = 0;
    var subscription;
    var hasError = false;
    var isComplete = false;
    return function shareReplayOperation(source) {
        refCount++;
        if (!subject || hasError) {
            hasError = false;
            subject = new ReplaySubject(bufferSize, windowTime, scheduler);
            subscription = source.subscribe({
                next: function (value) { subject.next(value); },
                error: function (err) {
                    hasError = true;
                    subject.error(err);
                },
                complete: function () {
                    isComplete = true;
                    subject.complete();
                },
            });
        }
        var innerSub = subject.subscribe(this);
        this.add(function () {
            refCount--;
            innerSub.unsubscribe();
            if (subscription && !isComplete && useRefCount && refCount === 0) {
                subscription.unsubscribe();
                subscription = undefined;
                subject = undefined;
            }
        });
    };
}

/** PURE_IMPORTS_START tslib,_Subscriber,_util_EmptyError PURE_IMPORTS_END */
function single(predicate) {
    return function (source) { return source.lift(new SingleOperator(predicate, source)); };
}
var SingleOperator = /*@__PURE__*/ (function () {
    function SingleOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    SingleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
    };
    return SingleOperator;
}());
var SingleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SingleSubscriber, _super);
    function SingleSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.seenValue = false;
        _this.index = 0;
        return _this;
    }
    SingleSubscriber.prototype.applySingleValue = function (value) {
        if (this.seenValue) {
            this.destination.error('Sequence contains more than one element');
        }
        else {
            this.seenValue = true;
            this.singleValue = value;
        }
    };
    SingleSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this.tryNext(value, index);
        }
        else {
            this.applySingleValue(value);
        }
    };
    SingleSubscriber.prototype.tryNext = function (value, index) {
        try {
            if (this.predicate(value, index, this.source)) {
                this.applySingleValue(value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    SingleSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index > 0) {
            destination.next(this.seenValue ? this.singleValue : undefined);
            destination.complete();
        }
        else {
            destination.error(new EmptyError);
        }
    };
    return SingleSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function skip(count) {
    return function (source) { return source.lift(new SkipOperator(count)); };
}
var SkipOperator = /*@__PURE__*/ (function () {
    function SkipOperator(total) {
        this.total = total;
    }
    SkipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
    };
    return SkipOperator;
}());
var SkipSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SkipSubscriber, _super);
    function SkipSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    SkipSubscriber.prototype._next = function (x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };
    return SkipSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError PURE_IMPORTS_END */
function skipLast(count) {
    return function (source) { return source.lift(new SkipLastOperator(count)); };
}
var SkipLastOperator = /*@__PURE__*/ (function () {
    function SkipLastOperator(_skipCount) {
        this._skipCount = _skipCount;
        if (this._skipCount < 0) {
            throw new ArgumentOutOfRangeError;
        }
    }
    SkipLastOperator.prototype.call = function (subscriber, source) {
        if (this._skipCount === 0) {
            return source.subscribe(new Subscriber(subscriber));
        }
        else {
            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
        }
    };
    return SkipLastOperator;
}());
var SkipLastSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SkipLastSubscriber, _super);
    function SkipLastSubscriber(destination, _skipCount) {
        var _this = _super.call(this, destination) || this;
        _this._skipCount = _skipCount;
        _this._count = 0;
        _this._ring = new Array(_skipCount);
        return _this;
    }
    SkipLastSubscriber.prototype._next = function (value) {
        var skipCount = this._skipCount;
        var count = this._count++;
        if (count < skipCount) {
            this._ring[count] = value;
        }
        else {
            var currentIndex = count % skipCount;
            var ring = this._ring;
            var oldValue = ring[currentIndex];
            ring[currentIndex] = value;
            this.destination.next(oldValue);
        }
    };
    return SkipLastSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function skipUntil(notifier) {
    return function (source) { return source.lift(new SkipUntilOperator(notifier)); };
}
var SkipUntilOperator = /*@__PURE__*/ (function () {
    function SkipUntilOperator(notifier) {
        this.notifier = notifier;
    }
    SkipUntilOperator.prototype.call = function (destination, source) {
        return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
    };
    return SkipUntilOperator;
}());
var SkipUntilSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SkipUntilSubscriber, _super);
    function SkipUntilSubscriber(destination, notifier) {
        var _this = _super.call(this, destination) || this;
        _this.hasValue = false;
        var innerSubscriber = new InnerSubscriber(_this, undefined, undefined);
        _this.add(innerSubscriber);
        _this.innerSubscription = innerSubscriber;
        subscribeToResult(_this, notifier, undefined, undefined, innerSubscriber);
        return _this;
    }
    SkipUntilSubscriber.prototype._next = function (value) {
        if (this.hasValue) {
            _super.prototype._next.call(this, value);
        }
    };
    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.hasValue = true;
        if (this.innerSubscription) {
            this.innerSubscription.unsubscribe();
        }
    };
    SkipUntilSubscriber.prototype.notifyComplete = function () {
    };
    return SkipUntilSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function skipWhile(predicate) {
    return function (source) { return source.lift(new SkipWhileOperator(predicate)); };
}
var SkipWhileOperator = /*@__PURE__*/ (function () {
    function SkipWhileOperator(predicate) {
        this.predicate = predicate;
    }
    SkipWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
    };
    return SkipWhileOperator;
}());
var SkipWhileSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SkipWhileSubscriber, _super);
    function SkipWhileSubscriber(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.skipping = true;
        _this.index = 0;
        return _this;
    }
    SkipWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (this.skipping) {
            this.tryCallPredicate(value);
        }
        if (!this.skipping) {
            destination.next(value);
        }
    };
    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
        try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    return SkipWhileSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _observable_fromArray,_observable_scalar,_observable_empty,_observable_concat,_util_isScheduler PURE_IMPORTS_END */
function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
    }
    return function (source) {
        var scheduler = array[array.length - 1];
        if (isScheduler(scheduler)) {
            array.pop();
        }
        else {
            scheduler = null;
        }
        var len = array.length;
        if (len === 1 && !scheduler) {
            return concat(scalar(array[0]), source);
        }
        else if (len > 0) {
            return concat(fromArray(array, scheduler), source);
        }
        else {
            return concat(empty$1(scheduler), source);
        }
    };
}

/** PURE_IMPORTS_START tslib,_Observable,_scheduler_asap,_util_isNumeric PURE_IMPORTS_END */
var SubscribeOnObservable = /*@__PURE__*/ (function (_super) {
    __extends(SubscribeOnObservable, _super);
    function SubscribeOnObservable(source, delayTime, scheduler) {
        if (delayTime === void 0) {
            delayTime = 0;
        }
        if (scheduler === void 0) {
            scheduler = asap;
        }
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.delayTime = delayTime;
        _this.scheduler = scheduler;
        if (!isNumeric(delayTime) || delayTime < 0) {
            _this.delayTime = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== 'function') {
            _this.scheduler = asap;
        }
        return _this;
    }
    SubscribeOnObservable.create = function (source, delay, scheduler) {
        if (delay === void 0) {
            delay = 0;
        }
        if (scheduler === void 0) {
            scheduler = asap;
        }
        return new SubscribeOnObservable(source, delay, scheduler);
    };
    SubscribeOnObservable.dispatch = function (arg) {
        var source = arg.source, subscriber = arg.subscriber;
        return this.add(source.subscribe(subscriber));
    };
    SubscribeOnObservable.prototype._subscribe = function (subscriber) {
        var delay = this.delayTime;
        var source = this.source;
        var scheduler = this.scheduler;
        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
            source: source, subscriber: subscriber
        });
    };
    return SubscribeOnObservable;
}(Observable));

/** PURE_IMPORTS_START _observable_SubscribeOnObservable PURE_IMPORTS_END */
function subscribeOn(scheduler, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return function subscribeOnOperatorFunction(source) {
        return source.lift(new SubscribeOnOperator(scheduler, delay));
    };
}
var SubscribeOnOperator = /*@__PURE__*/ (function () {
    function SubscribeOnOperator(scheduler, delay) {
        this.scheduler = scheduler;
        this.delay = delay;
    }
    SubscribeOnOperator.prototype.call = function (subscriber, source) {
        return new SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
    };
    return SubscribeOnOperator;
}());

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */
function switchMap(project, resultSelector) {
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(switchMap(function (a, i) { return from(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) { return source.lift(new SwitchMapOperator(project)); };
}
var SwitchMapOperator = /*@__PURE__*/ (function () {
    function SwitchMapOperator(project) {
        this.project = project;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
    };
    return SwitchMapOperator;
}());
var SwitchMapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.index = 0;
        return _this;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
        var destination = this.destination;
        destination.add(innerSubscriber);
        this.innerSubscription = subscribeToResult(this, result, value, index, innerSubscriber);
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
        this.unsubscribe();
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var destination = this.destination;
        destination.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _switchMap,_util_identity PURE_IMPORTS_END */
function switchAll() {
    return switchMap(identity);
}

/** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */
function switchMapTo(innerObservable, resultSelector) {
    return resultSelector ? switchMap(function () { return innerObservable; }, resultSelector) : switchMap(function () { return innerObservable; });
}

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function takeUntil(notifier) {
    return function (source) { return source.lift(new TakeUntilOperator(notifier)); };
}
var TakeUntilOperator = /*@__PURE__*/ (function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
        var notifierSubscription = subscribeToResult(takeUntilSubscriber, this.notifier);
        if (notifierSubscription && !takeUntilSubscriber.seenValue) {
            takeUntilSubscriber.add(notifierSubscription);
            return source.subscribe(takeUntilSubscriber);
        }
        return takeUntilSubscriber;
    };
    return TakeUntilOperator;
}());
var TakeUntilSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.seenValue = false;
        return _this;
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.seenValue = true;
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
    };
    return TakeUntilSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function takeWhile(predicate, inclusive) {
    if (inclusive === void 0) {
        inclusive = false;
    }
    return function (source) {
        return source.lift(new TakeWhileOperator(predicate, inclusive));
    };
}
var TakeWhileOperator = /*@__PURE__*/ (function () {
    function TakeWhileOperator(predicate, inclusive) {
        this.predicate = predicate;
        this.inclusive = inclusive;
    }
    TakeWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
    };
    return TakeWhileOperator;
}());
var TakeWhileSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TakeWhileSubscriber, _super);
    function TakeWhileSubscriber(destination, predicate, inclusive) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.inclusive = inclusive;
        _this.index = 0;
        return _this;
    }
    TakeWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        var result;
        try {
            result = this.predicate(value, this.index++);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this.nextOrComplete(value, result);
    };
    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
            destination.next(value);
        }
        else {
            if (this.inclusive) {
                destination.next(value);
            }
            destination.complete();
        }
    };
    return TakeWhileSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
var defaultThrottleConfig = {
    leading: true,
    trailing: false
};
function throttle(durationSelector, config) {
    if (config === void 0) {
        config = defaultThrottleConfig;
    }
    return function (source) { return source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing)); };
}
var ThrottleOperator = /*@__PURE__*/ (function () {
    function ThrottleOperator(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
    };
    return ThrottleOperator;
}());
var ThrottleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ThrottleSubscriber, _super);
    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.durationSelector = durationSelector;
        _this._leading = _leading;
        _this._trailing = _trailing;
        _this._hasValue = false;
        return _this;
    }
    ThrottleSubscriber.prototype._next = function (value) {
        this._hasValue = true;
        this._sendValue = value;
        if (!this._throttled) {
            if (this._leading) {
                this.send();
            }
            else {
                this.throttle(value);
            }
        }
    };
    ThrottleSubscriber.prototype.send = function () {
        var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
        if (_hasValue) {
            this.destination.next(_sendValue);
            this.throttle(_sendValue);
        }
        this._hasValue = false;
        this._sendValue = null;
    };
    ThrottleSubscriber.prototype.throttle = function (value) {
        var duration = this.tryDurationSelector(value);
        if (!!duration) {
            this.add(this._throttled = subscribeToResult(this, duration));
        }
    };
    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
        try {
            return this.durationSelector(value);
        }
        catch (err) {
            this.destination.error(err);
            return null;
        }
    };
    ThrottleSubscriber.prototype.throttlingDone = function () {
        var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
        if (_throttled) {
            _throttled.unsubscribe();
        }
        this._throttled = null;
        if (_trailing) {
            this.send();
        }
    };
    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.throttlingDone();
    };
    ThrottleSubscriber.prototype.notifyComplete = function () {
        this.throttlingDone();
    };
    return ThrottleSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async,_throttle PURE_IMPORTS_END */
function throttleTime(duration, scheduler, config) {
    if (scheduler === void 0) {
        scheduler = async;
    }
    if (config === void 0) {
        config = defaultThrottleConfig;
    }
    return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };
}
var ThrottleTimeOperator = /*@__PURE__*/ (function () {
    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
    };
    return ThrottleTimeOperator;
}());
var ThrottleTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
        var _this = _super.call(this, destination) || this;
        _this.duration = duration;
        _this.scheduler = scheduler;
        _this.leading = leading;
        _this.trailing = trailing;
        _this._hasTrailingValue = false;
        _this._trailingValue = null;
        return _this;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
        else {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext$3, this.duration, { subscriber: this }));
            if (this.leading) {
                this.destination.next(value);
            }
        }
    };
    ThrottleTimeSubscriber.prototype._complete = function () {
        if (this._hasTrailingValue) {
            this.destination.next(this._trailingValue);
            this.destination.complete();
        }
        else {
            this.destination.complete();
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            if (this.trailing && this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
            }
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(Subscriber));
function dispatchNext$3(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}

/** PURE_IMPORTS_START _scheduler_async,_scan,_observable_defer,_map PURE_IMPORTS_END */
function timeInterval(scheduler) {
    if (scheduler === void 0) {
        scheduler = async;
    }
    return function (source) {
        return defer(function () {
            return source.pipe(scan(function (_a, value) {
                var current = _a.current;
                return ({ value: value, current: scheduler.now(), last: current });
            }, { current: scheduler.now(), value: undefined, last: undefined }), map(function (_a) {
                var current = _a.current, last = _a.last, value = _a.value;
                return new TimeInterval(value, current - last);
            }));
        });
    };
}
var TimeInterval = /*@__PURE__*/ (function () {
    function TimeInterval(value, interval) {
        this.value = value;
        this.interval = interval;
    }
    return TimeInterval;
}());

/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function timeoutWith(due, withObservable, scheduler) {
    if (scheduler === void 0) {
        scheduler = async;
    }
    return function (source) {
        var absoluteTimeout = isDate(due);
        var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
        return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
    };
}
var TimeoutWithOperator = /*@__PURE__*/ (function () {
    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
    }
    TimeoutWithOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
    };
    return TimeoutWithOperator;
}());
var TimeoutWithSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TimeoutWithSubscriber, _super);
    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.absoluteTimeout = absoluteTimeout;
        _this.waitFor = waitFor;
        _this.withObservable = withObservable;
        _this.scheduler = scheduler;
        _this.action = null;
        _this.scheduleTimeout();
        return _this;
    }
    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
        var withObservable = subscriber.withObservable;
        subscriber._unsubscribeAndRecycle();
        subscriber.add(subscribeToResult(subscriber, withObservable));
    };
    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutWithSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutWithSubscriber.prototype._unsubscribe = function () {
        this.action = null;
        this.scheduler = null;
        this.withObservable = null;
    };
    return TimeoutWithSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */
function timeout(due, scheduler) {
    if (scheduler === void 0) {
        scheduler = async;
    }
    return timeoutWith(due, throwError(new TimeoutError()), scheduler);
}

/** PURE_IMPORTS_START _scheduler_async,_map PURE_IMPORTS_END */
function timestamp(scheduler) {
    if (scheduler === void 0) {
        scheduler = async;
    }
    return map(function (value) { return new Timestamp(value, scheduler.now()); });
}
var Timestamp = /*@__PURE__*/ (function () {
    function Timestamp(value, timestamp) {
        this.value = value;
        this.timestamp = timestamp;
    }
    return Timestamp;
}());

/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */
function toArrayReducer(arr, item, index) {
    if (index === 0) {
        return [item];
    }
    arr.push(item);
    return arr;
}
function toArray() {
    return reduce(toArrayReducer, []);
}

/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function window$1(windowBoundaries) {
    return function windowOperatorFunction(source) {
        return source.lift(new WindowOperator(windowBoundaries));
    };
}
var WindowOperator = /*@__PURE__*/ (function () {
    function WindowOperator(windowBoundaries) {
        this.windowBoundaries = windowBoundaries;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        var windowSubscriber = new WindowSubscriber(subscriber);
        var sourceSubscription = source.subscribe(windowSubscriber);
        if (!sourceSubscription.closed) {
            windowSubscriber.add(subscribeToResult(windowSubscriber, this.windowBoundaries));
        }
        return sourceSubscription;
    };
    return WindowOperator;
}());
var WindowSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WindowSubscriber, _super);
    function WindowSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.window = new Subject();
        destination.next(_this.window);
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow();
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this._complete();
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
    };
    WindowSubscriber.prototype._unsubscribe = function () {
        this.window = null;
    };
    WindowSubscriber.prototype.openWindow = function () {
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var destination = this.destination;
        var newWindow = this.window = new Subject();
        destination.next(newWindow);
    };
    return WindowSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_Subject PURE_IMPORTS_END */
function windowCount(windowSize, startWindowEvery) {
    if (startWindowEvery === void 0) {
        startWindowEvery = 0;
    }
    return function windowCountOperatorFunction(source) {
        return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
    };
}
var WindowCountOperator = /*@__PURE__*/ (function () {
    function WindowCountOperator(windowSize, startWindowEvery) {
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
    }
    WindowCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
    };
    return WindowCountOperator;
}());
var WindowCountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WindowCountSubscriber, _super);
    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowSize = windowSize;
        _this.startWindowEvery = startWindowEvery;
        _this.windows = [new Subject()];
        _this.count = 0;
        destination.next(_this.windows[0]);
        return _this;
    }
    WindowCountSubscriber.prototype._next = function (value) {
        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
        var destination = this.destination;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len && !this.closed; i++) {
            windows[i].next(value);
        }
        var c = this.count - windowSize + 1;
        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
            windows.shift().complete();
        }
        if (++this.count % startWindowEvery === 0 && !this.closed) {
            var window_1 = new Subject();
            windows.push(window_1);
            destination.next(window_1);
        }
    };
    WindowCountSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().error(err);
            }
        }
        this.destination.error(err);
    };
    WindowCountSubscriber.prototype._complete = function () {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().complete();
            }
        }
        this.destination.complete();
    };
    WindowCountSubscriber.prototype._unsubscribe = function () {
        this.count = 0;
        this.windows = null;
    };
    return WindowCountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subject,_scheduler_async,_Subscriber,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */
function windowTime(windowTimeSpan) {
    var scheduler = async;
    var windowCreationInterval = null;
    var maxWindowSize = Number.POSITIVE_INFINITY;
    if (isScheduler(arguments[3])) {
        scheduler = arguments[3];
    }
    if (isScheduler(arguments[2])) {
        scheduler = arguments[2];
    }
    else if (isNumeric(arguments[2])) {
        maxWindowSize = arguments[2];
    }
    if (isScheduler(arguments[1])) {
        scheduler = arguments[1];
    }
    else if (isNumeric(arguments[1])) {
        windowCreationInterval = arguments[1];
    }
    return function windowTimeOperatorFunction(source) {
        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
    };
}
var WindowTimeOperator = /*@__PURE__*/ (function () {
    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
    }
    WindowTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
    };
    return WindowTimeOperator;
}());
var CountedSubject = /*@__PURE__*/ (function (_super) {
    __extends(CountedSubject, _super);
    function CountedSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._numberOfNextedValues = 0;
        return _this;
    }
    CountedSubject.prototype.next = function (value) {
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value);
    };
    Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
        get: function () {
            return this._numberOfNextedValues;
        },
        enumerable: true,
        configurable: true
    });
    return CountedSubject;
}(Subject));
var WindowTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WindowTimeSubscriber, _super);
    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowTimeSpan = windowTimeSpan;
        _this.windowCreationInterval = windowCreationInterval;
        _this.maxWindowSize = maxWindowSize;
        _this.scheduler = scheduler;
        _this.windows = [];
        var window = _this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
            var closeState = { subscriber: _this, window: window, context: null };
            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        }
        else {
            var timeSpanOnlyState = { subscriber: _this, window: window, windowTimeSpan: windowTimeSpan };
            _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
        return _this;
    }
    WindowTimeSubscriber.prototype._next = function (value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len; i++) {
            var window_1 = windows[i];
            if (!window_1.closed) {
                window_1.next(value);
                if (window_1.numberOfNextedValues >= this.maxWindowSize) {
                    this.closeWindow(window_1);
                }
            }
        }
    };
    WindowTimeSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().error(err);
        }
        this.destination.error(err);
    };
    WindowTimeSubscriber.prototype._complete = function () {
        var windows = this.windows;
        while (windows.length > 0) {
            var window_2 = windows.shift();
            if (!window_2.closed) {
                window_2.complete();
            }
        }
        this.destination.complete();
    };
    WindowTimeSubscriber.prototype.openWindow = function () {
        var window = new CountedSubject();
        this.windows.push(window);
        var destination = this.destination;
        destination.next(window);
        return window;
    };
    WindowTimeSubscriber.prototype.closeWindow = function (window) {
        window.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
    };
    return WindowTimeSubscriber;
}(Subscriber));
function dispatchWindowTimeSpanOnly(state) {
    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
    if (window) {
        subscriber.closeWindow(window);
    }
    state.window = subscriber.openWindow();
    this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
    var window = subscriber.openWindow();
    var action = this;
    var context = { action: action, subscription: null };
    var timeSpanState = { subscriber: subscriber, window: window, context: context };
    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
    action.add(context.subscription);
    action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(state) {
    var subscriber = state.subscriber, window = state.window, context = state.context;
    if (context && context.action && context.subscription) {
        context.action.remove(context.subscription);
    }
    subscriber.closeWindow(window);
}

/** PURE_IMPORTS_START tslib,_Subject,_Subscription,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function windowToggle(openings, closingSelector) {
    return function (source) { return source.lift(new WindowToggleOperator(openings, closingSelector)); };
}
var WindowToggleOperator = /*@__PURE__*/ (function () {
    function WindowToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    WindowToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return WindowToggleOperator;
}());
var WindowToggleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WindowToggleSubscriber, _super);
    function WindowToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings));
        return _this;
    }
    WindowToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        if (contexts) {
            var len = contexts.length;
            for (var i = 0; i < len; i++) {
                contexts[i].window.next(value);
            }
        }
    };
    WindowToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_1 = contexts[index];
                context_1.window.error(err);
                context_1.subscription.unsubscribe();
            }
        }
        _super.prototype._error.call(this, err);
    };
    WindowToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_2 = contexts[index];
                context_2.window.complete();
                context_2.subscription.unsubscribe();
            }
        }
        _super.prototype._complete.call(this);
    };
    WindowToggleSubscriber.prototype._unsubscribe = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_3 = contexts[index];
                context_3.window.unsubscribe();
                context_3.subscription.unsubscribe();
            }
        }
    };
    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
            var closingNotifier = void 0;
            try {
                var closingSelector = this.closingSelector;
                closingNotifier = closingSelector(innerValue);
            }
            catch (e) {
                return this.error(e);
            }
            var window_1 = new Subject();
            var subscription = new Subscription();
            var context_4 = { window: window_1, subscription: subscription };
            this.contexts.push(context_4);
            var innerSubscription = subscribeToResult(this, closingNotifier, context_4);
            if (innerSubscription.closed) {
                this.closeWindow(this.contexts.length - 1);
            }
            else {
                innerSubscription.context = context_4;
                subscription.add(innerSubscription);
            }
            this.destination.next(window_1);
        }
        else {
            this.closeWindow(this.contexts.indexOf(outerValue));
        }
    };
    WindowToggleSubscriber.prototype.notifyError = function (err) {
        this.error(err);
    };
    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
        if (inner !== this.openSubscription) {
            this.closeWindow(this.contexts.indexOf(inner.context));
        }
    };
    WindowToggleSubscriber.prototype.closeWindow = function (index) {
        if (index === -1) {
            return;
        }
        var contexts = this.contexts;
        var context = contexts[index];
        var window = context.window, subscription = context.subscription;
        contexts.splice(index, 1);
        window.complete();
        subscription.unsubscribe();
    };
    return WindowToggleSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function windowWhen(closingSelector) {
    return function windowWhenOperatorFunction(source) {
        return source.lift(new WindowOperator$1(closingSelector));
    };
}
var WindowOperator$1 = /*@__PURE__*/ (function () {
    function WindowOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowSubscriber$1(subscriber, this.closingSelector));
    };
    return WindowOperator;
}());
var WindowSubscriber$1 = /*@__PURE__*/ (function (_super) {
    __extends(WindowSubscriber, _super);
    function WindowSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.closingSelector = closingSelector;
        _this.openWindow();
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
        if (this.closingNotification) {
            this.closingNotification.unsubscribe();
        }
    };
    WindowSubscriber.prototype.openWindow = function (innerSub) {
        if (innerSub === void 0) {
            innerSub = null;
        }
        if (innerSub) {
            this.remove(innerSub);
            innerSub.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var window = this.window = new Subject();
        this.destination.next(window);
        var closingNotifier;
        try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector();
        }
        catch (e) {
            this.destination.error(e);
            this.window.error(e);
            return;
        }
        this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
    };
    return WindowSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return function (source) {
        var project;
        if (typeof args[args.length - 1] === 'function') {
            project = args.pop();
        }
        var observables = args;
        return source.lift(new WithLatestFromOperator(observables, project));
    };
}
var WithLatestFromOperator = /*@__PURE__*/ (function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}());
var WithLatestFromSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        var _this = _super.call(this, destination) || this;
        _this.observables = observables;
        _this.project = project;
        _this.toRespond = [];
        var len = observables.length;
        _this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            _this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            _this.add(subscribeToResult(_this, observable, observable, i));
        }
        return _this;
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            }
            else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */
function zip$1() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function zipOperatorFunction(source) {
        return source.lift.call(zip.apply(void 0, [source].concat(observables)));
    };
}

/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */
function zipAll(project) {
    return function (source) { return source.lift(new ZipOperator(project)); };
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */

var operators = /*#__PURE__*/Object.freeze({
	audit: audit,
	auditTime: auditTime,
	buffer: buffer,
	bufferCount: bufferCount,
	bufferTime: bufferTime,
	bufferToggle: bufferToggle,
	bufferWhen: bufferWhen,
	catchError: catchError,
	combineAll: combineAll,
	combineLatest: combineLatest$1,
	concat: concat$1,
	concatAll: concatAll,
	concatMap: concatMap,
	concatMapTo: concatMapTo,
	count: count,
	debounce: debounce,
	debounceTime: debounceTime,
	defaultIfEmpty: defaultIfEmpty,
	delay: delay,
	delayWhen: delayWhen,
	dematerialize: dematerialize,
	distinct: distinct,
	distinctUntilChanged: distinctUntilChanged,
	distinctUntilKeyChanged: distinctUntilKeyChanged,
	elementAt: elementAt,
	endWith: endWith,
	every: every,
	exhaust: exhaust,
	exhaustMap: exhaustMap,
	expand: expand,
	filter: filter,
	finalize: finalize,
	find: find,
	findIndex: findIndex,
	first: first,
	groupBy: groupBy,
	ignoreElements: ignoreElements,
	isEmpty: isEmpty,
	last: last,
	map: map,
	mapTo: mapTo,
	materialize: materialize,
	max: max,
	merge: merge$1,
	mergeAll: mergeAll,
	mergeMap: mergeMap,
	flatMap: mergeMap,
	mergeMapTo: mergeMapTo,
	mergeScan: mergeScan,
	min: min,
	multicast: multicast,
	observeOn: observeOn,
	onErrorResumeNext: onErrorResumeNext$1,
	pairwise: pairwise,
	partition: partition,
	pluck: pluck,
	publish: publish,
	publishBehavior: publishBehavior,
	publishLast: publishLast,
	publishReplay: publishReplay,
	race: race$1,
	reduce: reduce,
	repeat: repeat,
	repeatWhen: repeatWhen,
	retry: retry,
	retryWhen: retryWhen,
	refCount: refCount,
	sample: sample,
	sampleTime: sampleTime,
	scan: scan,
	sequenceEqual: sequenceEqual,
	share: share,
	shareReplay: shareReplay,
	single: single,
	skip: skip,
	skipLast: skipLast,
	skipUntil: skipUntil,
	skipWhile: skipWhile,
	startWith: startWith,
	subscribeOn: subscribeOn,
	switchAll: switchAll,
	switchMap: switchMap,
	switchMapTo: switchMapTo,
	take: take,
	takeLast: takeLast,
	takeUntil: takeUntil,
	takeWhile: takeWhile,
	tap: tap,
	throttle: throttle,
	throttleTime: throttleTime,
	throwIfEmpty: throwIfEmpty,
	timeInterval: timeInterval,
	timeout: timeout,
	timeoutWith: timeoutWith,
	timestamp: timestamp,
	toArray: toArray,
	window: window$1,
	windowCount: windowCount,
	windowTime: windowTime,
	windowToggle: windowToggle,
	windowWhen: windowWhen,
	withLatestFrom: withLatestFrom,
	zip: zip$1,
	zipAll: zipAll
});

var ObservableList_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * Creates an observable list (or detail) from a promise-callback.
 *
 * @deprecated This class will be removed soon in favor of decoupling
 * this library from rxjs. Use [[Realtime]] for realtime connection and
 * rxjs `defer()` or `from()` to composite an observable on your own.
 */
var ObservableList = /** @class */ (function () {
    /**
     * Creates a observable list with optional paging and realtime configuration.
     *
     * @param {Promise<IResultBase<TData>>} request List (or detail) from a promise-callback
     * @param {any} realtime$ Observable realtime object (optional)
     * @param {IObservableOptions} options The observable configuration
     */
    function ObservableList(request, realtime$, options, realtimeFilter) {
        if (options === void 0) { options = {}; }
        if (realtimeFilter === void 0) { realtimeFilter = {}; }
        this.realtimeFilter = realtimeFilter;
        /**
         * The inner source for the list observable
         */
        this.source = new rxjs_1.Observable();
        this.seed = { mapping: {}, list: [] };
        this.pagingDriver = new rxjs_1.Subject();
        this.specialRealtimeFilter = {
            source: function (o, val) { return o.source.id === val; },
            fragmentType: function (o, val) { return !!o[val]; },
            // the following are not supported or not valid filters
            orderBy: function (o, val) { return true; },
            query: function (o, val) { return true; },
            q: function (o, val) { return true; },
            pageSize: function (o, val) { return true; },
            withTotalPages: function (o, val) { return true; },
            currentPage: function (o, val) { return true; }
        };
        this.defaultObservableOptions = {
            hot: true,
            realtime: false,
            pagingStrategy: PagingStrategy.PROGRESSIVE,
            realtimeAction: RealtimeAction.FULL,
            pagingDelay: 0
        };
        this.options = Object.assign({}, this.defaultObservableOptions, options);
        // cold / paging
        this.source = this.compose(request, this.options.pagingStrategy, this.options.pagingDelay);
        // realtime
        if (this.options.realtime) {
            this.source = this.composeRealtime(realtime$);
        }
        // hot
        if (this.options.hot) {
            this.source = this.composeHot();
        }
    }
    /**
     * Load more data from this service (next page).
     */
    ObservableList.prototype.more = function () {
        if (this.options.pagingStrategy !== PagingStrategy.PROGRESSIVE) {
            throw new Error('Only PagingStrategy.PROGRESSIVE does support load more button.');
        }
        var paging = this.pagingDriver.paging;
        var fetching = !paging || paging.fetching;
        fetching = this.fetchNextPage(fetching, paging);
        return fetching;
    };
    ObservableList.prototype.composeDetail = function () {
        return this.source.pipe(operators.map(function (list) { return list[0]; }));
    };
    /**
     * Creates a observable with the given paging strategy.
     *
     * @param {Promise<IResultBase<TData>>} request List (or detail) from a promise-callback
     * @param {PagingStrategy} pagingStrategy The paging strategy to use.
     * @param {number} pagingDelay If all pages are loaded, the paging is delayed by x ms.
     */
    ObservableList.prototype.compose = function (request, pagingStrategy, pagingDelay) {
        if (pagingStrategy === void 0) { pagingStrategy = PagingStrategy.PROGRESSIVE; }
        if (pagingDelay === void 0) { pagingDelay = 0; }
        var firstPage$ = rxjs_1.defer(function () { return rxjs_1.from(request()); });
        return pagingStrategy === PagingStrategy.PROGRESSIVE
            ? this.composeProgressive(firstPage$)
            : this.composeAllOrNone(firstPage$, pagingStrategy, pagingDelay);
    };
    ObservableList.prototype.composeRealtime = function (realtime$, action) {
        var _this = this;
        if (action === void 0) { action = RealtimeAction.FULL; }
        if (!realtime$) {
            // tslint:disable-next-line:max-line-length
            throw new Error('Cannot compose realtime without setting realtime observable in service constructor.');
        }
        realtime$ = realtime$.pipe(operators.filter(function (result) { return _this.filterAction(result, action); }), operators.filter(function (result) { return _this.filterRealtime(result); }), operators.map(this.mapData));
        return this.source.pipe(operators.merge(realtime$), operators.scan(this.accumulator, this.seed), operators.map(function (_a) {
            var list = _a.list;
            return list;
        }));
    };
    ObservableList.prototype.composeHot = function () {
        return this.source.pipe(operators.publishReplay(1), operators.refCount());
    };
    ObservableList.prototype.fetchNextPage = function (fetching, paging) {
        if (!fetching && !paging.done) {
            var isLast = paging.currentPage >= paging.totalPages;
            this.pagingDriver.next(isLast ? rxjs_1.empty() : paging.next());
            paging.done = isLast;
            fetching = paging.fetching = !isLast;
        }
        return fetching;
    };
    ObservableList.prototype.composeAllOrNone = function (firstPage$, pagingStrategy, pagingDelay) {
        var _this = this;
        return firstPage$.pipe(operators.expand(function (_a) {
            var paging = _a.paging;
            return _this.shouldUsePaging(paging, pagingStrategy)
                ? rxjs_1.from(paging.next()).pipe(operators.delay(pagingDelay))
                : rxjs_1.empty();
        }), operators.map(this.mapData));
    };
    ObservableList.prototype.composeProgressive = function (firstPage$) {
        var _this = this;
        return this.pagingDriver.pipe(operators.mergeMap(function (r) { return r; }), operators.merge(firstPage$), operators.tap(function (_a) {
            var paging = _a.paging;
            if (paging) {
                _this.pagingDriver.paging = paging;
            }
        }), operators.map(this.mapData));
    };
    ObservableList.prototype.shouldUsePaging = function (paging, pagingStrategy) {
        if (pagingStrategy === PagingStrategy.ALL && !paging.totalPages) {
            return !!paging.nextPage;
        }
        return (paging && pagingStrategy === PagingStrategy.ALL && paging.currentPage < paging.totalPages);
    };
    ObservableList.prototype.accumulator = function (acc, rtItemOrList) {
        var mapping = acc.mapping, list = acc.list;
        // if deleted, realtime just returns an string-id
        if (typeof rtItemOrList === 'string') {
            var index = list.indexOf(mapping[rtItemOrList]);
            if (index > -1) {
                list.splice(index, 1);
                mapping[rtItemOrList] = undefined;
            }
            return acc;
        }
        var items = Array.isArray(rtItemOrList) ? rtItemOrList : [rtItemOrList];
        items.forEach(function (item, index) {
            if (mapping[item.id]) {
                mapping[item.id] = Object.assign(mapping[item.id], item);
            }
            else {
                mapping[item.id] = item;
                list.push(item);
            }
        });
        return acc;
    };
    ObservableList.prototype.filterAction = function (result, action) {
        return action === RealtimeAction.FULL || action === result.realtimeAction;
    };
    ObservableList.prototype.filterRealtime = function (result) {
        if (this.options.realtimeFilter) {
            return this.options.realtimeFilter(result);
        }
        else if (result.realtimeAction === RealtimeAction.CREATE) {
            var data = result.data;
            var valid = true;
            // tslint:disable-next-line:forin
            for (var key in this.realtimeFilter) {
                var specialFn = this.specialRealtimeFilter[key];
                valid = specialFn
                    ? this.specialRealtimeFilter[key](data, this.realtimeFilter[key])
                    : data[key] === this.realtimeFilter[key];
                if (!valid) {
                    break;
                }
            }
            return valid;
        }
        return true;
    };
    ObservableList.prototype.mapData = function (result) {
        return result.data;
    };
    return ObservableList;
}());
exports.ObservableList = ObservableList;
var RealtimeAction;
(function (RealtimeAction) {
    RealtimeAction["UPDATE"] = "UPDATE";
    RealtimeAction["DELETE"] = "DELETE";
    RealtimeAction["CREATE"] = "CREATE";
    RealtimeAction["FULL"] = "FULL";
})(RealtimeAction = exports.RealtimeAction || (exports.RealtimeAction = {}));
var PagingStrategy;
(function (PagingStrategy) {
    PagingStrategy["ALL"] = "ALL";
    PagingStrategy["PROGRESSIVE"] = "PROGRESSIVE";
    PagingStrategy["NONE"] = "NONE";
})(PagingStrategy = exports.PagingStrategy || (exports.PagingStrategy = {}));

});

unwrapExports(ObservableList_1);
var ObservableList_2 = ObservableList_1.ObservableList;
var ObservableList_3 = ObservableList_1.RealtimeAction;
var ObservableList_4 = ObservableList_1.PagingStrategy;

var Service_1 = createCommonjsModule(function (module, exports) {
var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });


var Service = /** @class */ (function () {
    function Service(client, realtime) {
        var _this = this;
        this.client = client;
        this.realtime = realtime;
        this.cache = new Map();
        var methodsToHide = ['list', 'create', 'update', 'detail', 'delete', 'detail$', 'list$'];
        var prototype = Object.getPrototypeOf(this);
        methodsToHide.forEach(function (method) {
            if (!prototype.hasOwnProperty(method)) {
                Object.defineProperty(_this, method, {
                    get: function () {
                        return undefined;
                    }
                });
            }
        });
    }
    Service.prototype.list = function (filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var headers, url, res, json, data, paging;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        headers = { accept: 'application/json' };
                        url = this.listUrl;
                        return [4 /*yield*/, this.fetch(url, this.changeFetchOptions({ headers: headers, params: filter }, url))];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        json = _a.sent();
                        data = this.propertyName ? json[this.propertyName] : json;
                        paging = this.getPaging(json, filter);
                        return [2 /*return*/, { res: res, data: data, paging: paging }];
                }
            });
        });
    };
    Service.prototype.list$ = function (filter, options) {
        var _this = this;
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        var source = filter.source;
        return new ObservableList_1.ObservableList(function () { return _this.list(filter); }, this.getRealtime(source), options, filter).source;
    };
    Service.prototype.detail = function (entityOrId, filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var headers, url, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        headers = { accept: 'application/json' };
                        url = this.getDetailUrl(entityOrId);
                        return [4 /*yield*/, this.fetch(url, this.changeFetchOptions({ headers: headers, params: __assign({}, filter) }, url))];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    Service.prototype.detail$ = function (entityOrId, options) {
        var _this = this;
        if (options === void 0) { options = { pagingStrategy: ObservableList_1.PagingStrategy.NONE }; }
        var obsList$ = new ObservableList_1.ObservableList(function () { return _this.detail(entityOrId); }, this.getRealtime(entityOrId), options);
        return obsList$.composeDetail().source;
    };
    Service.prototype.create = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            var url, method, body, headers, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.listUrl;
                        method = 'POST';
                        body = JSON.stringify(this.onBeforeCreate(entity));
                        headers = { 'content-type': 'application/json', accept: 'application/json' };
                        return [4 /*yield*/, this.fetch(url, this.changeFetchOptions({ method: method, body: body, headers: headers }, url))];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    Service.prototype.update = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            var url, method, body, headers, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.getDetailUrl(entity);
                        method = 'PUT';
                        body = JSON.stringify(this.onBeforeUpdate(entity));
                        headers = { 'content-type': 'application/json', accept: 'application/json' };
                        return [4 /*yield*/, this.fetch(url, this.changeFetchOptions({ method: method, body: body, headers: headers }, url))];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    Service.prototype.delete = function (entityOrId, params) {
        return __awaiter(this, void 0, void 0, function () {
            var method, url, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        method = 'DELETE';
                        url = this.getDetailUrl(entityOrId);
                        return [4 /*yield*/, this.fetch(url, this.changeFetchOptions({ method: method, params: params }, url))];
                    case 1:
                        res = _a.sent();
                        return [2 /*return*/, { res: res, data: null }];
                }
            });
        });
    };
    Service.prototype.onBeforeCreate = function (obj) {
        delete obj.id;
        return obj;
    };
    Service.prototype.onBeforeUpdate = function (objWithId) {
        return objWithId;
    };
    Service.prototype.changeFetchOptions = function (options, url) {
        return options;
    };
    Service.prototype.getUrl = function (url) {
        if (url === void 0) { url = ''; }
        var baseUrl = this.baseUrl.replace(/\/+$/, '');
        var partialUrl = url.replace(/^\/+/, '');
        return baseUrl + "/" + partialUrl;
    };
    Service.prototype.getDetailUrl = function (entityOrId) {
        var id;
        if (typeof entityOrId === 'object' && entityOrId.id) {
            id = entityOrId.id;
        }
        else {
            id = entityOrId;
        }
        return this.listUrl + "/" + id;
    };
    Service.prototype.fetch = function (url, init) {
        return __awaiter(this, void 0, void 0, function () {
            var fullUrl, res, data, ex_1, ex_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        fullUrl = this.getUrl(url);
                        return [4 /*yield*/, this.client.fetch(fullUrl, init)];
                    case 1:
                        res = _a.sent();
                        if (!(res.status >= 400)) return [3 /*break*/, 10];
                        data = null;
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 9]);
                        return [4 /*yield*/, res.json()];
                    case 3:
                        data = _a.sent();
                        return [3 /*break*/, 9];
                    case 4:
                        ex_1 = _a.sent();
                        _a.label = 5;
                    case 5:
                        _a.trys.push([5, 7, , 8]);
                        return [4 /*yield*/, res.text()];
                    case 6:
                        data = _a.sent();
                        return [3 /*break*/, 8];
                    case 7:
                        ex_2 = _a.sent();
                        return [3 /*break*/, 8];
                    case 8: return [3 /*break*/, 9];
                    case 9: throw { res: res, data: data };
                    case 10: return [2 /*return*/, res];
                }
            });
        });
    };
    Service.prototype.mimeType = function (type) {
        return "application/vnd.com.nsn.cumulocity." + type + "+json";
    };
    Service.prototype.getIdString = function (reference) {
        var id;
        if (typeof reference === 'object') {
            id = reference.id;
        }
        else {
            id = reference;
        }
        return String(id);
    };
    Service.prototype.getChannel = function (entityOrId) {
        return entityOrId ? this.channel.replace('*', this.getIdString(entityOrId)) : this.channel;
    };
    Service.prototype.getRealtime = function (entityOrId) {
        if (this.realtime) {
            return this.realtime.observable(this.getChannel(entityOrId));
        }
    };
    Service.prototype.getPaging = function (json, filter) {
        if (json.statistics) {
            var statistics = __assign({}, json.statistics, { nextPage: this.getCurrentPageFromLink(json.next), prevPage: this.getCurrentPageFromLink(json.prev) });
            return new Paging_1.Paging(this, statistics, filter);
        }
        return null;
    };
    Service.prototype.getCurrentPageFromLink = function (link) {
        if (link === void 0) { link = ''; }
        var matches = link.match(/currentPage=(-{0,1}\d+)/);
        return matches && parseInt(matches[1], 10);
    };
    return Service;
}());
exports.Service = Service;

});

unwrapExports(Service_1);
var Service_2 = Service_1.Service;

var FetchClient_1 = createCommonjsModule(function (module, exports) {
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var cross_fetch_1 = __importDefault(browserPonyfill);
var auths = new WeakMap(); // tslint:disable-line
var FetchClient = /** @class */ (function () {
    function FetchClient(authOrBaseUrl, baseUrl) {
        this.baseUrl = baseUrl;
        this.tenant = '';
        this.defaultHeaders = {};
        if (typeof authOrBaseUrl === 'string') {
            baseUrl = authOrBaseUrl;
        }
        else {
            this.setAuth(authOrBaseUrl);
        }
        this.baseUrl = this.resolveServerUrl(baseUrl);
    }
    FetchClient.prototype.setAuth = function (auth) {
        auths.set(this, auth);
    };
    FetchClient.prototype.fetch = function (url, init) {
        return __awaiter(this, void 0, void 0, function () {
            var fetchFn, fullUrl, options;
            return __generator(this, function (_a) {
                fetchFn = cross_fetch_1.default;
                try {
                    fetchFn = window.fetch || fetchFn;
                }
                catch (e) { /* do nothing */ }
                fullUrl = this.getUrl(url, init);
                options = this.getFetchOptions(init);
                return [2 /*return*/, fetchFn(fullUrl, options)];
            });
        });
    };
    FetchClient.prototype.getUrl = function (url, options) {
        if (url === void 0) { url = ''; }
        var params = options && options.params;
        var paramPart = '';
        if (params && Object.keys(params).length) {
            paramPart = Object.keys(params)
                .map(function (k) {
                var vals = params[k];
                var encodedKey = encodeURIComponent(k);
                if (!Array.isArray(vals)) {
                    vals = [vals];
                }
                return vals.map(function (v) { return encodedKey + "=" + encodeURIComponent(v); }).join('&');
            })
                .join('&');
            paramPart = "?" + paramPart;
        }
        var baseUrl = this.baseUrl.replace(/\/+$/, '').replace(/^\/+/, '');
        var partialUrl = url.replace(/\/+$/, '').replace(/^\/+/, '');
        return baseUrl + "/" + partialUrl + paramPart;
    };
    FetchClient.prototype.getFetchOptions = function (options) {
        if (options === void 0) { options = {}; }
        var auth = auths.get(this);
        options.headers = Object.assign({}, this.defaultHeaders, options.headers, { UseXBasic: true });
        delete options.params;
        options = auth ? auth.getFetchOptions(options) : options;
        return options;
    };
    FetchClient.prototype.getCometdHandshake = function (config) {
        if (config === void 0) { config = {}; }
        var auth = auths.get(this);
        return auth ? auth.getCometdHandshake(config) : config;
    };
    FetchClient.prototype.resolveServerUrl = function (baseUrl) {
        if (baseUrl === void 0) { baseUrl = ''; }
        if (baseUrl && baseUrl.startsWith('http')) {
            return baseUrl.replace(/\/+$/, '');
        }
        try {
            var location_1 = window.location;
            return location_1.protocol + "//" + location_1.host + "/" + baseUrl.replace(/\/+$/, '');
        }
        catch (ex) {
            throw Error('Your environment does not support relative URLs. Please provide a base URL.');
        }
    };
    return FetchClient;
}());
exports.FetchClient = FetchClient;

});

unwrapExports(FetchClient_1);
var FetchClient_2 = FetchClient_1.FetchClient;

var error = function (message) {
  function E() {
    this.message = message;
  }

  E.prototype = new Error();
  E.prototype.name = 'InvalidCharacterError';
  E.prototype.code = 5;
  return E;
};
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

var E = error('The string to be encoded contains characters out of range');
var _btoa = typeof btoa !== 'undefined'
/* istanbul ignore next */
? function (input) {
  return btoa(input);
} : function (input) {
  var str = String(input);
  var output = '';

  for ( // initialize result and counter
  var block, charCode, idx = 0, map = chars; // if the next str index does not exist:
  //   change the mapping table to "="
  //   check if d has no fractional digits
  str.charAt(idx | 0) || (map = '=', idx % 1); // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
  output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
    charCode = str.charCodeAt(idx += 3 / 4);

    if (charCode > 0xFF) {
      throw new E();
    }

    block = block << 8 | charCode;
  }

  return output;
};

var utf8 = function (input) {
  return encodeURIComponent(input).replace(/%([0-9A-F]{2})/g, function (match, p1) {
    return String.fromCharCode('0x' + p1);
  });
};

var btoa$1 = (function (input) {
  return _btoa(utf8(input));
});

var btoau = (function (input) {
  return btoa$1(input).replace(/\+/g, '-').replace(/\//g, '_');
});

var E$1 = error('The string to be decoded is not correctly encoded');
var _atob = typeof atob !== 'undefined'
/* istanbul ignore next */
? function (input) {
  return atob(input);
} : function (input) {
  var str = String(input).replace(/[=]+$/, '');

  if (str.length % 4 == 1) {
    throw new E$1();
  }

  var output = '';

  for ( // initialize result and counters
  var bc = 0, bs, buffer, idx = 0; // get next character
  buffer = str.charAt(idx++); // character found in table? initialize bit storage and add its ascii value;
  ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {
    // try to find character in table (0-63, not found => -1)
    buffer = chars.indexOf(buffer);
  }

  return output;
};

var utf16 = function (input) {
  return decodeURIComponent(input.split('').map(function (c) {
    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
  }).join(''));
};

var atob$1 = (function (input) {
  return utf16(_atob(input));
});

var atobu = (function (input) {
  return atob$1(input.replace(/-/g, '+').replace(/_/g, '/'));
});



var b2a_1 = /*#__PURE__*/Object.freeze({
	btoa: btoa$1,
	btoau: btoau,
	atob: atob$1,
	atobu: atobu
});

var BasicAuth_1 = createCommonjsModule(function (module, exports) {
var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });

// this is var and not const to please typedoc https://github.com/TypeStrong/typedoc/issues/691
var secrets = new WeakMap(); // tslint:disable-line
/**
 * Allows to use Basic-Auth for Authorization to the
 * Cumulocity API.
 */
var BasicAuth = /** @class */ (function () {
    /**
     * Authenticates the given user against the given tenant.
     * @param name
     * @param password
     * @param tenant
     */
    function BasicAuth(credentials) {
        this.updateCredentials(credentials);
    }
    BasicAuth.prototype.updateCredentials = function (_a) {
        var _b = _a === void 0 ? {} : _a, tenant = _b.tenant, user = _b.user, password = _b.password, token = _b.token, tfa = _b.tfa;
        var secret = secrets.get(this) || {};
        if (user && tenant) {
            user = tenant + "/" + user;
        }
        user = user || this.user;
        password = password || secret.password;
        if (!token && user && password) {
            token = b2a_1.btoa(user + ":" + password);
        }
        if (user) {
            this.user = user;
        }
        token = token || secret.token;
        tfa = tfa || secret.tfa;
        secrets.set(this, { tfa: tfa, token: token, password: password });
        return token;
    };
    BasicAuth.prototype.getFetchOptions = function (options) {
        var secret = secrets.get(this);
        var token = secret.token, tfa = secret.tfa;
        var xsrfToken = this.getCookieValue('XSRF-TOKEN');
        var headers = __assign({ Authorization: "Basic " + (token || '') }, (xsrfToken ? { 'X-XSRF-TOKEN': xsrfToken } : undefined));
        if (tfa) {
            headers.tfatoken = tfa;
        }
        options.headers = Object.assign(headers, options.headers);
        return options;
    };
    BasicAuth.prototype.getCometdHandshake = function (config) {
        if (config === void 0) { config = {}; }
        var secret = secrets.get(this);
        var token = secret.token, tfa = secret.tfa;
        var KEY = 'com.cumulocity.authn';
        var ext = config.ext = config.ext || {};
        var auth = ext[KEY] = Object.assign(ext[KEY] || {}, { token: token, tfa: tfa });
        return config;
    };
    BasicAuth.prototype.logout = function () {
        delete this.user;
        secrets.set(this, {});
    };
    BasicAuth.prototype.getCookieValue = function (name) {
        try {
            var value = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)');
            return value ? value.pop() : undefined;
        }
        catch (ex) {
            return undefined;
        }
    };
    return BasicAuth;
}());
exports.BasicAuth = BasicAuth;

});

unwrapExports(BasicAuth_1);
var BasicAuth_2 = BasicAuth_1.BasicAuth;

var CookieAuth_1 = createCommonjsModule(function (module, exports) {
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Allows to use Cookies for Authorization to the
 * Cumulocity API.
 */
var CookieAuth = /** @class */ (function () {
    function CookieAuth() {
        this.logoutUrl = 'user/logout';
    }
    CookieAuth.prototype.updateCredentials = function (_a) {
        var user = (_a === void 0 ? {} : _a).user;
        this.user = user;
        return undefined;
    };
    CookieAuth.prototype.getFetchOptions = function (options) {
        var xsrfToken = this.getCookieValue('XSRF-TOKEN');
        var headers = { 'X-XSRF-TOKEN': xsrfToken };
        options.headers = Object.assign(headers, options.headers);
        return options;
    };
    CookieAuth.prototype.getCometdHandshake = function (config) {
        if (config === void 0) { config = {}; }
        var KEY = 'com.cumulocity.authn';
        var xsrfToken = this.getCookieValue('XSRF-TOKEN');
        var ext = config.ext = config.ext || {};
        ext[KEY] = Object.assign(ext[KEY] || {}, { xsrfToken: xsrfToken });
        return config;
    };
    CookieAuth.prototype.logout = function () {
        return __awaiter(this, void 0, void 0, function () {
            var client, method, body, headers;
            return __generator(this, function (_a) {
                if (this.user) {
                    delete this.user;
                }
                client = new FetchClient_1.FetchClient();
                client.setAuth(this);
                method = 'POST';
                body = JSON.stringify({});
                headers = { 'content-type': 'application/json', accept: 'application/json' };
                return [2 /*return*/, client.fetch(this.logoutUrl, { headers: headers, body: body, method: method })];
            });
        });
    };
    CookieAuth.prototype.getCookieValue = function (name) {
        var value = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)');
        return value ? value.pop() : '';
    };
    return CookieAuth;
}());
exports.CookieAuth = CookieAuth;

});

unwrapExports(CookieAuth_1);
var CookieAuth_2 = CookieAuth_1.CookieAuth;

var gettext = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/** Identity function used for marking strings for translation */
exports.gettext = function (t) { return t; };

});

unwrapExports(gettext);
var gettext_1 = gettext.gettext;

var Severity_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Severity can be one of the following states.
 * It is used in [[AlarmService]] for example.
 */
var Severity;
(function (Severity) {
    Severity[Severity["CRITICAL"] = gettext.gettext('CRITICAL')] = "CRITICAL";
    Severity[Severity["MAJOR"] = gettext.gettext('MAJOR')] = "MAJOR";
    Severity[Severity["MINOR"] = gettext.gettext('MINOR')] = "MINOR";
    Severity[Severity["WARNING"] = gettext.gettext('WARNING')] = "WARNING";
})(Severity = exports.Severity || (exports.Severity = {}));

});

unwrapExports(Severity_1);
var Severity_2 = Severity_1.Severity;

var QueriesUtil_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var QueriesUtil = /** @class */ (function () {
    function QueriesUtil() {
        var _this = this;
        this.operatorFns = {
            __not: function (operand) {
                return "not(" + _this.buildQueryFilter(operand, null) + ")";
            },
            __and: function (operand) {
                return _this.buildQueryFilter(operand, null, 'and');
            },
            __or: function (operand) {
                return _this.buildQueryFilter(operand, null, 'or');
            },
            __eq: function (operand, contextKey) {
                if (typeof operand === 'object' && operand !== null) {
                    return _this.buildQueryFilter(operand, contextKey);
                }
                return contextKey + " eq " + _this.quoteString(operand);
            },
            __gt: function (operand, contextKey) {
                return contextKey + " gt " + _this.quoteString(operand);
            },
            __ge: function (operand, contextKey) {
                return contextKey + " ge " + _this.quoteString(operand);
            },
            __lt: function (operand, contextKey) {
                return contextKey + " lt " + _this.quoteString(operand);
            },
            __le: function (operand, contextKey) {
                return contextKey + " le " + _this.quoteString(operand);
            },
            __in: function (operand, contextKey) {
                var stmts = operand
                    .filter(function (op) { return !!op; })
                    .map(function (op) {
                    return contextKey + " eq " + _this.quoteString(op);
                });
                return _this.glue(stmts, 'or');
            },
            __bygroupid: function (operand) {
                return "bygroupid(" + operand + ")";
            },
            __has: function (operand) {
                return "has(" + operand + ")";
            },
            __useFilterQueryString: function (queryString) {
                // match everything inside the most exterior parentheses, including them
                var query = queryString.match(/\(.*\)/)[0];
                // get rid of the most exterior parentheses
                return query.substring(1, query.length - 1);
            }
        };
    }
    /**
     * Builds query string from provided query object.
     *
     * @param query Object containing filters and sort order for querying managed objects. Supported filters are:
     * - **__and** - Specifies conditions, e.g. {__and: [{__has: 'c8y_IsDevice'}, {'count': {__gt: 0}}]}.
     * - **__or** - Specifies alternative conditions, e.g. {__or: [{__bygroupid: 10300}, {__bygroupid: 10400}]}.
     * - **__eq** - Specified fragment must be equal to given value, e.g. {'status': 'AVAILABLE'} (no nested object required).
     * - **__lt** - Specified fragment must be less then given value, e.g. {'count': {__lt: 10}}.
     * - **__gt** - Specified fragment must be greater then given value, e.g. {'count': {__gt: 0}}.
     * - **__in** - Specified fragment must be equal to one of values in the list, e.g. {'status': {__in: ['AVAILABLE', 'UNAVAILABLE']}}.
     * - **__not** - Negates condition, e.g. {__not: {'status': 'AVAILABLE'}}.
     * - **__bygroupid** - True if filtered managed object is assigned to given group, e.g. {__bygroupid: 10300}.
     * - **__has** - Specified fragment must have a value defined, e.g. {__has: 'c8y_IsDevice'}.
     * - **__useFilterQueryString** - Gets rid of the '$filter=() $orderby=' parts of a query and keeps only what's between the most
     *                                exterior parentheses of the $filter.
     *                                EXAMPLE: takes a query of the form
     *                                "$filter=(name eq 'RaspPi*') $orderby=name asc"
     *                                and turns it into
     *                                "name eq 'RaspPi*'"
     *                                This is necessary for searching for smart groups, which are identified by their own query
     *                                that needs to be passed through.
     *
     *
     * The order is specified by an array of field paths and sort direction (1 for ascending, -1 for descending), e.g.:
     * - {__orderby: [{'creationTime': -1}, {'name': 1}], __filter: {...}}
     *
     * @returns {string} Returns a query string ready to be sent in request params to backend.
     *
     * @example
     * <pre>
     *   const query = {
     *     __filter: {
     *       'name': 'My Device*',
     *       'c8y_Availability.status': {
     *         __in: ['AVAILABLE', 'UNAVAILABLE']
     *       },
     *       'creationTime': {
     *         __lt: '2015-11-30T13:28:123Z'
     *       },
     *       'c8y_ActiveAlarmsStatus.critical': {
     *         __gt: 0
     *       },
     *       __or: [
     *         {__not: {__has: 'c8y_ActiveAlarmsStatus.major'}},
     *         {
     *           __or: [
     *             {__bygroupid: 10300},
     *             {__bygroupid: 10400}
     *           ]
     *         }
     *       ]
     *     },
     *     __orderby: [
     *       {'name': 1},
     *       {'creationTime': -1},
     *       {'c8y_ActiveAlarmsStatus.critical': -1}
     *     ]
     *   };
     *
     *   const params = {
     *     query: queriesUtil.buildQuery(query)
     *   };
     * </pre>
     */
    QueriesUtil.prototype.buildQuery = function (query) {
        var q = [];
        var filter = this.buildQueryFilter(query.__filter || query);
        var orderBy = this.buildQueryOrderby(query.__orderby);
        if (filter) {
            q.push("$filter=(" + filter + ")");
        }
        if (orderBy) {
            q.push("$orderby=" + orderBy);
        }
        return q.join(' ');
    };
    QueriesUtil.prototype.buildQueryFilter = function (queryFilter, _queryKey, _glueType) {
        var _this = this;
        var queryKey = _queryKey || null;
        var glueType = _glueType || 'and';
        var q = [];
        if (Array.isArray(queryFilter)) {
            queryFilter.forEach(function (qFilter) {
                var _q = _this.buildQueryFilter(qFilter, null, glueType);
                if (_q) {
                    q.push(_q);
                }
            });
        }
        else {
            var _q_1;
            Object.keys(queryFilter).forEach(function (k) {
                if (_this.operatorFns[k] !== undefined) {
                    _q_1 = _this.operatorFns[k](queryFilter[k], queryKey);
                    if (_q_1) {
                        q.push(_q_1);
                    }
                }
                else {
                    _q_1 = _this.operatorFns.__eq(queryFilter[k], k);
                    if (_q_1) {
                        q.push(_q_1);
                    }
                }
            });
        }
        return this.glue(q, glueType);
    };
    QueriesUtil.prototype.buildQueryOrderby = function (queryOrderbys) {
        var o = [];
        if (queryOrderbys) {
            queryOrderbys.forEach(function (q) {
                Object.keys(q).forEach(function (k) {
                    if (q[k] !== 0) {
                        o.push(k + " " + (q[k] > 0 ? 'asc' : 'desc'));
                    }
                });
            });
        }
        return o.join(',');
    };
    QueriesUtil.prototype.addAndFilter = function (query, filter) {
        return this.addFilter(query, filter, 'and');
    };
    QueriesUtil.prototype.addOrFilter = function (query, filter) {
        return this.addFilter(query, filter, 'or');
    };
    QueriesUtil.prototype.addFilter = function (query, filter, operator) {
        var _a;
        var oldFilter = query.__orderby ? query.__filter || {} : query.__filter || query;
        var newFilter = (_a = {}, _a["__" + operator] = this.skipEmptyObjects([oldFilter, filter]), _a);
        if (!query.__filter && !query.__orderby) {
            return newFilter;
        }
        query.__filter = newFilter;
        return query;
    };
    QueriesUtil.prototype.prependOrderbys = function (query, orderbys) {
        return this.addOrderbys(query, orderbys, 'prepend');
    };
    QueriesUtil.prototype.appendOrderbys = function (query, orderbys) {
        return this.addOrderbys(query, orderbys, 'append');
    };
    QueriesUtil.prototype.addOrderbys = function (query, orderbys, how) {
        var oldFilter = query.__orderby ? query.__filter || {} : query.__filter || query;
        var oldOrderbys = query.__orderby || [];
        var newOrderbys = how === 'prepend' ? orderbys.concat(oldOrderbys) : oldOrderbys.concat(orderbys);
        var newQuery = {
            __orderby: this.skipEmptyObjects(newOrderbys)
        };
        if (!this.isEmptyObject(oldFilter)) {
            newQuery.__filter = oldFilter;
        }
        return newQuery;
    };
    QueriesUtil.prototype.glue = function (stmts, type) {
        return stmts.length > 1 ? "(" + stmts.join(") " + type + " (") + ")" : stmts[0];
    };
    QueriesUtil.prototype.quoteString = function (s) {
        return typeof s === 'string' ? "'" + s + "'" : s;
    };
    QueriesUtil.prototype.skipEmptyObjects = function (objs) {
        var _this = this;
        return objs.filter(function (obj) { return !_this.isEmptyObject(obj); });
    };
    QueriesUtil.prototype.isEmptyObject = function (obj) {
        return Object.keys(obj).length === 0;
    };
    return QueriesUtil;
}());
exports.QueriesUtil = QueriesUtil;

});

unwrapExports(QueriesUtil_1);
var QueriesUtil_2 = QueriesUtil_1.QueriesUtil;

var core = createCommonjsModule(function (module, exports) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(Service_1);
__export(FetchClient_1);
__export(BasicAuth_1);
__export(CookieAuth_1);
__export(Paging_1);
__export(Severity_1);
__export(ObservableList_1);
__export(QueriesUtil_1);

});

unwrapExports(core);

var EventService_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * This class allows managing for events.
 */
var EventService = /** @class */ (function (_super) {
    __extends(EventService, _super);
    function EventService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.baseUrl = 'event';
        _this.listUrl = 'events';
        _this.propertyName = 'events';
        _this.channel = '/events/*';
        return _this;
    }
    /**
     * Gets the details of a specific event.
     *
     * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *    const eventId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await eventService.detail(eventId);
     *   })();
     * ```
     */
    EventService.prototype.detail = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
            });
        });
    };
    /**
     * Creates a new event.
     *
     * @param {IEvent} entity Event object with mandantory fragments.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *  const mandantoryObject: IEvent = {
     *    source: device,
     *    text: 'I am an Event!',
     *    time: '2018-05-02T10:08:00Z',
     *    type: 'device-type-here',
     *  };
     *
     *  (async () => {
     *    const {data, res} = await eventService.create(mandantoryObject);
     *  })();
     * ```
     */
    EventService.prototype.create = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.create.call(this, entity)];
            });
        });
    };
    /**
     * Updates event data.
     *
     * @param {Partial<IEvent>} entity Event is partially updatable.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *  const partialUpdateObject: Partial<IEvent> = {
     *    source: device,
     *    text: 'Changed Event!'
     *  };
     *
     *  (async () => {
     *    const {data, res} = await eventService.update(partialUpdateObject);
     *  })();
     * ```
     */
    EventService.prototype.update = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.update.call(this, entity)];
            });
        });
    };
    /**
     * Gets the list of events filtered by parameters.
     *
     * @returns Response wrapped in [[IResultList]]
     *
     * @param {object} filter Object containing filters for querying events.
     *
     * @example
     * ```typescript
     *
     *  const filter: object = {
     *     pageSize: 100,
     *     withTotalPages: true
     *   };
     *
     *   (async () => {
     *     const {data, res, paging} = await eventService.list(filter);
     *   })();
     * ```
     */
    EventService.prototype.list = function (filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.list.call(this, filter)];
            });
        });
    };
    /**
     * Gets a list as observable.
     *
     * @param {object} filter Object containing filters for querying
     * @param {object} options To configure the observable
     *
     * @returns Data wrapped as Observable.
     *
     * @example
     * ```typescript
     *
     *   const list$ = eventService.list$();
     *   list$.subscribe((data) => console.log(data));
     * ```
     *
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use [[Realtime]] for realtime connection and
     * rxjs `defer()` or `from()` to composite an observable on your own.
     */
    EventService.prototype.list$ = function (filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return _super.prototype.list$.call(this, filter, options);
    };
    /**
     * List all events by a given source.
     *
     * @param {string | number | IIdentified} sourceOrId The source of the event.
     * @param {object} filter Object containing filters for querying.
     * @param {object} options To configure the observable.
     *
     * @returns Data wrapped as Observable.
     *
     * @example
     * ```typescript
     *
     *   const listBySource$ = eventService.listBySource$(11);
     *   listBySource$.subscribe((data) => console.log(data));
     * ```
     *
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use [[Realtime]] for realtime connection and
     * rxjs `defer()` or `from()` to composite an observable on your own.
     */
    EventService.prototype.listBySource$ = function (sourceOrId, filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        Object.assign(filter, {
            source: this.getIdString(sourceOrId)
        });
        return _super.prototype.list$.call(this, filter, options);
    };
    /**
     * Removes an event with given id.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {string | number | IIdentified} entityOrId entity or id of the event.
     *
     * @example
     * ```typescript
     *
     *  const eventId: number = 1;
     *
     *   (async () => {
     *     const {data, res} = await eventService.delete(eventId);
     *     // data will be null
     *   })();
     * ```
     */
    EventService.prototype.delete = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.delete.call(this, entityOrId)];
            });
        });
    };
    return EventService;
}(core.Service));
exports.EventService = EventService;

});

unwrapExports(EventService_1);
var EventService_2 = EventService_1.EventService;

/* eslint-env browser */
var browser$1 = typeof self == 'object' ? self.FormData : window.FormData;

var EventBinaryService_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var form_data_1 = __importDefault(browser$1);

var EventBinaryService = /** @class */ (function (_super) {
    __extends(EventBinaryService, _super);
    function EventBinaryService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.baseUrl = 'event';
        _this.listUrl = 'events';
        return _this;
    }
    /**
     * Uploads an event binary.
     * @returns Response wrapped in [[IResult]]
     *
     * @param {Stream | Buffer | File | Blob} file file to upload.
     * @param {string | number | IEvent} eventOrId Event or Id of the Event.
     *
     * @example
     * ```typescript
     *
     *   const file = Buffer.from('aaa');
     *   const eventId: string | number = 123;
     *
     *    (async () => {
     *      const {data, res} = await eventBinaryService.upload(file, eventId);
     *   })();
     * ```
     */
    EventBinaryService.prototype.upload = function (file, entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            var method, url, body, headers, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        method = 'POST';
                        url = this.getDetailUrl(entityOrId);
                        body = new form_data_1.default();
                        body.append('file', file);
                        headers = {
                            accept: 'application/json'
                        };
                        return [4 /*yield*/, this.fetch(url, { method: method, body: body, headers: headers })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    /**
     * Downloads the binary for a given event.
     * @returns Response wrapped in [[IFetchResponse]]
     *
     * @param {string | number | IEvent} eventOrId Event or Id of the Event.
     *
     * @example
     * ```typescript
     *
     *   const eventId: string | number = 123;
     *
     *    (async () => {
     *      const res = await eventBinaryService.download(eventId);
     *   })();
     */
    EventBinaryService.prototype.download = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            var url;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.getDetailUrl(entityOrId);
                        return [4 /*yield*/, this.fetch(url)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Removes the binary for a given event.
     * @returns Response wrapped in [[IResult]]
     *
     * @param {string | number | IEvent} eventOrId Event or Id of the Event.
     *
     * @example
     * ```typescript
     *
     *   const eventId: string | number = 123;
     *
     *    (async () => {
     *      const {data, res} = await eventBinaryService.delete(eventId);
     *   })();
     * ```
     */
    EventBinaryService.prototype.delete = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.delete.call(this, entityOrId)];
            });
        });
    };
    EventBinaryService.prototype.getDetailUrl = function (entityOrId) {
        var id;
        if (typeof entityOrId === 'object' && entityOrId.id) {
            id = entityOrId.id;
        }
        else {
            id = entityOrId;
        }
        return this.listUrl + "/" + id + "/binaries";
    };
    return EventBinaryService;
}(core.Service));
exports.EventBinaryService = EventBinaryService;

});

unwrapExports(EventBinaryService_1);
var EventBinaryService_2 = EventBinaryService_1.EventBinaryService;

var event = createCommonjsModule(function (module, exports) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(EventService_1);
__export(EventBinaryService_1);

});

unwrapExports(event);

var InventoryBinaryService_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var form_data_1 = __importDefault(browser$1);

var InventoryBinaryService = /** @class */ (function (_super) {
    __extends(InventoryBinaryService, _super);
    function InventoryBinaryService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.baseUrl = 'inventory';
        _this.listUrl = 'binaries';
        _this.propertyName = 'managedObjects';
        return _this;
    }
    /**
     * Uploads a file and creates a managed object with its metadata.
     * @param file A file to be uploaded.
     * @param managedObject An object containing metadata about the file.
     * Note that you can specify `fileType` and `fileName` in case `file` does not define them
     * but these two properties will be removed from `managedObject` before saving.
     */
    InventoryBinaryService.prototype.create = function (file, managedObject) {
        if (managedObject === void 0) { managedObject = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var method, url, body, fileName, fileType, bodyHeaders, headers, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        method = 'POST';
                        url = this.listUrl;
                        body = new form_data_1.default();
                        if (managedObject.fileName) {
                            fileName = managedObject.fileName;
                            delete managedObject.fileName;
                        }
                        if (managedObject.fileType) {
                            fileType = managedObject.fileType;
                            delete managedObject.fileType;
                        }
                        if (!fileName) {
                            fileName = 'bin';
                        }
                        if (typeof (File) !== 'undefined' && file instanceof File) {
                            fileName = file.name;
                            fileType = file.type;
                        }
                        if (!managedObject.name) {
                            managedObject.name = fileName;
                        }
                        if (!managedObject.type) {
                            managedObject.type = fileType || 'c8y_upload';
                        }
                        body.append('file', file, fileName);
                        body.append('object', JSON.stringify(managedObject));
                        if (typeof body.getHeaders === 'function') {
                            bodyHeaders = body.getHeaders();
                        }
                        headers = Object.assign({
                            accept: 'application/json'
                        }, bodyHeaders);
                        return [4 /*yield*/, this.fetch(url, { method: method, body: body, headers: headers })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    InventoryBinaryService.prototype.list = function (filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.list.call(this, filter)];
            });
        });
    };
    /**
     * Gets a list as observable.
     *
     * @param {object} filter Object containing filters for querying
     * @param {object} options To configure the observable
     *
     * @returns Data wrapped as [[ObservableList]]
     *
     * @example
     * ```typescript
     *
     *   const list$ = InventoryBinaryService.list$();
     *   list$.subscribe((data) => console.log(data));
     * ```
     */
    InventoryBinaryService.prototype.list$ = function (filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return _super.prototype.list$.call(this, filter, options);
    };
    InventoryBinaryService.prototype.delete = function (managedObjectOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.delete.call(this, managedObjectOrId)];
            });
        });
    };
    InventoryBinaryService.prototype.download = function (managedObjectOrId) {
        return __awaiter(this, void 0, void 0, function () {
            var url;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.getDetailUrl(managedObjectOrId);
                        return [4 /*yield*/, this.fetch(url)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Gets binary managed object's id from its download or self URL.
     *
     * @param {string} url URL string.
     *
     * @returns {number} Binary managed object's id.
     *
     * @example
     * ```typescript
     *
     *   const id = InventoryBinaryService.getIdFromUrl('http://mytenant.cumulocity.com/inventory/binaries/12345');
     * ```
     */
    InventoryBinaryService.prototype.getIdFromUrl = function (url) {
        var regexp = new RegExp('\\/inventory\\/binaries\\/(\\d+)|\\/inventory\\/managedObjects\\/(\\d+)');
        var matches = url.match(regexp);
        return matches && (matches[1] || matches[2]);
    };
    return InventoryBinaryService;
}(core.Service));
exports.InventoryBinaryService = InventoryBinaryService;

});

unwrapExports(InventoryBinaryService_1);
var InventoryBinaryService_2 = InventoryBinaryService_1.InventoryBinaryService;

var InventoryService_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * Possible types of a child.
 */
var ChildType;
(function (ChildType) {
    ChildType["ASSETS"] = "childAssets";
    ChildType["DEVICES"] = "childDevices";
    ChildType["ADDITIONS"] = "childAdditions";
})(ChildType = exports.ChildType || (exports.ChildType = {}));
/**
 * This class allows for managing managed objects and different child types, see [[ChildType]].
 */
var InventoryService = /** @class */ (function (_super) {
    __extends(InventoryService, _super);
    function InventoryService(client, realtime) {
        var _this = _super.call(this, client, realtime) || this;
        _this.baseUrl = 'inventory';
        _this.listUrl = 'managedObjects';
        _this.propertyName = 'managedObjects';
        _this.channel = '/managedobjects/*';
        _this.inventoriesQueryParamName = 'query';
        _this.devicesQueryParamName = 'q';
        _this.queriesUtil = new core.QueriesUtil();
        _this.binary = new InventoryBinaryService_1.InventoryBinaryService(client);
        return _this;
    }
    /**
     * Gets the details of managed object
     *
     * @param {IdReference} managedObjectOrId ManagedObject or Id of the ManagedObject.
     * @param {object} filter Filter object.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *    const managedObjId: number = 1;
     *    const filter = { withChildren: false };
     *
     *    (async () => {
     *      const {data, res} = await inventoryService.detail(managedObjId, filter);
     *   })();
     * ```
     */
    InventoryService.prototype.detail = function (managedObjectOrId, filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.detail.call(this, managedObjectOrId, filter)];
            });
        });
    };
    /**
     * Gets the details of managed object as observable
     *
     * @param {IdReference} managedObjectOrId ManagedObject or Id of the ManagedObject.
     * @param {IObservableOptions} options The observable options.
     *
     * @returns Data wrapped as Observable
     *
     * @example
     * ```typescript
     *
     *   const managedObjId: number = 1;
     *
     *   const detail$ = inventoryService.detail$(managedObjId);
     *   detail$.subscribe((data) => console.log(data));
     * ```
     *
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use [[Realtime]] for realtime connection and
     * rxjs `defer()` or `from()` to composite an observable on your own.
     */
    InventoryService.prototype.detail$ = function (entityOrId, options) {
        return _super.prototype.detail$.call(this, entityOrId, options);
    };
    /**
     * Gets a list as observable.
     *
     * @param {object} filter Object containing filters for querying
     * @param {object} options To configure the observable
     *
     * @returns Data wrapped as Observable.
     *
     * @example
     * ```typescript
     *
     *   const list$ = inventoryService.list$();
     *   list$.subscribe((data) => console.log(data));
     * ```
     *
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use [[Realtime]] for realtime connection and
     * rxjs `defer()` or `from()` to composite an observable on your own.
     */
    InventoryService.prototype.list$ = function (filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return _super.prototype.list$.call(this, filter, options);
    };
    /**
     * Creates a new managed object.
     *
     * @param {Partial<IManagedObject>} managedObject
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *  const partialManagedObj: Partial<IManagedObject> = {
     *    customFragment: 'yourData'
     *  };
     *
     *  (async () => {
     *    const {data, res} = await inventoryService.create(partialManagedObj);
     *  })();
     * ```
     */
    InventoryService.prototype.create = function (managedObject) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.create.call(this, managedObject)];
            });
        });
    };
    /**
     * Updates managed object data.
     *
     * @param {Partial<IManagedObject>} managedObject Managed object is partially updatable.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *  const partialUpdateObject: Partial<IManagedObject> = {
     *    customFragment: 'Changed data',
     *    name: 'Name'
     *  };
     *
     *  (async () => {
     *    const {data, res} = await inventoryService.update(partialUpdateObject);
     *  })();
     * ```
     */
    InventoryService.prototype.update = function (managedObject) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.update.call(this, managedObject)];
            });
        });
    };
    /**
     * Gets the list of managed objects filtered by parameters.
     *
     * @returns Response wrapped in [[IResultList]]
     *
     * @param {object} filter Object containing filters for querying managed objects.
     *
     * @example
     * ```typescript
     *
     *  const filter: object = {
     *     pageSize: 100,
     *     withTotalPages: true
     *   };
     *
     *   (async () => {
     *     const {data, res, paging} = await inventoryService.list(filter);
     *   })();
     * ```
     */
    InventoryService.prototype.list = function (filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.list.call(this, filter)];
            });
        });
    };
    /**
     * Gets the list of all managed objects filtered and sorted by given query.
     *
     * @returns Response wrapped in [[IResultList]]
     *
     * @param {object} filter Object containing filters for querying managed objects.
     *
     * @example
     * ```typescript
     *
     *  const filter: object = {
     *     pageSize: 100,
     *     withTotalPages: true
     *   };
     *
     *  const query = {
     *      name: 'MY-NAM*'
     *  }
     *
     *   (async () => {
     *     const {data, res, paging} = await inventoryService.listQuery(query, filter);
     *   })();
     * ```
     */
    InventoryService.prototype.listQuery = function (query, filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                filter[this.inventoriesQueryParamName] = this.queriesUtil.buildQuery(query);
                return [2 /*return*/, _super.prototype.list.call(this, filter)];
            });
        });
    };
    /**
     * Gets the list of all devices filtered and sorted by given query.
     *
     * @returns Response wrapped in [[IResultList]]
     *
     * @param {object} filter Object containing filters for querying devices.
     *
     * @example
     * ```typescript
     *
     *  const filter: object = {
     *     pageSize: 100,
     *     withTotalPages: true
     *   };
     *
     *  const query = {
     *      name: 'MY-NAM*'
     *  }
     *
     *   (async () => {
     *     const {data, res, paging} = await inventoryService.listQueryDevices(query, filter);
     *   })();
     * ```
     */
    InventoryService.prototype.listQueryDevices = function (query, filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                filter[this.devicesQueryParamName] = this.queriesUtil.buildQuery(query);
                return [2 /*return*/, _super.prototype.list.call(this, filter)];
            });
        });
    };
    /**
     * Removes managed object with given id.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {IdReference} managedObjectOrId ManagedObject or Id of the ManagedObject.
     * @param {object} params Additional query params.
     *
     * @example
     * ```typescript
     *
     *   const managedObjectId: number = 1;
     *   const params: any = {
     *     cascade: true
     *   }
     *
     *    (async () => {
     *      const {data, res} = await inventoryService.delete(managedObjectId, params);
     *   })();
     * ```
     */
    InventoryService.prototype.delete = function (managedObjectOrId, params) {
        if (params === void 0) { params = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.delete.call(this, managedObjectOrId, params)];
            });
        });
    };
    /**
     * Gets a list of child additions from a given managed object (parent)
     *
     * @returns Response wrapped in [[IResultList]]
     *
     * @param {IdReference} parentReference
     * @param {object} filter
     *
     * @example
     * ```typescript
     *    const parentReferenceId: IdReference = 1;
     *
     *    const filter: object = {
     *      pageSize: 100,
     *      withTotalPages: true
     *    };
     *
     *    (async () => {
     *      const {data, res, paging} = await inventoryService.childAdditionsList(parentReferenceId, filter);
     *    })();
     * ```
     */
    InventoryService.prototype.childAdditionsList = function (parentReference, filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.listChildren(ChildType.ADDITIONS, parentReference, filter)];
            });
        });
    };
    /**
     * Creates a new managed object as child addition to another managed object (parent)
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {Partial<IManagedObject>} managedObject
     * @param {IdReference} parentReference
     *
     * @example
     * ```typescript
     *
     *    const mOAsChildAddition: Partial<IManagedObject> = {
     *      name: 'Child addition MO',
     *      type: 'new type',
     *      ...
     *    };
     *
     *    // This is the identifier of the managed object which should be the parent of
     *    // mOAsChildAddition, see above.
     *    const parentReferenceId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await inventoryService.childAdditionsCreate(mOAsChildAddition, parentReferenceId);
     *    })();
     * ```
     */
    InventoryService.prototype.childAdditionsCreate = function (managedObject, parentReference) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.createChild(ChildType.ADDITIONS, managedObject, parentReference)];
            });
        });
    };
    /**
     * Adds an existing managed object as child addition to another managed object (parent)
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {IdReference} childReference
     * @param {IdReference} parentReference
     *
     * @example
     * ```typescript
     *
     *    const childRef: number = 2;
     *    const parentReferenceId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await inventoryService.childAdditionsCreate(childRef, parentReferenceId);
     *    })();
     * ```
     */
    InventoryService.prototype.childAdditionsAdd = function (childReference, parentReference) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.addChild(ChildType.ADDITIONS, childReference, parentReference)];
            });
        });
    };
    /**
     * Removes an existing managed object as child addition from another managed object (parent)
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {IdReference} childReference
     * @param {IdReference} parentReference
     *
     * @example
     * ```typescript
     *
     *    const childRef: number = 2;
     *    const parentReferenceId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await inventoryService.childAdditionsRemove(childRef, parentReferenceId);
     *    })();
     * ```
     */
    InventoryService.prototype.childAdditionsRemove = function (childReference, parentReference) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.removeChild(ChildType.ADDITIONS, childReference, parentReference)];
            });
        });
    };
    /**
     * Gets a list of child assets from a given managed object (parent)
     *
     * @returns Response wrapped in [[IResultList]]
     *
     * @param {IdReference} parentReference
     * @param {object} filter
     *
     * @example
     * ```typescript
     *
     *    const parentReferenceId: IdReference = 1;
     *
     *    const filter: object = {
     *      pageSize: 100,
     *      withTotalPages: true
     *    };
     *
     *    (async () => {
     *      const {data, res, paging} = await inventoryService.childAssetsList(parentReferenceId, filter);
     *    })();
     * ```
     */
    InventoryService.prototype.childAssetsList = function (parentReference, filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.listChildren(ChildType.ASSETS, parentReference, filter)];
            });
        });
    };
    /**
     * Creates a new managed object as child asset to another managed object (parent)
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {Partial<IManagedObject>} managedObject
     * @param {IdReference} parentReference
     *
     * @example
     * ```typescript
     *
     *    const mOAsChildAsset: Partial<IManagedObject> = {
     *      name: 'Child asset MO',
     *      type: 'new type',
     *      ...
     *    };
     *
     *    // This is the identifier of the managed object which should be the parent of
     *    // mOAsChildAsset, see above.
     *    const parentReferenceId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await inventoryService.childAdditionsCreate(mOAsChildAddition, parentReferenceId);
     *    })();
     * ```
     */
    InventoryService.prototype.childAssetsCreate = function (managedObject, parentReference) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.createChild(ChildType.ASSETS, managedObject, parentReference)];
            });
        });
    };
    /**
     * Adds an existing managed object as child asset to another managed object (parent)
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {IdReference} childReference
     * @param {IdReference} parentReference
     *
     * @example
     * ```typescript
     *
     *    const childRef: number = 2;
     *    const parentReferenceId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await inventoryService.childAssetsAdd(childRef, parentReferenceId);
     *    })();
     * ```
     */
    InventoryService.prototype.childAssetsAdd = function (childReference, parentReference) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.addChild(ChildType.ASSETS, childReference, parentReference)];
            });
        });
    };
    /**
     * Removes an existing managed object as child asset from another managed object (parent)
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {IdReference} childReference
     * @param {IdReference} parentReference
     *
     * @example
     * ```typescript
     *
     *    const childRef: number = 2;
     *    const parentReferenceId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await inventoryService.childAssetsRemove(childRef, parentReferenceId);
     *    })();
     * ```
     */
    InventoryService.prototype.childAssetsRemove = function (childReference, parentReference) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.removeChild(ChildType.ASSETS, childReference, parentReference)];
            });
        });
    };
    /**
     * Gets a list of child devices from a given managed object (parent)
     *
     * @returns Response wrapped in [[IResultList]]
     *
     * @param {IdReference} parentReference
     * @param {object} filter
     *
     * @example
     * ```typescript
     *
     *    const parentReferenceId: IdReference = 1;
     *
     *    const filter: object = {
     *      pageSize: 100,
     *      withTotalPages: true
     *    };
     *
     *    (async () => {
     *      const {data, res, paging} = await inventoryService.childDevicesList(parentReferenceId, filter);
     *    })();
     * ```
     */
    InventoryService.prototype.childDevicesList = function (parentReference, filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.listChildren(ChildType.DEVICES, parentReference, filter)];
            });
        });
    };
    /**
     * Creates a new managed object as child device to another managed object (parent)
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {Partial<IManagedObject>} managedObject
     * @param {IdReference} parentReference
     *
     * @example
     * ```typescript
     *
     *    const mOAsChildDevice: Partial<IManagedObject> = {
     *      name: 'Child device MO',
     *      type: 'new type',
     *      ...
     *    };
     *
     *    // This is the identifier of the managed object which should be the parent of
     *    // mOAsChildDevice, see above.
     *    const parentReferenceId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await inventoryService.childDevicesCreate(mOAsChildDevice, parentReferenceId);
     *    })();
     * ```
     */
    InventoryService.prototype.childDevicesCreate = function (managedObject, parentReference) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.createChild(ChildType.DEVICES, managedObject, parentReference)];
            });
        });
    };
    /**
     * Adds an existing managed object as child device to another managed object (parent)
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {IdReference} childReference
     * @param {IdReference} parentReference
     *
     * @example
     * ```typescript
     *
     *    const childRef: number = 2;
     *    const parentReferenceId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await inventoryService.childDevicesAdd(childRef, parentReferenceId);
     *    })();
     * ```
     */
    InventoryService.prototype.childDevicesAdd = function (childReference, parentReference) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.addChild(ChildType.DEVICES, childReference, parentReference)];
            });
        });
    };
    /**
     * Removes an existing managed object as child device from another managed object (parent)
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {IdReference} childReference
     * @param {IdReference} parentReference
     *
     * @example
     * ```typescript
     *
     *    const childRef: number = 2;
     *    const parentReferenceId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await inventoryService.childDevicesRemove(childRef, parentReferenceId);
     *    })();
     * ```
     */
    InventoryService.prototype.childDevicesRemove = function (childReference, parentReference) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.removeChild(ChildType.DEVICES, childReference, parentReference)];
            });
        });
    };
    InventoryService.prototype.onBeforeUpdate = function (objWithId) {
        delete objWithId.lastUpdated;
        return objWithId;
    };
    InventoryService.prototype.onBeforeCreate = function (managedObject) {
        delete managedObject.id;
        delete managedObject.lastUpdated;
        return managedObject;
    };
    InventoryService.prototype.getChildrenUrl = function (type, parentReference) {
        return this.getDetailUrl(parentReference) + "/" + type;
    };
    InventoryService.prototype.getChildUrl = function (type, childReference, parentReference) {
        var childId = this.getIdString(childReference);
        return this.getChildrenUrl(type, parentReference) + "/" + childId;
    };
    InventoryService.prototype.listChildren = function (type, parentReference, filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var headers, url, res, json, data, paging;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        headers = { 'content-type': 'application/json' };
                        url = this.getChildrenUrl(type, parentReference);
                        return [4 /*yield*/, this.fetch(url, { headers: headers, params: filter })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        json = _a.sent();
                        data = json.references.map(function (ref) { return ref.managedObject; });
                        paging = this.getPaging(json, filter);
                        paging.list = function (pagingFilter) { return _this.listChildren(type, parentReference, pagingFilter); };
                        return [2 /*return*/, { res: res, data: data, paging: paging }];
                }
            });
        });
    };
    InventoryService.prototype.createChild = function (type, managedObject, parentReference) {
        return __awaiter(this, void 0, void 0, function () {
            var url, method, body, headers, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.getChildrenUrl(type, parentReference);
                        method = 'POST';
                        body = JSON.stringify(this.onBeforeCreate(managedObject));
                        headers = { 'content-type': this.mimeType('managedObject'), accept: 'application/json' };
                        return [4 /*yield*/, this.fetch(url, { method: method, body: body, headers: headers })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    InventoryService.prototype.addChild = function (type, childReference, parentReference) {
        return __awaiter(this, void 0, void 0, function () {
            var url, method, childId, body, headers, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.getChildrenUrl(type, parentReference);
                        method = 'POST';
                        childId = this.getIdString(childReference);
                        body = JSON.stringify({ managedObject: { id: String(childId) } });
                        headers = {
                            accept: 'application/json',
                            'content-type': this.mimeType('managedObjectReference')
                        };
                        return [4 /*yield*/, this.fetch(url, { method: method, body: body, headers: headers })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        data = data.managedObject;
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    InventoryService.prototype.removeChild = function (type, childReference, parentReference) {
        return __awaiter(this, void 0, void 0, function () {
            var childId, url, method, headers, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        childId = this.getIdString(childReference);
                        url = this.getChildrenUrl(type, parentReference) + "/" + childId;
                        method = 'DELETE';
                        headers = { accept: 'application/json' };
                        return [4 /*yield*/, this.fetch(url, { method: method, headers: headers })];
                    case 1:
                        res = _a.sent();
                        data = null;
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    return InventoryService;
}(core.Service));
exports.InventoryService = InventoryService;

});

unwrapExports(InventoryService_1);
var InventoryService_2 = InventoryService_1.ChildType;
var InventoryService_3 = InventoryService_1.InventoryService;

var inventory = createCommonjsModule(function (module, exports) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(InventoryService_1);
__export(InventoryBinaryService_1);

});

unwrapExports(inventory);

var MeasurementService_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * This class allows for managing measurements.
 */
var MeasurementService = /** @class */ (function (_super) {
    __extends(MeasurementService, _super);
    function MeasurementService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.baseUrl = 'measurement';
        _this.listUrl = 'measurements';
        _this.propertyName = 'measurements';
        _this.channel = '/measurements/*';
        return _this;
    }
    /**
     * Gets the details of selected measurement.
     *
     * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *    const measurementId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await measurementService.detail(measurementId);
     *   })();
     * ```
     */
    MeasurementService.prototype.detail = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
            });
        });
    };
    /**
     * Creates a new measurement.
     *
     * @param {Partial<IMeasurementCreate>} entity At least sourceId is mandantory.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *  const mandantoryObject: Partial<IMeasurementCreate> = {
     *    sourceId: device.id,
     *    fragment: { series: { unit: '%', value: 51 } },
     *  };
     *
     *  (async () => {
     *    const {data, res} = await measurementService.create(mandantoryObject);
     *  })();
     * ```
     */
    MeasurementService.prototype.create = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.create.call(this, this.onBeforeCreate(entity))];
            });
        });
    };
    /**
     * Gets the list of measurements filtered by parameters.
     *
     * @returns Response wrapped in [[IResultList]]
     *
     * @param {object} filter Object containing filters for querying measurements.
     *
     * @example
     * ```typescript
     *
     *  const filter: object = {
     *     pageSize: 100,
     *     withTotalPages: true
     *   };
     *
     *   (async () => {
     *     const {data, res, paging} = await measurementService.list(filter);
     *   })();
     * ```
     */
    MeasurementService.prototype.list = function (filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.list.call(this, filter)];
            });
        });
    };
    /**
     * Gets a list as observable.
     *
     * @param {object} filter Object containing filters for querying
     * @param {object} options To configure the observable
     *
     * @returns Data wrapped as Observable.
     *
     * @example
     * ```typescript
     *
     *   const list$ = measurementService.list$();
     *   list$.subscribe((data) => console.log(data));
     * ```
     *
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use [[Realtime]] for realtime connection and
     * rxjs `defer()` or `from()` to composite an observable on your own.
     */
    MeasurementService.prototype.list$ = function (filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return _super.prototype.list$.call(this, filter, options);
    };
    /**
     * List all events by a given source.
     *
     * @param {string | number | IIdentified} sourceOrId The source of the event.
     * @param {object} filter Object containing filters for querying.
     * @param {object} options To configure the observable.
     *
     * @returns Data wrapped as [[ObservableList]]
     *
     * @example
     * ```typescript
     *
     *   const listBySource$ = measurementService.listBySource$(11);
     *   listBySource$.subscribe((data) => console.log(data));
     * ```
     *
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use [[Realtime]] for realtime connection and
     * rxjs `defer()` or `from()` to composite an observable on your own.
     */
    MeasurementService.prototype.listBySource$ = function (sourceOrId, filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        Object.assign(filter, {
            source: this.getIdString(sourceOrId)
        });
        return _super.prototype.list$.call(this, filter, options);
    };
    /**
     * Removes a measurement with given id.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {string | number | IIdentified} entityOrId
     *
     * @example
     * ```typescript
     *
     *   const id: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await measurementService.delete(id);
     *   })();
     * ```
     */
    MeasurementService.prototype.delete = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.delete.call(this, entityOrId)];
            });
        });
    };
    /**
     * Gets the list of series in a measurement filtered by parameters.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {object} filter Object containing filters for querying measurements.
     *
     * @example
     * ```typescript
     *
     *  const filter: object = {
     *    dateFrom: '2018-02-06T10:43:55.077Z',
     *    dateTo: '2018-02-06T10:50:55.077Z',
     *    source: device.id
     *  };
     *
     *   (async () => {
     *     const {data, res} = await measurementService.listSeries(filter);
     *   })();
     * ```
     */
    MeasurementService.prototype.listSeries = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var url, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.baseUrl + "/" + this.listUrl + "/series";
                        return [4 /*yield*/, this.client.fetch(url, { params: params })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    MeasurementService.prototype.onBeforeCreate = function (entity) {
        if (!entity.time) {
            entity.time = new Date();
        }
        if (!entity.type) {
            entity.type = 'c8y_Measurement';
        }
        if (entity.sourceId) {
            var sourceId = entity.sourceId;
            delete entity.sourceId;
            if (!entity.source) {
                entity.source = {
                    id: String(sourceId),
                };
            }
        }
        return entity;
    };
    return MeasurementService;
}(core.Service));
exports.MeasurementService = MeasurementService;

});

unwrapExports(MeasurementService_1);
var MeasurementService_2 = MeasurementService_1.MeasurementService;

var ISeriesFilter = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var aggregationType;
(function (aggregationType) {
    aggregationType["MINUTELY"] = "MINUTELY";
    aggregationType["HOURLY"] = "HOURLY";
    aggregationType["MONTHLY"] = "MONTHLY";
})(aggregationType = exports.aggregationType || (exports.aggregationType = {}));

});

unwrapExports(ISeriesFilter);
var ISeriesFilter_1 = ISeriesFilter.aggregationType;

var measurement = createCommonjsModule(function (module, exports) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(MeasurementService_1);
__export(ISeriesFilter);

});

unwrapExports(measurement);

var AlarmService_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * This class allows for managing alarms.
 */
var AlarmService = /** @class */ (function (_super) {
    __extends(AlarmService, _super);
    function AlarmService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.baseUrl = 'alarm';
        _this.listUrl = 'alarms';
        _this.propertyName = 'alarms';
        _this.channel = '/alarms/*';
        return _this;
    }
    /**
     * Gets the details of selected alarms.
     *
     * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *    const alarmId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await alarmService.detail(alarmId);
     *    })();
     * ```
     */
    AlarmService.prototype.detail = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
            });
        });
    };
    /**
     * Creates a new alarm.
     *
     * @param {IAlarm} entity Alarm object with mandantory fragments.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *  const mandantoryObject: IAlarm = {
     *    severity: Severity.CRITICAL,
     *    source: device,
     *    text: 'I am an Alarm!',
     *    time: '2018-05-02T10:08:00Z',
     *    type: 'device-type-here',
     *  };
     *
     *  (async () => {
     *    const {data, res} = await alarmService.create(mandantoryObject);
     *  })();
     * ```
     */
    AlarmService.prototype.create = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.create.call(this, entity)];
            });
        });
    };
    /**
     * Updates alarm data.
     *
     * @param {Partial<IAlarm>} entity Alarm is partially updatable.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *  const partialUpdateObject: Partial<IAlarm> = {
     *    severity: Severity.MINOR,
     *    source: device,
     *    text: 'Changed Alarm!'
     *  };
     *
     *  (async () => {
     *    const {data, res} = await alarmService.update(partialUpdateObject);
     *  })();
     * ```
     */
    AlarmService.prototype.update = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.update.call(this, entity)];
            });
        });
    };
    /**
     * Gets the list of alarms filtered by parameters.
     *
     * @returns Response wrapped in [[IResultList]]
     *
     * @param {object} filter Object containing filters for querying alarms.
     *
     * @example
     * ```typescript
     *
     *  const filter: object = {
     *     severity: Severity.MAJOR,
     *     pageSize: 100,
     *     withTotalPages: true
     *   };
     *
     *   (async () => {
     *     const {data, res, paging} = await alarmService.list(filter);
     *   })();
     * ```
     */
    AlarmService.prototype.list = function (filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.list.call(this, filter)];
            });
        });
    };
    /**
     * Gets a list as observable.
     *
     * @param {object} filter Object containing filters for querying
     * @param {object} options To configure the observable
     *
     * @returns Data wrapped as [[ObservableList]]
     *
     * @example
     * ```typescript
     *
     *   const list$ = alarmService.list$();
     *   list$.subscribe((data) => console.log(data));
     * ```
     *
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use [[Realtime]] for realtime connection and
     * rxjs `defer()` or `from()` to composite an observable on your own.
     */
    AlarmService.prototype.list$ = function (filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return _super.prototype.list$.call(this, filter, options);
    };
    /**
     * List all events by a given source.
     *
     * @param {string | number | IIdentified} sourceOrId The source of the event.
     * @param {object} filter Object containing filters for querying.
     * @param {object} options To configure the observable.
     *
     * @returns Data wrapped as Observable.
     *
     * @example
     * ```typescript
     *
     *   const listBySource$ = alarmService.listBySource$(11);
     *   listBySource$.subscribe((data) => console.log(data));
     * ```
     *
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use [[Realtime]] for realtime connection and
     * rxjs `defer()` or `from()` to composite an observable on your own.
     */
    AlarmService.prototype.listBySource$ = function (sourceOrId, filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        Object.assign(filter, {
            source: this.getIdString(sourceOrId)
        });
        return _super.prototype.list$.call(this, filter, options);
    };
    return AlarmService;
}(core.Service));
exports.AlarmService = AlarmService;

});

unwrapExports(AlarmService_1);
var AlarmService_2 = AlarmService_1.AlarmService;

var AlarmStatus_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * A specific alarm can have one of the following states
 */
var AlarmStatus;
(function (AlarmStatus) {
    AlarmStatus[AlarmStatus["ACKNOWLEDGED"] = gettext.gettext('ACKNOWLEDGED')] = "ACKNOWLEDGED";
    AlarmStatus[AlarmStatus["CLEARED"] = gettext.gettext('CLEARED')] = "CLEARED";
    AlarmStatus[AlarmStatus["ACTIVE"] = gettext.gettext('ACTIVE')] = "ACTIVE";
})(AlarmStatus = exports.AlarmStatus || (exports.AlarmStatus = {}));

});

unwrapExports(AlarmStatus_1);
var AlarmStatus_2 = AlarmStatus_1.AlarmStatus;

var alarm = createCommonjsModule(function (module, exports) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(AlarmService_1);
__export(AlarmStatus_1);

});

unwrapExports(alarm);

var OperationService_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * This class allows for managing operations on a device.
 */
var OperationService = /** @class */ (function (_super) {
    __extends(OperationService, _super);
    function OperationService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.baseUrl = 'devicecontrol';
        _this.listUrl = 'operations';
        _this.propertyName = 'operations';
        return _this;
    }
    /**
     * Gets the details of selected operation.
     *
     * @param {string|number|IIdentified} entityOrId Entity or Id of the entitytabs.service.ts.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *    const operationId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await operationService.detail(operationId);
     *   })();
     * ```
     */
    OperationService.prototype.detail = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
            });
        });
    };
    /**
     * Creates a new operation.
     *
     * @param {IOperation} entity Operation object with mandantory fragments.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *  const mandantoryObject: IOperation = {
     *    com_cumulocity_model_WebCamDevice: {
     *      name: 'take picture',
     *      parameters: {
     *         duration: '5s',
     *         quality: 'HD'
     *      }
     *    },
     *    deviceId: device.id,
     *  };
     *
     *  (async () => {
     *    const {data, res} = await operationService.create(mandantoryObject);
     *  })();
     * ```
     */
    OperationService.prototype.create = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.create.call(this, entity)];
            });
        });
    };
    /**
     * Updates operation data.
     *
     * @param {Partial<IOperation>} entity Operation is partially updatable.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *  const partialUpdateObject: Partial<IOperation> = {
     *    com_cumulocity_model_WebCamDevice: {
     *      name: 'take picture',
     *      parameters: {
     *         duration: '2s',
     *         quality: 'HD',
     *         ratio: '16:9'
     *      }
     *    },
     *    deviceId: device.id,
     *  };
     *
     *  (async () => {
     *    const {data, res} = await operationService.update(partialUpdateObject);
     *  })();
     * ```
     */
    OperationService.prototype.update = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.update.call(this, entity)];
            });
        });
    };
    /**
     * Gets the list of operations filtered by parameters.
     *
     * @returns Response wrapped in [[IResultList]]
     *
     * @param {object} filter Object containing filters for querying operations.
     *
     * @example
     * ```typescript
     *
     *  const filter: object = {
     *     pageSize: 100,
     *     withTotalPages: true
     *   };
     *
     *   (async () => {
     *     const {data, res, paging} = await operationService.list(filter);
     *   })();
     * ```
     */
    OperationService.prototype.list = function (filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.list.call(this, filter)];
            });
        });
    };
    /**
     * Gets a list of operations as observable.
     *
     * @param {object} filter Object containing filters for querying
     * @param {object} options To configure the observable
     *
     * @returns Data wrapped as Observable.
     *
     * @example
     * ```typescript
     *
     *   const list$ = operationService.list$();
     *   list$.subscribe((data) => console.log(data));
     * ```
     *
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use [[Realtime]] for realtime connection and
     * rxjs `defer()` or `from()` to composite an observable on your own.
     */
    OperationService.prototype.list$ = function (filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return _super.prototype.list$.call(this, filter, options);
    };
    return OperationService;
}(core.Service));
exports.OperationService = OperationService;

});

unwrapExports(OperationService_1);
var OperationService_2 = OperationService_1.OperationService;

var OperationBulkService_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * This class allows for managing bulk operations.
 */
var OperationBulkService = /** @class */ (function (_super) {
    __extends(OperationBulkService, _super);
    function OperationBulkService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.baseUrl = 'devicecontrol';
        _this.listUrl = 'bulkoperations';
        _this.propertyName = 'bulkOperations';
        return _this;
    }
    /**
     * Gets the details of selected bulk operation.
     *
     * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *    const bulkOperationId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await operationBulkService.detail(bulkOperationId);
     *   })();
     * ```
     */
    OperationBulkService.prototype.detail = function (operationOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.detail.call(this, operationOrId)];
            });
        });
    };
    /**
     * Creates a new operation.
     *
     * @param {Partial<IOperationBulk>} operation Operation object with mandantory fragments.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *  const mandantoryObject: Partial<IOperationBulk> = {
     *    creationRamp: 15,
     *    groupId: '149044',
     *    operationPrototype: {
     *      c8y_Restart: {},
     *      description: 'Restart device',
     *      deviceId: device.id,
     *      status: 'PENDING'
     *    },
     *     startDate: '2018-02-15T16:01:00.000Z'
     *  };
     *
     *  (async () => {
     *    const {data, res} = await operationBulkService.create(mandantoryObject);
     *  })();
     * ```
     */
    OperationBulkService.prototype.create = function (operation) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.create.call(this, operation)];
            });
        });
    };
    /**
     * Updates a new operation.
     *
     * @param {Partial<IOperationBulk>} operation Operation object.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *  const updateObject: Partial<IOperationBulk> = {
     *    creationRamp: 15,
     *    groupId: '149044',
     *    operationPrototype: {
     *      c8y_Restart: {},
     *      description: 'Restart device',
     *      deviceId: device.id,
     *      status: 'PENDING'
     *    },
     *     startDate: '2018-02-15T16:01:00.000Z'
     *  };
     *
     *  (async () => {
     *    const {data, res} = await operationBulkService.update(updateObject);
     *  })();
     * ```
     */
    OperationBulkService.prototype.update = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.update.call(this, entity)];
            });
        });
    };
    /**
     * Gets the list of bulk operations filtered by parameters.
     *
     * @returns Response wrapped in [[IResultList]]
     *
     * @param {object} filter Object containing filters for querying alarms.
     *
     * @example
     * ```typescript
     *
     *  const filter: object = {
     *     pageSize: 100,
     *     withTotalPages: true
     *   };
     *
     *   (async () => {
     *     const {data, res, paging} = await operationBulkService.list(filter);
     *   })();
     * ```
     */
    OperationBulkService.prototype.list = function (filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.list.call(this, filter)];
            });
        });
    };
    /**
     * Gets a list as observable.
     *
     * @param {object} filter Object containing filters for querying
     * @param {object} options To configure the observable
     *
     * @returns Data wrapped as Observable.
     *
     * @example
     * ```typescript
     *
     *   const list$ = operationBulkService.list$();
     *   list$.subscribe((data) => console.log(data));
     * ```
     *
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use [[Realtime]] for realtime connection and
     * rxjs `defer()` or `from()` to composite an observable on your own.
     */
    OperationBulkService.prototype.list$ = function (filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return _super.prototype.list$.call(this, filter, options);
    };
    /**
     * Removes an bulk operation with given id.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {string | number | IIdentified):} operationOrId Operation object or id.
     *
     * @example
     * ```typescript
     *
     *   const id: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await operationBulkService.delete(id);
     *   })();
     * ```
     */
    OperationBulkService.prototype.delete = function (operationOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.delete.call(this, operationOrId)];
            });
        });
    };
    return OperationBulkService;
}(core.Service));
exports.OperationBulkService = OperationBulkService;

});

unwrapExports(OperationBulkService_1);
var OperationBulkService_2 = OperationBulkService_1.OperationBulkService;

var OperationBulkStatus_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * A bulk operation can have one of the following states.
 */
var OperationBulkStatus;
(function (OperationBulkStatus) {
    OperationBulkStatus[OperationBulkStatus["ACTIVE"] = gettext.gettext('ACTIVE')] = "ACTIVE";
    OperationBulkStatus[OperationBulkStatus["IN_PROGRESS"] = gettext.gettext('IN_PROGRESS')] = "IN_PROGRESS";
    OperationBulkStatus[OperationBulkStatus["COMPLETED"] = gettext.gettext('COMPLETED')] = "COMPLETED";
    OperationBulkStatus[OperationBulkStatus["DELETED"] = gettext.gettext('DELETED')] = "DELETED";
})(OperationBulkStatus = exports.OperationBulkStatus || (exports.OperationBulkStatus = {}));

});

unwrapExports(OperationBulkStatus_1);
var OperationBulkStatus_2 = OperationBulkStatus_1.OperationBulkStatus;

var OperationBulkGeneralStatus_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * A bulk operation can have one of the following general statuses.
 */
var OperationBulkGeneralStatus;
(function (OperationBulkGeneralStatus) {
    OperationBulkGeneralStatus[OperationBulkGeneralStatus["SCHEDULED"] = gettext.gettext('SCHEDULED')] = "SCHEDULED";
    OperationBulkGeneralStatus[OperationBulkGeneralStatus["EXECUTING"] = gettext.gettext('EXECUTING')] = "EXECUTING";
    OperationBulkGeneralStatus[OperationBulkGeneralStatus["EXECUTING_WITH_ERROR"] = gettext.gettext('EXECUTING_WITH_ERROR')] = "EXECUTING_WITH_ERROR";
    OperationBulkGeneralStatus[OperationBulkGeneralStatus["CANCELED"] = gettext.gettext('CANCELED')] = "CANCELED";
    OperationBulkGeneralStatus[OperationBulkGeneralStatus["FAILED"] = gettext.gettext('FAILED')] = "FAILED";
    OperationBulkGeneralStatus[OperationBulkGeneralStatus["SUCCESSFUL"] = gettext.gettext('SUCCESSFUL')] = "SUCCESSFUL";
    OperationBulkGeneralStatus[OperationBulkGeneralStatus["DELETED"] = gettext.gettext('DELETED')] = "DELETED";
    OperationBulkGeneralStatus[OperationBulkGeneralStatus["INCORRECT"] = gettext.gettext('INCORRECT')] = "INCORRECT";
})(OperationBulkGeneralStatus = exports.OperationBulkGeneralStatus || (exports.OperationBulkGeneralStatus = {}));

});

unwrapExports(OperationBulkGeneralStatus_1);
var OperationBulkGeneralStatus_2 = OperationBulkGeneralStatus_1.OperationBulkGeneralStatus;

var OperationStatus_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * An Operation can have one of the following states.
 */
var OperationStatus;
(function (OperationStatus) {
    OperationStatus[OperationStatus["PENDING"] = gettext.gettext('PENDING')] = "PENDING";
    OperationStatus[OperationStatus["EXECUTING"] = gettext.gettext('EXECUTING')] = "EXECUTING";
    OperationStatus[OperationStatus["SUCCESSFUL"] = gettext.gettext('SUCCESSFUL')] = "SUCCESSFUL";
    OperationStatus[OperationStatus["FAILED"] = gettext.gettext('FAILED')] = "FAILED";
})(OperationStatus = exports.OperationStatus || (exports.OperationStatus = {}));

});

unwrapExports(OperationStatus_1);
var OperationStatus_2 = OperationStatus_1.OperationStatus;

var operation = createCommonjsModule(function (module, exports) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(OperationService_1);
__export(OperationBulkService_1);
__export(OperationBulkStatus_1);
__export(OperationBulkGeneralStatus_1);
__export(OperationStatus_1);

});

unwrapExports(operation);

var TenantService_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * @description
 * This service allows for managing tenants.
 */
var TenantService = /** @class */ (function (_super) {
    __extends(TenantService, _super);
    function TenantService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.baseUrl = 'tenant';
        _this.listUrl = 'tenants';
        _this.currentTenantUrl = 'currentTenant';
        _this.propertyName = 'tenants';
        _this.fetchOptions = {
            method: 'PUT',
            body: {},
            headers: { 'content-type': 'application/json', accept: 'application/json' }
        };
        return _this;
    }
    /**
     * Get a representation of a tenant.
     *
     * @param {string|number|IIdentified} entityOrId Tenant's id or tenant object.
     *
     * @returns Returns promise object that is resolved with the IIdentified wrapped by IResult.
     *
     * @example
     * ```typescript
     *
     *    const tenantId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await tenantService.detail(tenantId);
     *   })();
     * ```
     *
     * Required role: ROLE_TENANT_MANAGEMENT_READ<br><br>
     * User password is never returned in GET response. Authentication mechanism is provided by another interface.
     */
    TenantService.prototype.detail = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
            });
        });
    };
    /**
     * Creates a new tenant.
     *
     * @param {IIdentified} entity Tenant object.
     *
     * @returns {IResult<IIdentified>} Returns promise object that is resolved with the details of newly created tenant.
     *
     * @example
     * ```typescript
     *
     *  const tenantObject = {
     *    id: "sample_tenant",
     *    company: "sample_company",
     *    domain: "sample_domain.com",
     *    contactName: "Mr. Doe",
     *    ...
     *  };
     *
     *  (async () => {
     *    const {data, res} = await tenantService.create(tenantObject);
     *  })();
     * ```
     *
     * Required role: ROLE_TENANT_MANAGEMENT_ADMIN or ROLE_TENANT_MANAGEMENT_CREATE<br><br>
     * Note that creating a tenant with adminName, adminPass and adminEmail, creates an admin user with these settings.
     * For the tenant id SQL keywords (e.g., select, cross, where) are not allowed.
     */
    TenantService.prototype.create = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.create.call(this, entity)];
            });
        });
    };
    /**
     * Updates tenant data.
     *
     * @param {IIdentified} entity Tenant is partially updatable.
     *
     * @returns {IResult<IIdentified>} Returns promise object that is resolved with the saved tenant object.
     *
     * @example
     * ```typescript
     *
     *  const partialUpdateObject: IIdentified = {
     *     adminName : "newAdmin"
     *     ...
     *   }
     *
     *  (async () => {
     *    const {data, res} = await tenantService.update(partialUpdateObject);
     *  })();
     * ```
     *
     * Required role: ROLE_TENANT_MANAGEMENT_ADMIN or ROLE_TENANT_MANAGEMENT_UPDATE<br><br>
     * Note that updating adminPass and adminEmail updates these settings in the admin user of the tenant.
     * Updating adminName has no effect.
     */
    TenantService.prototype.update = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.update.call(this, entity)];
            });
        });
    };
    /**
     * Gets the list of tenants filtered by parameters.
     *
     * @param {object} filter Object containing filters for querying tenants.
     *
     * @returns Returns promise object that is resolved with the IIdentified wrapped by IResultList.
     *
     * @example
     * ```typescript
     *
     *  const filter: object = {
     *     severity: Severity.MAJOR,
     *     pageSize: 100,
     *     withTotalPages: true
     *   };
     *
     *   (async () => {
     *     const {data, res, paging} = await tenantService.list(filter);
     *   })();
     * ```
     *
     * Required role: ROLE_TENANT_MANAGEMENT_READ
     */
    TenantService.prototype.list = function (filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.list.call(this, filter)];
            });
        });
    };
    /**
     * Gets a list as observable.
     *
     * @param {object} filter Object containing filters for querying
     * @param {object} options To configure the observable
     *
     * @returns Data wrapped as Observable.
     *
     * @example
     * ```typescript
     *
     *   const list$ = tenantService.list$();
     *   list$.subscribe((data) => console.log(data));
     * ```
     *
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use [[Realtime]] for realtime connection and
     * rxjs `defer()` or `from()` to composite an observable on your own.
     */
    TenantService.prototype.list$ = function (filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return _super.prototype.list$.call(this, filter, options);
    };
    /**
     * Delete a representation of a tenant.
     *
     * @param {string|number|IIdentified} entityOrId Tenant's id or tenant object.
     *
     * @returns Returns promise object that is resolved with the IResult.
     *
     * @example
     * ```typescript
     *
     *    const tenantId: string = "uniqueTenantId";
     *
     *    (async () => {
     *      const {data, res} = await tenantService.delete(tenantId);
     *   })();
     * ```
     *
     * Required role: ROLE_TENANT_MANAGEMENT_ADMIN
     */
    TenantService.prototype.delete = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.delete.call(this, entityOrId)];
            });
        });
    };
    TenantService.prototype.current = function () {
        return __awaiter(this, void 0, void 0, function () {
            var headers, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        headers = { 'content-type': 'application/json' };
                        return [4 /*yield*/, this.fetch(this.currentTenantUrl, { headers: headers })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    /**
     * enable support user for current tenant.
     *
     * @returns Returns promise object that is resolved with the IResult.
     *
     * @example
     * ```typescript
     *    (async () => {
     *      const {res} = await tenantService.enableSupportUser();
     *   })();
     * ```
     */
    TenantService.prototype.enableSupportUser = function () {
        return __awaiter(this, void 0, void 0, function () {
            var url, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = 'support-user/enable';
                        return [4 /*yield*/, this.fetch(url, this.fetchOptions)];
                    case 1:
                        res = _a.sent();
                        return [2 /*return*/, { res: res, data: null }];
                }
            });
        });
    };
    /**
     * disable support user for current tenant.
     *
     * @returns Returns promise object that is resolved with the IResult.
     *
     * @example
     * ```typescript
     *    (async () => {
     *      const {res} = await tenantService.disableSupportUser();
     *   })();
     * ```
     */
    TenantService.prototype.disableSupportUser = function () {
        return __awaiter(this, void 0, void 0, function () {
            var url, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = 'support-user/disable';
                        return [4 /*yield*/, this.fetch(url, this.fetchOptions)];
                    case 1:
                        res = _a.sent();
                        return [2 /*return*/, { res: res, data: null }];
                }
            });
        });
    };
    TenantService.prototype.currentTenantType = function () {
        return __awaiter(this, void 0, void 0, function () {
            var tenantData;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.current()];
                    case 1:
                        tenantData = _a.sent();
                        if (tenantData.data.customProperties &&
                            tenantData.data.customProperties.tenantType === 'TRIAL') {
                            return [2 /*return*/, 'TRIAL'];
                        }
                        return [2 /*return*/, 'REGULAR'];
                }
            });
        });
    };
    TenantService.prototype.onBeforeCreate = function (obj) {
        return obj;
    };
    return TenantService;
}(core.Service));
exports.TenantService = TenantService;

});

unwrapExports(TenantService_1);
var TenantService_2 = TenantService_1.TenantService;

var TenantStatus_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

var TenantStatus;
(function (TenantStatus) {
    TenantStatus[TenantStatus["ACTIVE"] = gettext.gettext('ACTIVE')] = "ACTIVE";
    TenantStatus[TenantStatus["SUSPENDED"] = gettext.gettext('SUSPENDED')] = "SUSPENDED";
})(TenantStatus = exports.TenantStatus || (exports.TenantStatus = {}));

});

unwrapExports(TenantStatus_1);
var TenantStatus_2 = TenantStatus_1.TenantStatus;

var tenant = createCommonjsModule(function (module, exports) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(TenantService_1);
__export(TenantStatus_1);

});

unwrapExports(tenant);

var UserInventoryRoleService_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * @description
 * This service allows for managing current user's inventory roles.
 */
var UserInventoryRoleService = /** @class */ (function (_super) {
    __extends(UserInventoryRoleService, _super);
    function UserInventoryRoleService(userUrl, client) {
        var _this = _super.call(this, client) || this;
        _this.listUrl = "inventory";
        _this.currenUserUrl = "currentUser";
        _this.propertyName = 'inventoryAssignments';
        _this.baseUrl = "user/" + userUrl + "/roles";
        return _this;
    }
    /**
     * Get a representation of a concrete current user's inventory role.
     *
     * @param {string|number|IUserInventoryRole} entityOrId inventory role id or inventory role object.
     *
     * @returns Returns promise object that is resolved with the IUserInventoryRole wrapped by IResult.
     *
     * @example
     * ```typescript
     *
     *    const inventoryRoleId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await userInventoryRoleService.detail(inventoryRoleId);
     *   })();
     * ```
     *
     * Required role: ROLE_TENANT_MANAGEMENT_READ<br><br>
     * User password is never returned in GET response. Authentication mechanism is provided by another interface.
     */
    UserInventoryRoleService.prototype.detail = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
            });
        });
    };
    /**
     * Assign inventory role to current user.
     *
     * @param {IUserInventoryRole} entity Inventory Role object.
     *
     * @returns Returns promise object that is resolved with the details of newly assigned inventory role.
     *
     * @example
     * ```typescript
     *
     *  const inventoryRoleObject: IUserInventoryRole = {
     *    ...
     *  };
     *
     *    (async () => {
     *      const {data, res} = await userInventoryRoleService.create(inventoryRoleObject);
     *   })();
     * ```
     */
    UserInventoryRoleService.prototype.create = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.create.call(this, entity)];
            });
        });
    };
    /**
     * Updates an inventory role.
     *
     * @param {Partial<IUserInventoryRole>} entity Inventory Role object.
     */
    UserInventoryRoleService.prototype.update = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.update.call(this, entity)];
            });
        });
    };
    /**
     * Gets the list the inventory roles applied to a current user.
     *
     * @param {object} filter Object containing filters for querying inventory roles.
     *
     * @returns Returns promise object that is resolved with the IUserInventoryRole wrapped by IResultList.
     *
     * @example
     * ```typescript
     *
     *  const filter: object = {
     *     severity: Severity.MAJOR,
     *     pageSize: 100,
     *     withTotalPages: true
     *   };
     *
     *   (async () => {
     *     const {data, res, paging} = await userInventoryRoleService.list(filter);
     *   })();
     * ```
     */
    UserInventoryRoleService.prototype.list = function (filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.list.call(this, filter)];
            });
        });
    };
    /**
     * Gets a list as observable.
     *
     * @param {object} filter Object containing filters for querying
     * @param {object} options To configure the observable
     *
     * @returns Data wrapped as [[ObservableList]]
     *
     * @example
     * ```typescript
     *
     *   const list$ = userInventoryRoleService.list$();
     *   list$.subscribe((data) => console.log(data));
     * ```
     *
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use [[Realtime]] for realtime connection and
     * rxjs `defer()` or `from()` to composite an observable on your own.
     */
    UserInventoryRoleService.prototype.list$ = function (filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return _super.prototype.list$.call(this, filter, options);
    };
    /**
     * Unassign inventory role from current user
     *
     * @param {string|number|IIdentified} entityOrId Inventory Role id or Inventory Role object.
     *
     * @returns Returns promise object that is resolved with the IResult.
     *
     * @example
     * ```typescript
     *
     *    const inventoryRoleId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await userInventoryRoleService.delete(inventoryRoleId);
     *   })();
     * ```
     */
    UserInventoryRoleService.prototype.delete = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.delete.call(this, entityOrId)];
            });
        });
    };
    return UserInventoryRoleService;
}(core.Service));
exports.UserInventoryRoleService = UserInventoryRoleService;

});

unwrapExports(UserInventoryRoleService_1);
var UserInventoryRoleService_2 = UserInventoryRoleService_1.UserInventoryRoleService;

var UserService_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * @description
 * This service allows for managing users.
 */
var UserService = /** @class */ (function (_super) {
    __extends(UserService, _super);
    function UserService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.baseUrl = 'user';
        _this.currentUserUrl = 'currentUser';
        _this.passwordResetUrl = 'passwordReset';
        _this.verifyTFACodeUrl = 'pin';
        _this.totpCurrentUserURL = _this.currentUserUrl + "/totpSecret";
        _this.verifyTOTPCodeUrl = _this.totpCurrentUserURL + "/verify";
        _this.activateTOTPCodeUrl = _this.totpCurrentUserURL + "/activity";
        _this.revokeTOTPSecretUrl = 'totpSecret/revoke';
        _this.propertyName = 'users';
        return _this;
    }
    Object.defineProperty(UserService.prototype, "listUrl", {
        get: function () {
            return this.client.tenant + "/users";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the details of given user.
     *
     * @param {string | number | IUser} entityOrId User's id or user object.
     *
     * @returns Returns promise object that is resolved with the IUser wrapped by IResult.
     *
     * @example
     * ```typescript
     *
     *    const userId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await userService.detail(userId);
     *   })();
     * ```
     * User password is never returned in GET response. Authentication mechanism is provided by another interface.
     */
    UserService.prototype.detail = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
            });
        });
    };
    /**
     * Creates a new user.
     *
     * @param {IUser} entity User object.
     *
     * @returns {IResult<IUser>} Returns promise object that is resolved with the details of newly created user.
     *
     * @example
     * ```typescript
     *
     *  const userObject: IUser = {
     *    userName: "newUser",
     *    password: "userPassword12!@"
     *  };
     *
     *  (async () => {
     *    const {data, res} = await userService.create(userObject);
     *  })();
     * ```
     */
    UserService.prototype.create = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.create.call(this, entity)];
            });
        });
    };
    /**
     * Updates user data.
     *
     * @param {Partial<IUser>} entity User is partially updatable.
     *
     * @returns {IResult<IUserGroup>} Returns promise object that is resolved with the saved user object.
     *
     * @example
     * ```typescript
     *
     *  const partialUpdateObject: Partial<IUser> = {
     *     "id" : "myuser",
     *     "userName" : "newUserName",
     *     "email": "newUserEmail@example.com"
     *     ...
     *   }
     *
     *  (async () => {
     *    const {data, res} = await userService.update(partialUpdateObject);
     *  })();
     * ```
     * When user is updated with changed permissions or groups, suitable audit record is created with type
     * 'User' and activity 'User updated'.
     */
    UserService.prototype.update = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.update.call(this, entity)];
            });
        });
    };
    /**
     * Gets the list of users filtered by parameters.
     *
     * @param {object} filter Object containing filters for querying users.
     *
     * @returns Returns promise object that is resolved with the IUser wrapped by IResultList.
     *
     * @example
     * ```typescript
     *
     *  const filter: object = {
     *     pageSize: 100,
     *     withTotalPages: true
     *   };
     *
     *   (async () => {
     *     const {data, res, paging} = await userService.list(filter);
     *   })();
     * ```
     */
    UserService.prototype.list = function (filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.list.call(this, filter)];
            });
        });
    };
    /**
     * Gets a list as observable.
     *
     * @param {object} filter Object containing filters for querying
     * @param {object} options To configure the observable
     *
     * @returns Data wrapped as Observable.
     *
     * @example
     * ```typescript
     *
     *   const list$ = userInventoryRoleService.list$();
     *   list$.subscribe((data) => console.log(data));
     * ```
     *
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use [[Realtime]] for realtime connection and
     * rxjs `defer()` or `from()` to composite an observable on your own.
     */
    UserService.prototype.list$ = function (filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return _super.prototype.list$.call(this, filter, options);
    };
    /**
     * Removes user.
     *
     * @param {number|IIdentified} entityOrId User's id or user object.
     *
     * @returns Returns promise object that is resolved with the IResult of null.
     *
     * @example
     * ```typescript
     *
     *    const userId: string = "uniqueUserId";
     *
     *    (async () => {
     *      const {data, res} = await userService.delete(userGroupId);
     *   })();
     * ```
     */
    UserService.prototype.delete = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.delete.call(this, entityOrId)];
            });
        });
    };
    /**
     * Create instance of User Inventory Role Service related with given User.
     *
     * @param {string|number|IUser} entityOrId User's id or user object.
     *
     * @returns Returns UserInventoryRoleService object that is related with given User.
     *
     * @example
     * ```typescript
     *
     *    const userId: string = "uniqueUserId";
     *
     *    const userInventoryRoleService = userService.inventoryAssignment(userGroupId);
     *    (async () => {
     *      const {data, res} = await userInventoryRoleService.create(...);
     *   })();
     * ```
     */
    UserService.prototype.inventoryAssignment = function (entityOrId) {
        return new UserInventoryRoleService_1.UserInventoryRoleService(this.getDetailUrl(entityOrId), this.client);
    };
    /**
     * Gets user that is currently logged in.
     *
     * @returns Returns promise object that is resolved with the IUser wrapped by IResult.
     *
     * @example
     * ```typescript
     *
     *    (async () => {
     *      const {data, res} = await userService.current();
     *   })();
     * ```
     */
    UserService.prototype.current = function () {
        return __awaiter(this, void 0, void 0, function () {
            var headers, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        headers = {
                            'content-type': 'application/json',
                            Accept: 'application/vnd.com.nsn.cumulocity.user+json;'
                        };
                        return [4 /*yield*/, this.fetch(this.currentUserUrl, { headers: headers })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    /**
     * Gets user that is currently logged in with the list of all roles assigned.
     *
     * @returns Returns promise object that is resolved with the ICurrenUser wrapped by IResult.
     *
     * @example
     * ```typescript
     *
     *    (async () => {
     *      const {data, res} = await userService.currentWithEffectiveRoles();
     *   })();
     * ```
     */
    UserService.prototype.currentWithEffectiveRoles = function () {
        return __awaiter(this, void 0, void 0, function () {
            var headers, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        headers = {
                            'content-type': 'application/json',
                            Accept: 'application/vnd.com.nsn.cumulocity.currentUser+json;'
                        };
                        return [4 /*yield*/, this.fetch(this.currentUserUrl, { headers: headers })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    /**
     * Updates the current user
     *
     * @param {IUser} user The user object with the properties to be updated
     *
     * @return Returns promise object resolved with the IUser wrapped by IResult
     */
    UserService.prototype.updateCurrent = function (user) {
        return __awaiter(this, void 0, void 0, function () {
            var mimeType, headers, body, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        mimeType = 'application/vnd.com.nsn.cumulocity.user+json';
                        headers = { 'content-type': mimeType, Accept: mimeType };
                        body = JSON.stringify(this.onBeforeUpdate(user));
                        return [4 /*yield*/, this.fetch(this.currentUserUrl, { headers: headers, body: body, method: 'PUT' })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    /**
     * Sends an email message with a link allowing user to reset their password.
     *
     * @param {string} email The email address to send the message to.
     * @param {string} tenantId The id of user's tenant (if cannot be inferred from URL).
     *
     * @returns Returns a request result object.
     *
     * @example
     * ```typescript
     *   const email = 'user@example.com';
     *   const tenantId = 't123456';
     *
     *   (async () => {
     *     const { res, data } = await userService.sendPasswordResetMail(email, tenantId);
     *   })();
     * ```
     */
    UserService.prototype.sendPasswordResetMail = function (email, tenantId) {
        return __awaiter(this, void 0, void 0, function () {
            var headers, method, url, params, body, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        headers = { 'content-type': 'application/json', accept: 'application/json' };
                        method = 'POST';
                        url = this.passwordResetUrl;
                        params = tenantId ? { tenantId: tenantId } : {};
                        body = JSON.stringify({ email: email });
                        return [4 /*yield*/, this.fetch(url, { headers: headers, method: method, params: params, body: body })];
                    case 1:
                        res = _a.sent();
                        return [2 /*return*/, { res: res, data: null }];
                }
            });
        });
    };
    /**
     * Resets user's password to a new one.
     *
     * @param {IResetPassword} newPassword Object with token, user's email, new password and its strength indicator.
     * @param {string} tenantId The id of user's tenant (if cannot be inferred from URL).
     *
     * @returns Returns a request result object.
     *
     * @example
     * ```typescript
     *   const newPassword: IResetPassword = {
     *     token: '123123ASDAWERER@#!WEDS$@#!WADA#A#EA#EA#EA',
     *     email: 'user@example.com',
     *     newPassword: 'myNewPassword',
     *     passwordStrength: PasswordStrength.GREEN
     *   };
     *   const tenantId = 't123456';
     *
     *   (async () => {
     *     const { res, data } = await userService.resetPassword(newPassword, tenantId);
     *   })();
     * ```
     */
    UserService.prototype.resetPassword = function (newPassword, tenantId) {
        return __awaiter(this, void 0, void 0, function () {
            var headers, method, url, params, body, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        headers = { 'content-type': 'application/json', accept: 'application/json' };
                        method = 'PUT';
                        url = this.passwordResetUrl;
                        params = tenantId ? { tenantId: tenantId } : {};
                        body = JSON.stringify(newPassword);
                        return [4 /*yield*/, this.fetch(url, { headers: headers, method: method, params: params, body: body })];
                    case 1:
                        res = _a.sent();
                        return [2 /*return*/, { res: res, data: null }];
                }
            });
        });
    };
    /**
     * Verifies TFA code which is sent via SMS. If invoked with string '0', new TFA code will be sent.
     *
     * @param {string} pin The code to verify.
     *
     * @returns Returns a status object.
     *
     * @example
     * ```typescript
     *
     *    (async () => {
     *      const {data, res} = await userService.verifyTFACode('123123');
     *   })();
     * ```
     */
    UserService.prototype.verifyTFACode = function (pin) {
        return __awaiter(this, void 0, void 0, function () {
            var method, body, headers, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        method = 'POST';
                        body = JSON.stringify({ pin: pin });
                        headers = { 'content-type': 'application/json', accept: 'application/json' };
                        return [4 /*yield*/, this.fetch(this.verifyTFACodeUrl, { headers: headers, body: body, method: method })];
                    case 1:
                        res = _a.sent();
                        return [2 /*return*/, { res: res, data: null }];
                }
            });
        });
    };
    /**
     * Verifies TFA code which is generated by a TOTP app.
     *
     * @param {string} code The code to verify.
     *
     * @returns Returns a status object.
     *
     * @example
     * ```typescript
     *
     *    (async () => {
     *      const {data, res} = await userService.verifyTotpCode('123123');
     *   })();
     * ```
     */
    UserService.prototype.verifyTotpCode = function (code) {
        return __awaiter(this, void 0, void 0, function () {
            var method, headers, body, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        method = 'POST';
                        headers = { 'content-type': 'application/json' };
                        body = JSON.stringify({ code: code });
                        return [4 /*yield*/, this.fetch(this.verifyTOTPCodeUrl, { headers: headers, body: body, method: method })];
                    case 1:
                        res = _a.sent();
                        return [2 /*return*/, { res: res, data: null }];
                }
            });
        });
    };
    /**
     * Verifies TFA code which is generated by a TOTP app.
     *
     * @returns Returns a status object.
     *
     * @example
     * ```typescript
     *
     *    (async () => {
     *      const {data, res} = await userService.activateTotp();
     *   })();
     * ```
     */
    UserService.prototype.activateTotp = function () {
        return __awaiter(this, void 0, void 0, function () {
            var method, headers, body, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        method = 'POST';
                        headers = { 'content-type': 'application/json' };
                        body = JSON.stringify({ isActive: true });
                        return [4 /*yield*/, this.fetch(this.activateTOTPCodeUrl, { headers: headers, body: body, method: method })];
                    case 1:
                        res = _a.sent();
                        return [2 /*return*/, { res: res, data: null }];
                }
            });
        });
    };
    /**
     * Checks if TOTP is activated and enforced.
     *
     * @returns Returns an object of ITotpStatus if it is active.
     *
     * @example
     * ```typescript
     *
     *    (async () => {
     *      const {data, res} = await userService.getActivityTotp();
     *      console.log(data.isActive);
     *   })();
     * ```
     */
    UserService.prototype.getActivityTotp = function () {
        return __awaiter(this, void 0, void 0, function () {
            var method, headers, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        method = 'GET';
                        headers = { 'content-type': 'application/json' };
                        return [4 /*yield*/, this.fetch(this.activateTOTPCodeUrl, { headers: headers, method: method })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    /**
     * Generates a secret which can be used to setup two-factor authentication with TOTP.
     *
     * @returns Returns the secret and an URL to a QR Code.
     *
     * @example
     * ```typescript
     *
     *    (async () => {
     *      const {data, res} = await userService.generateTotpSecret();
     *      console.log(secret);
     *   })();
     * ```
     */
    UserService.prototype.generateTotpSecret = function () {
        return __awaiter(this, void 0, void 0, function () {
            var method, headers, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        method = 'POST';
                        headers = { 'content-type': 'application/json', accept: 'application/json' };
                        return [4 /*yield*/, this.fetch(this.totpCurrentUserURL, { headers: headers, method: method })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    /**
     * Revokes a specific user's TOTP secret.
     *
     * @param {IUser} user User whose TOTP secret to revoke.
     *
     * @returns Status object
     */
    UserService.prototype.totpRevokeSecret = function (user) {
        return __awaiter(this, void 0, void 0, function () {
            var url, method, headers, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.getDetailUrl(user) + "/" + this.revokeTOTPSecretUrl;
                        method = 'DELETE';
                        headers = { accept: 'application/json' };
                        return [4 /*yield*/, this.fetch(url, { headers: headers, method: method })];
                    case 1:
                        res = _a.sent();
                        return [2 /*return*/, { res: res, data: null }];
                }
            });
        });
    };
    /**
     * Update user phone number.
     * @param {string} phoneNumber provided phone number by user
     */
    UserService.prototype.savePhoneNumber = function (phoneNumber) {
        return __awaiter(this, void 0, void 0, function () {
            var url, options, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = 'user/currentUserPhone';
                        options = {
                            method: 'PUT',
                            headers: { 'content-type': 'application/json', accept: 'application/json' },
                            body: JSON.stringify({
                                phone: phoneNumber
                            })
                        };
                        return [4 /*yield*/, this.client.fetch(url, options)];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    UserService.prototype.hasRole = function (user, roleId) {
        return this.hasRoleInUser(user, roleId) || this.hasRoleInGroups(user, roleId);
    };
    UserService.prototype.hasAllRoles = function (user, roleIds) {
        var _this = this;
        return roleIds.every(function (roleId) { return _this.hasRole(user, roleId); });
    };
    UserService.prototype.hasAnyRole = function (user, roleIds) {
        var _this = this;
        return roleIds.some(function (roleId) { return _this.hasRole(user, roleId); });
    };
    UserService.prototype.onBeforeUpdate = function (user) {
        var obj = Object.assign({}, user);
        delete obj.id;
        delete obj.userName;
        return obj;
    };
    UserService.prototype.getDetailUrl = function (entityOrId) {
        var id;
        if (typeof entityOrId === 'object' && entityOrId.id) {
            id = entityOrId.id;
        }
        else if (typeof entityOrId === 'object' && entityOrId.userName) {
            id = entityOrId.userName;
        }
        else {
            id = entityOrId;
        }
        return this.listUrl + "/" + encodeURIComponent(String(id));
    };
    UserService.prototype.hasRoleInUser = function (user, roleId) {
        var effectiveRoles = user.effectiveRoles || [];
        return (this.hasRoleInReferences((user && user.roles && user.roles.references) || [], roleId) ||
            effectiveRoles.some(function (_a) {
                var id = _a.id;
                return roleId === id;
            }));
    };
    UserService.prototype.hasRoleInGroups = function (user, roleId) {
        var _this = this;
        var groupReferences = (user && user.groups && user.groups.references) || [];
        return groupReferences.some(function (groupRef) {
            return _this.hasRoleInReferences(groupRef.group.roles.references, roleId);
        });
    };
    UserService.prototype.hasRoleInReferences = function (references, roleId) {
        return references.some(function (ref) { return ref.role.id === roleId; });
    };
    return UserService;
}(core.Service));
exports.UserService = UserService;

});

unwrapExports(UserService_1);
var UserService_2 = UserService_1.UserService;

var PasswordStrength_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var PasswordStrength;
(function (PasswordStrength) {
    PasswordStrength["GREEN"] = "GREEN";
    PasswordStrength["RED"] = "RED";
    PasswordStrength["YELLOW"] = "YELLOW";
})(PasswordStrength = exports.PasswordStrength || (exports.PasswordStrength = {}));

});

unwrapExports(PasswordStrength_1);
var PasswordStrength_2 = PasswordStrength_1.PasswordStrength;

var user = createCommonjsModule(function (module, exports) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(UserService_1);
__export(UserInventoryRoleService_1);
__export(PasswordStrength_1);

});

unwrapExports(user);

var ApplicationBinaryService_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });

var form_data_1 = __importDefault(browser$1);
var ApplicationBinaryService = /** @class */ (function (_super) {
    __extends(ApplicationBinaryService, _super);
    function ApplicationBinaryService(client, applicationOrId) {
        var _this = _super.call(this, client) || this;
        _this.listUrl = 'binaries';
        _this.propertyName = 'attachments';
        _this.baseUrl = "application/applications/" + _this.getIdString(applicationOrId);
        return _this;
    }
    ApplicationBinaryService.prototype.upload = function (binary, fileName) {
        return __awaiter(this, void 0, void 0, function () {
            var url, method, body, bufferOrStream, uploadFileName, bodyHeaders, headers, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.listUrl;
                        method = 'POST';
                        body = new form_data_1.default();
                        bufferOrStream = binary instanceof ArrayBuffer ? Buffer.from(binary) : binary;
                        uploadFileName = fileName;
                        if (typeof (File) !== 'undefined' && binary instanceof File) {
                            uploadFileName = binary.name;
                        }
                        body.append('file', bufferOrStream, uploadFileName);
                        body.append('fileName', uploadFileName);
                        if (typeof body.getHeaders === 'function') {
                            bodyHeaders = body.getHeaders();
                        }
                        headers = Object.assign({
                            accept: 'application/json'
                        }, bodyHeaders);
                        return [4 /*yield*/, this.fetch(url, { method: method, body: body, headers: headers })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    ApplicationBinaryService.prototype.list = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.list.call(this)];
            });
        });
    };
    ApplicationBinaryService.prototype.list$ = function (filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return _super.prototype.list$.call(this, filter, options);
    };
    ApplicationBinaryService.prototype.delete = function (binaryOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.delete.call(this, binaryOrId)];
            });
        });
    };
    ApplicationBinaryService.prototype.listPlugins = function () {
        return __awaiter(this, void 0, void 0, function () {
            var headers, url, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        headers = { accept: 'application/json' };
                        url = this.listUrl + "/plugins";
                        return [4 /*yield*/, this.fetch(url, { headers: headers })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    ApplicationBinaryService.prototype.addPlugin = function (pluginName, pluginFile) {
        return __awaiter(this, void 0, void 0, function () {
            var url, method, body, bufferOrStream, bodyHeaders, headers, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.listUrl + "/plugins/" + encodeURIComponent(pluginName);
                        method = 'POST';
                        body = new form_data_1.default();
                        bufferOrStream = pluginFile instanceof ArrayBuffer ? Buffer.from(pluginFile) : pluginFile;
                        body.append('file', bufferOrStream);
                        if (typeof body.getHeaders === 'function') {
                            bodyHeaders = body.getHeaders();
                        }
                        headers = Object.assign({
                            accept: 'application/json'
                        }, bodyHeaders);
                        return [4 /*yield*/, this.fetch(url, { method: method, body: body, headers: headers })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    ApplicationBinaryService.prototype.removePlugin = function (pluginName) {
        return __awaiter(this, void 0, void 0, function () {
            var method, headers, url, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        method = 'DELETE';
                        headers = { accept: 'application/json' };
                        url = this.listUrl + "/plugins/" + pluginName;
                        return [4 /*yield*/, this.fetch(url, { method: method, headers: headers })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    ApplicationBinaryService.prototype.updateFiles = function (files) {
        return __awaiter(this, void 0, void 0, function () {
            var url, method, body, bodyHeaders, headers, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.listUrl + "/files";
                        method = 'POST';
                        body = new form_data_1.default();
                        files.forEach(function (file) {
                            var bufferOrStream = file.contents instanceof ArrayBuffer ? Buffer.from(file.contents) : file.contents;
                            body.append(file.path, bufferOrStream);
                        });
                        if (typeof body.getHeaders === 'function') {
                            bodyHeaders = body.getHeaders();
                        }
                        headers = Object.assign({
                            accept: 'application/json'
                        }, bodyHeaders);
                        return [4 /*yield*/, this.fetch(url, { method: method, body: body, headers: headers })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    return ApplicationBinaryService;
}(core.Service));
exports.ApplicationBinaryService = ApplicationBinaryService;

});

unwrapExports(ApplicationBinaryService_1);
var ApplicationBinaryService_2 = ApplicationBinaryService_1.ApplicationBinaryService;

var ApplicationType_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var ApplicationType;
(function (ApplicationType) {
    ApplicationType["EXTERNAL"] = "EXTERNAL";
    ApplicationType["HOSTED"] = "HOSTED";
    ApplicationType["MICROSERVICE"] = "MICROSERVICE";
    ApplicationType["FEATURE"] = "FEATURE";
})(ApplicationType = exports.ApplicationType || (exports.ApplicationType = {}));

});

unwrapExports(ApplicationType_1);
var ApplicationType_2 = ApplicationType_1.ApplicationType;

var ApplicationService_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });





var ApplicationService = /** @class */ (function (_super) {
    __extends(ApplicationService, _super);
    function ApplicationService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.baseUrl = 'application';
        _this.listUrl = 'applications';
        _this.propertyName = 'applications';
        _this.channel = '/applications/*';
        return _this;
    }
    /**
     * Creates a new application.
     *
     * @param {IIdentified} entity Application object.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *  const newApp = {
     *    name: 'New application',
     *    type: 'EXTERNAL',
     *    key: 'new-app'
     *  };
     *
     *  (async () => {
     *    const {data, res} = await applicationService.create(newApp);
     *  })();
     * ```
     */
    ApplicationService.prototype.create = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.create.call(this, entity)];
            });
        });
    };
    ApplicationService.prototype.clone = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            var url, method, body, headers, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.getDetailUrl(entity) + "/clone";
                        method = 'POST';
                        body = '';
                        headers = { 'content-type': 'application/json', accept: 'application/json' };
                        return [4 /*yield*/, this.fetch(url, { method: method, body: body, headers: headers })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    /**
     * Gets the list of existing applications filtered by parameters.
     *
     * @returns Response wrapped in [[IResultList]]
     *
     * @param {object} filter Object containing filters for querying applications.
     *
     * @example
     * ```typescript
     *
     *  const filter: object = {
     *     pageSize: 100,
     *     withTotalPages: true
     *   };
     *
     *   (async () => {
     *     const {data, res, paging} = await applicationService.list(filter);
     *   })();
     * ```
     */
    ApplicationService.prototype.list = function (filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.list.call(this, filter)];
            });
        });
    };
    /**
     * Gets a list as observable.
     *
     * @param {object} filter Object containing filters for querying
     * @param {object} options To configure the observable
     *
     * @returns Data wrapped as [[ObservableList]]
     *
     * @example
     * ```typescript
     *
     *   const list$ = alarmService.list$();
     *   list$.subscribe((data) => console.log(data));
     * ```
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use [[Realtime]] for realtime connection and
     * rxjs `defer()` or `from()` to composite an observable on your own.
     */
    ApplicationService.prototype.list$ = function (filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return _super.prototype.list$.call(this, filter, options);
    };
    /**
     * Gets the details of selected application.
     *
     * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *    const applicationId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await applicationService.detail(applicationId);
     *   })();
     * ```
     */
    ApplicationService.prototype.detail = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
            });
        });
    };
    /**
     * Updates existing application.
     * Make sure that you specifiy the application id within the update object.
     *
     * @param {IIdentified} entity Application object.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *  const updateApp = {
     *    id: 38
     *    name: 'Updated application'
     *  };
     *
     *  (async () => {
     *    const {data, res} = await applicationService.update(updateApp);
     *  })();
     * ```
     */
    ApplicationService.prototype.update = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.update.call(this, entity)];
            });
        });
    };
    /**
     * Removes an application with given id.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {string | number | IIdentified} entityOrId entity or id of the application.
     *
     * @example
     * ```typescript
     *
     *  const removeApp: object = {
     *     id: 38
     *   };
     *
     *   (async () => {
     *     const {data, res} = await applicationService.delete(removeApp);
     *     // data will be null
     *   })();
     * ```
     */
    ApplicationService.prototype.delete = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.delete.call(this, entityOrId)];
            });
        });
    };
    ApplicationService.prototype.listByName = function (name) {
        return __awaiter(this, void 0, void 0, function () {
            var headers, url, res, json, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        headers = { 'content-type': 'application/json' };
                        url = "applicationsByName/" + encodeURIComponent(name);
                        return [4 /*yield*/, this.fetch(url, { headers: headers })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        json = _a.sent();
                        data = json[this.propertyName];
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    ApplicationService.prototype.listByTenant = function (tenantOrName, params) {
        if (params === void 0) { params = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var headers, tenantService, tenantName, _a, _b, url, res, json, data;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        headers = { 'content-type': 'application/json' };
                        tenantService = new tenant.TenantService(this.client);
                        _a = this.getIdString;
                        _b = tenantOrName;
                        if (_b) return [3 /*break*/, 2];
                        return [4 /*yield*/, tenantService.current()];
                    case 1:
                        _b = (_c.sent()).data.name;
                        _c.label = 2;
                    case 2:
                        tenantName = _a.apply(this, [_b]);
                        url = "applicationsByTenant/" + encodeURIComponent(tenantName);
                        return [4 /*yield*/, this.fetch(url, { headers: headers, params: params })];
                    case 3:
                        res = _c.sent();
                        return [4 /*yield*/, res.json()];
                    case 4:
                        json = _c.sent();
                        data = json[this.propertyName];
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    ApplicationService.prototype.listByOwner = function (tenantOrName, params) {
        if (params === void 0) { params = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var headers, tenantService, tenantName, _a, _b, url, res, json, data;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        headers = { 'content-type': 'application/json' };
                        tenantService = new tenant.TenantService(this.client);
                        _a = this.getIdString;
                        _b = tenantOrName;
                        if (_b) return [3 /*break*/, 2];
                        return [4 /*yield*/, tenantService.current()];
                    case 1:
                        _b = (_c.sent()).data.name;
                        _c.label = 2;
                    case 2:
                        tenantName = _a.apply(this, [_b]);
                        url = "applicationsByOwner/" + encodeURIComponent(tenantName);
                        return [4 /*yield*/, this.fetch(url, { headers: headers, params: params })];
                    case 3:
                        res = _c.sent();
                        return [4 /*yield*/, res.json()];
                    case 4:
                        json = _c.sent();
                        data = json[this.propertyName];
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    ApplicationService.prototype.listByUser = function (userOrId, params) {
        if (params === void 0) { params = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var headers, userService, userId, _a, _b, url, res, json, data;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        headers = { 'content-type': 'application/json' };
                        userService = new user.UserService(this.client);
                        _a = this.getIdString;
                        _b = userOrId;
                        if (_b) return [3 /*break*/, 2];
                        return [4 /*yield*/, userService.current()];
                    case 1:
                        _b = (_c.sent()).data;
                        _c.label = 2;
                    case 2:
                        userId = _a.apply(this, [_b]);
                        url = "applicationsByUser/" + encodeURIComponent(userId);
                        return [4 /*yield*/, this.fetch(url, { headers: headers, params: params })];
                    case 3:
                        res = _c.sent();
                        return [4 /*yield*/, res.json()];
                    case 4:
                        json = _c.sent();
                        data = json[this.propertyName];
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    ApplicationService.prototype.binary = function (application) {
        return new ApplicationBinaryService_1.ApplicationBinaryService(this.client, application);
    };
    ApplicationService.prototype.getHref = function (application) {
        if (application.type === ApplicationType_1.ApplicationType.EXTERNAL) {
            return application.externalUrl;
        }
        return "/apps/" + (application.public ? 'public/' : '') + application.contextPath;
    };
    /**
     * Checks if current user can access specified application.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {string | IApplication} application Application name or contextPath as a
     * string or Application object.
     *
     * @example
     * ```typescript
     *
     *  const checkApp: object = {
     *    name: 'myApplication'
     *  };
     *
     *  (async () => {
     *    const {data, res} = await applicationService.isAvailable(checkApp);
     *  })();
     * ```
     */
    ApplicationService.prototype.isAvailable = function (application) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, res, data, available;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.listByUser(undefined, {
                            dropOverwrittenApps: true,
                            noPaging: true
                        })];
                    case 1:
                        _a = _b.sent(), res = _a.res, data = _a.data;
                        available = (data || []).some(function (availableApp) {
                            return typeof application === 'string'
                                ? availableApp.name === application || availableApp.contextPath === application
                                : _this.isMatch(availableApp, application);
                        });
                        return [2 /*return*/, { data: available, res: res }];
                }
            });
        });
    };
    ApplicationService.prototype.isMatch = function (object, source) {
        var _this = this;
        return Object.keys(source).every(function (key) {
            if (Array.isArray(object[key]) && Array.isArray(source[key])) {
                return source[key].every(function (el) { return object[key].includes(el); });
            }
            else if (typeof object[key] === 'object' &&
                object[key] !== null &&
                typeof source[key] === 'object' &&
                source[key] !== null) {
                return _this.isMatch(object[key], source[key]);
            }
            else {
                return object[key] === source[key];
            }
        });
    };
    return ApplicationService;
}(core.Service));
exports.ApplicationService = ApplicationService;

});

unwrapExports(ApplicationService_1);
var ApplicationService_2 = ApplicationService_1.ApplicationService;

var ApplicationAvailability_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

var ApplicationAvailability;
(function (ApplicationAvailability) {
    ApplicationAvailability[ApplicationAvailability["MARKET"] = gettext.gettext('MARKET')] = "MARKET";
    ApplicationAvailability[ApplicationAvailability["PRIVATE"] = gettext.gettext('PRIVATE')] = "PRIVATE";
})(ApplicationAvailability = exports.ApplicationAvailability || (exports.ApplicationAvailability = {}));

});

unwrapExports(ApplicationAvailability_1);
var ApplicationAvailability_2 = ApplicationAvailability_1.ApplicationAvailability;

var application = createCommonjsModule(function (module, exports) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(ApplicationService_1);
__export(ApplicationType_1);
__export(ApplicationAvailability_1);

});

unwrapExports(application);

var SystemOptionsService_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });

var SystemOptionsService = /** @class */ (function (_super) {
    __extends(SystemOptionsService, _super);
    function SystemOptionsService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.baseUrl = 'tenant/system';
        _this.listUrl = 'options';
        _this.propertyName = 'options';
        return _this;
    }
    /**
     * Gets the details of given system option.
     *
     * @param {string|number|IIdentified} option System option object with mandantory fragments.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *    const option: ISystemOption = {
     *      category: 'alarm.type.mapping',
     *      key: 'temp_to_high'
     *    };
     *
     *    (async () => {
     *      const {data, res} = await systemOptionsService.detail(option);
     *   })();
     * ```
     */
    SystemOptionsService.prototype.detail = function (option) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.detail.call(this, option)];
            });
        });
    };
    /**
     * Gets the list of system options filtered by parameters.
     *
     * @returns Response wrapped in [[IResultList]]
     *
     * @param {object} filter Object containing filters for querying system options.
     *
     * @example
     * ```typescript
     *
     *  const filter: object = {
     *     pageSize: 100,
     *     withTotalPages: true
     *   };
     *
     *   (async () => {
     *     const {data, res, paging} = await systemOptionsService.list(filter);
     *   })();
     * ```
     */
    SystemOptionsService.prototype.list = function (filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var headers, url, res, json, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        headers = { 'content-type': 'application/json' };
                        url = this.listUrl;
                        return [4 /*yield*/, this.fetch(url, { headers: headers, params: filter })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        json = _a.sent();
                        data = json[this.propertyName];
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    SystemOptionsService.prototype.getDetailUrl = function (option) {
        return this.listUrl + "/" + option.category + "/" + option.key;
    };
    SystemOptionsService.prototype.onBeforeCreate = function (obj) {
        return obj;
    };
    return SystemOptionsService;
}(core.Service));
exports.SystemOptionsService = SystemOptionsService;

});

unwrapExports(SystemOptionsService_1);
var SystemOptionsService_2 = SystemOptionsService_1.SystemOptionsService;

var systemOptions = createCommonjsModule(function (module, exports) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(SystemOptionsService_1);

});

unwrapExports(systemOptions);

var TenantOptionsService_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * @description
 * This service allows for managing tenant's options.
 */
var TenantOptionsService = /** @class */ (function (_super) {
    __extends(TenantOptionsService, _super);
    function TenantOptionsService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.baseUrl = 'tenant';
        _this.listUrl = 'options';
        _this.propertyName = 'options';
        _this.securityOptionsCategories = ['password'];
        _this.securityOptionsListUrl = 'security-options';
        _this.systemOptions = 'system';
        return _this;
    }
    /**
     * Get a representation of a tenant's option.
     *
     * @param {ITenantOption} entity Tenant option object.
     *
     * @returns {IResult<ITenantOption>} Returns promise object that is resolved with
     * the ITenantOption wrapped by IResult.
     *
     * @example
     * ```typescript
     *
     *    const option: ITenantOption = {
     *      category: 'access.control',
     *      key: 'allow.origin'
     *    };
     *
     *    (async () => {
     *      const {data, res} = await tenantService.detail(option);
     *   })();
     * ```
     *
     * Required role: ROLE_OPTION_MANAGEMENT_READ
     */
    TenantOptionsService.prototype.detail = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.detail.call(this, entity)];
            });
        });
    };
    /**
     * Creates a new tenant's option.
     *
     * @param {ITenantOption} entity Tenant's Option object.
     *
     * @returns {IResult<IIdentified>} Returns promise object that is resolved with
     * the details of newly created tenant option.
     *
     * @example
     * ```typescript
     *
     *  const tenantObject = {
     *    id: "sample_tenant",
     *    company: "sample_company",
     *    domain: "sample_domain.com",
     *    contactName: "Mr. Doe",
     *    ...
     *  };
     *
     *  (async () => {
     *    const {data, res} = await tenantService.create(tenantObject);
     *  })();
     * ```
     *
     * Required role: ROLE_OPTION_MANAGEMENT_ADMIN<br><br>
     * Options are category-key-value tuples, storing tenant configuration.Some categories of options
     * allow creation of new one, other are limited to predefined set of keys.<br><br>
     * Any option of any tenant can be defined as "non-editable" by "management" tenant. Afterwards, any PUT or DELETE
     * requests made on that option by the owner tenant, will result in 403 error (Unauthorized).
     */
    TenantOptionsService.prototype.create = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.create.call(this, entity)];
            });
        });
    };
    /**
     * Updates tenant's option data.
     *
     * @param {ITenantOption} entity Tenant option is partially updatable.
     *
     * @returns {IResult<ITenantOption>} Returns promise object that is resolved with the saved tenant option object.
     *
     * @example
     * ```typescript
     *
     *  const partialUpdateObject: IIdentified = {
     *     value : "http://developer.cumulocity.com"
     *     ...
     *   }
     *
     *  (async () => {
     *    const {data, res} = await tenantOptionsService.update(partialUpdateObject);
     *  })();
     * ```
     *
     * Required role: ROLE_OPTION_MANAGEMENT_ADMIN
     */
    TenantOptionsService.prototype.update = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.update.call(this, entity)];
            });
        });
    };
    /**
     * Gets the list of tenant's options filtered by parameters.
     *
     * @param {object} filter Object containing filters for querying tenant options.
     *
     * @returns {IResultList<ITenantOption>} Returns promise object that is resolved
     * with the ITenantOption wrapped by IResultList.
     *
     * @example
     * ```typescript
     *
     *  const filter: object = {
     *     severity: Severity.MAJOR,
     *     pageSize: 100,
     *     withTotalPages: true
     *   };
     *
     *   (async () => {
     *     const {data, res, paging} = await tenantOptionsService.list(filter);
     *   })();
     * ```
     *
     * Required role: ROLE_OPTION_MANAGEMENT_READ
     */
    TenantOptionsService.prototype.list = function (filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.list.call(this, filter)];
            });
        });
    };
    /**
     * Gets a list as observable.
     *
     * @param {object} filter Object containing filters for querying
     * @param {object} options To configure the observable
     *
     * @returns Data wrapped as Observable.
     *
     * @example
     * ```typescript
     *
     *   const list$ = tenantOptionsService.list$();
     *   list$.subscribe((data) => console.log(data));
     * ```
     *
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use [[Realtime]] for realtime connection and
     * rxjs `defer()` or `from()` to composite an observable on your own.
     */
    TenantOptionsService.prototype.list$ = function (filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return _super.prototype.list$.call(this, filter, options);
    };
    /**
     * Delete a representation of a tenant's option.
     *
     * @param {string|number|IIdentified} entityOrId Tenant's option id or tenant's option object.
     *
     * @returns Returns promise object that is resolved with the IResult.
     *
     * @example
     * ```typescript
     *
     *    const tenantOptionId: string = "uniqueTenantId";
     *
     *    (async () => {
     *      const {data, res} = await tenantOptionsService.delete(tenantOptionId);
     *   })();
     * ```
     *
     * Required role: ROLE_TENANT_MANAGEMENT_ADMIN
     */
    TenantOptionsService.prototype.delete = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.delete.call(this, entityOrId)];
            });
        });
    };
    TenantOptionsService.prototype.getDetailUrl = function (entity) {
        if (this.securityOptionsCategories.indexOf(entity.category) > -1) {
            return this.securityOptionsListUrl + "/" + entity.category + "/" + entity.key;
        }
        else {
            return this.listUrl + "/" + entity.category + "/" + entity.key;
        }
    };
    TenantOptionsService.prototype.onBeforeCreate = function (obj) {
        return obj;
    };
    return TenantOptionsService;
}(core.Service));
exports.TenantOptionsService = TenantOptionsService;

});

unwrapExports(TenantOptionsService_1);
var TenantOptionsService_2 = TenantOptionsService_1.TenantOptionsService;

var tenantOptions = createCommonjsModule(function (module, exports) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(TenantOptionsService_1);

});

unwrapExports(tenantOptions);

var TenantSecurityOptionsService_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * @description
 * This service allows to get tenant security option.
 */
var TenantSecurityOptionsService = /** @class */ (function (_super) {
    __extends(TenantSecurityOptionsService, _super);
    function TenantSecurityOptionsService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.baseUrl = 'tenant';
        _this.listUrl = 'security-options';
        _this.category = 'password';
        _this.propertyName = 'options';
        return _this;
    }
    /**
     * Get a specific tenant's security option.
     *
     * @param {ITenantSecurityOption} Tenant's security option object with key value.
     *
     * @returns Returns promise object that is resolved with the ITenantSecurityOption wrapped by IResult.
     *
     * @example
     * ```typescript
     *
     *     const option: ITenantSecurityOption = {
     *        key: 'limit.validity'
     *      };
     *
     *    (async () => {
     *      const {data, res} = await tenantSecurityOptionsService.detail(option);
     *   })();
     * ```
     */
    TenantSecurityOptionsService.prototype.detail = function (tenantSecurityOption) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.detail.call(this, tenantSecurityOption)];
            });
        });
    };
    TenantSecurityOptionsService.prototype.getDetailUrl = function (tenantSecurityOption) {
        return this.listUrl + "/" + this.category + "/" + tenantSecurityOption.key;
    };
    TenantSecurityOptionsService.prototype.onBeforeCreate = function (obj) {
        return obj;
    };
    return TenantSecurityOptionsService;
}(core.Service));
exports.TenantSecurityOptionsService = TenantSecurityOptionsService;

});

unwrapExports(TenantSecurityOptionsService_1);
var TenantSecurityOptionsService_2 = TenantSecurityOptionsService_1.TenantSecurityOptionsService;

var tenantSecurityOptions = createCommonjsModule(function (module, exports) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(TenantSecurityOptionsService_1);

});

unwrapExports(tenantSecurityOptions);

var TenantLoginOptionsService_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * @description
 * This service allows to get tenant login options.
 */
var TenantLoginOptionsService = /** @class */ (function (_super) {
    __extends(TenantLoginOptionsService, _super);
    function TenantLoginOptionsService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.baseUrl = 'tenant';
        _this.loginOptionsUrl = 'loginOptions';
        return _this;
    }
    /**
     * Gets the tenant's login options.
     *
     * @example
     * ```typescript
     *
     *    (async () => {
     *      const {data, res} = await tenantLoginOptionsService.detail();
     *   })();
     * ```
     */
    TenantLoginOptionsService.prototype.detail = function () {
        return __awaiter(this, void 0, void 0, function () {
            var url, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.loginOptionsUrl;
                        if (this.client.tenant) {
                            url = this.loginOptionsUrl + "?tenantId=" + this.client.tenant;
                        }
                        return [4 /*yield*/, this.fetch(url)];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    return TenantLoginOptionsService;
}(core.Service));
exports.TenantLoginOptionsService = TenantLoginOptionsService;

});

unwrapExports(TenantLoginOptionsService_1);
var TenantLoginOptionsService_2 = TenantLoginOptionsService_1.TenantLoginOptionsService;

var tenantLoginOptions = createCommonjsModule(function (module, exports) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(TenantLoginOptionsService_1);

});

unwrapExports(tenantLoginOptions);

var AuditService_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });

var AuditService = /** @class */ (function (_super) {
    __extends(AuditService, _super);
    function AuditService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.baseUrl = 'audit';
        _this.listUrl = 'auditRecords';
        _this.propertyName = 'auditRecords';
        return _this;
    }
    /**
     * Gets the details of selected audit record.
     *
     * @param {string|number|IAuditRecord} entityOrId Entity or Id of the entity.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *    const auditId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await auditService.detail(auditId);
     *   })();
     * ```
     */
    AuditService.prototype.detail = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
            });
        });
    };
    /**
     * Creates a new audit record for a given source.
     *
     * @param {IAuditRecord} entity Audit record object with mandantory fragments.
     * IAuditRecord implements the [[IEvent]] interface.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *  const mandantoryObject: IAuditRecord = {
     *    type: AuditRecordType.ALARM,
     *    time: '2018-05-02T10:08:00Z',
     *    severity: Severity.MAJOR,
     *    source: {id: 1}
     *  };
     *
     *  (async () => {
     *    const {data, res} = await auditService.create(mandantoryObject);
     *  })();
     * ```
     */
    AuditService.prototype.create = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.create.call(this, entity)];
            });
        });
    };
    /**
     * Gets the list of audit records filtered by parameters.
     *
     * @returns Response wrapped in [[IResultList]]
     *
     * @param {object} filter Object containing filters for querying audit records.
     *
     * @example
     * ```typescript
     *
     *  const filter: object = {
     *     severity: Severity.MAJOR,
     *     pageSize: 100,
     *     withTotalPages: true
     *   };
     *
     *   (async () => {
     *     const {data, res, paging} = await auditService.list(filter);
     *   })();
     * ```
     */
    AuditService.prototype.list = function (filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.list.call(this, filter)];
            });
        });
    };
    /**
     * Gets a list as observable.
     *
     * @param {object} filter Object containing filters for querying
     * @param {object} options To configure the observable
     *
     * @returns Data wrapped as Observable.
     *
     * @example
     * ```typescript
     *
     *   const list$ = auditService.list$();
     *   list$.subscribe((data) => console.log(data));
     * ```
     *
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use [[Realtime]] for realtime connection and
     * rxjs `defer()` or `from()` to composite an observable on your own.
     */
    AuditService.prototype.list$ = function (filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return _super.prototype.list$.call(this, filter, options);
    };
    return AuditService;
}(core.Service));
exports.AuditService = AuditService;

});

unwrapExports(AuditService_1);
var AuditService_2 = AuditService_1.AuditService;

var AuditRecordType_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A specific audit record can have one of the following types
 */
var AuditRecordType;
(function (AuditRecordType) {
    AuditRecordType["ALARM"] = "Alarm";
    AuditRecordType["BULK_OPERATION"] = "BulkOperation";
    AuditRecordType["CEP_MODULE"] = "CepModule";
    AuditRecordType["EVENT"] = "Event";
    AuditRecordType["INVENTORY"] = "Inventory";
    AuditRecordType["INVENTORY_ROLE"] = "InventoryRole";
    AuditRecordType["OPERATION"] = "Operation";
    AuditRecordType["OPTION"] = "Option";
    AuditRecordType["GROUP"] = "Group";
    AuditRecordType["SMART_RULE"] = "SmartRule";
    AuditRecordType["SYSTEM"] = "SYSTEM";
    AuditRecordType["TENANT"] = "Tenant";
    AuditRecordType["USER"] = "User";
})(AuditRecordType = exports.AuditRecordType || (exports.AuditRecordType = {}));

});

unwrapExports(AuditRecordType_1);
var AuditRecordType_2 = AuditRecordType_1.AuditRecordType;

var ChangeType_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * An audit record can have one of the following change type
 */
var ChangeType;
(function (ChangeType) {
    ChangeType[ChangeType["ADDED"] = gettext.gettext('ADDED')] = "ADDED";
    ChangeType[ChangeType["REPLACED"] = gettext.gettext('REPLACED')] = "REPLACED";
    ChangeType[ChangeType["REMOVED"] = gettext.gettext('REMOVED')] = "REMOVED";
})(ChangeType = exports.ChangeType || (exports.ChangeType = {}));

});

unwrapExports(ChangeType_1);
var ChangeType_2 = ChangeType_1.ChangeType;

var audit$1 = createCommonjsModule(function (module, exports) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(AuditService_1);
__export(AuditRecordType_1);
__export(ChangeType_1);

});

unwrapExports(audit$1);

var InventoryRoleService_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });

var InventoryRoleService = /** @class */ (function (_super) {
    __extends(InventoryRoleService, _super);
    function InventoryRoleService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.baseUrl = 'user';
        _this.listUrl = 'inventoryroles';
        _this.propertyName = 'roles';
        return _this;
    }
    /**
     * Gets the details of inventory role.
     *
     * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *    const inventoryRoleId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await inventoryRoleService.detail(inventoryRoleId);
     *   })();
     * ```
     */
    InventoryRoleService.prototype.detail = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
            });
        });
    };
    /**
     * Creates a new inventory role.
     *
     * @param {IIdentified} entity
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *  const newRole: IIdentified = {
     *    name: 'Custom role'
     *  };
     *
     *  (async () => {
     *    const {data, res} = await inventoryRoleService.create(newRole);
     *  })();
     * ```
     */
    InventoryRoleService.prototype.create = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.create.call(this, entity)];
            });
        });
    };
    /**
     * Updates inventory role data.
     *
     * @param {IIdentified} entity
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *  const updateObject: IIdentified = {
     *    id: 1,
     *    name: 'changed role'
     *  };
     *
     *  (async () => {
     *    const {data, res} = await inventoryRoleService.update(updateObject);
     *  })();
     * ```
     */
    InventoryRoleService.prototype.update = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.update.call(this, entity)];
            });
        });
    };
    /**
     * Gets the list of inventory roles filtered by parameters.
     *
     * @returns Response wrapped in [[IResultList]]
     *
     * @param {object} filter Object containing filters for querying alarms.
     *
     * @example
     * ```typescript
     *
     *  const filter: object = {
     *     pageSize: 100,
     *     withTotalPages: true
     *   };
     *
     *   (async () => {
     *     const {data, res, paging} = await inventoryRoleService.list(filter);
     *   })();
     * ```
     */
    InventoryRoleService.prototype.list = function (filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.list.call(this, filter)];
            });
        });
    };
    /**
     * Gets a list as observable.
     *
     * @param {object} filter Object containing filters for querying
     * @param {object} options To configure the observable
     *
     * @returns Data wrapped as Observable.
     *
     * @example
     * ```typescript
     *
     *   const list$ = inventoryRoleService.list$();
     *   list$.subscribe((data) => console.log(data));
     * ```
     *
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use [[Realtime]] for realtime connection and
     * rxjs `defer()` or `from()` to composite an observable on your own.
     */
    InventoryRoleService.prototype.list$ = function (filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return _super.prototype.list$.call(this, filter, options);
    };
    /**
     * Removes an inventory role with given id.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {IExternalIdentity} identity Identity object with mandantory fragments.
     *
     * @example
     * ```typescript
     *
     *   const id: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await identityService.delete(id);
     *   })();
     * ```
     */
    InventoryRoleService.prototype.delete = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.delete.call(this, entityOrId)];
            });
        });
    };
    return InventoryRoleService;
}(core.Service));
exports.InventoryRoleService = InventoryRoleService;

});

unwrapExports(InventoryRoleService_1);
var InventoryRoleService_2 = InventoryRoleService_1.InventoryRoleService;

var inventoryRole = createCommonjsModule(function (module, exports) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(InventoryRoleService_1);

});

unwrapExports(inventoryRole);

var DeviceRegistrationStatus_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Device registration can have one of the following states.
 */
var DeviceRegistrationStatus;
(function (DeviceRegistrationStatus) {
    DeviceRegistrationStatus[DeviceRegistrationStatus["WAITING_FOR_CONNECTION"] = gettext.gettext('WAITING_FOR_CONNECTION')] = "WAITING_FOR_CONNECTION";
    DeviceRegistrationStatus[DeviceRegistrationStatus["PENDING_ACCEPTANCE"] = gettext.gettext('PENDING_ACCEPTANCE')] = "PENDING_ACCEPTANCE";
    DeviceRegistrationStatus[DeviceRegistrationStatus["ACCEPTED"] = gettext.gettext('ACCEPTED')] = "ACCEPTED";
})(DeviceRegistrationStatus = exports.DeviceRegistrationStatus || (exports.DeviceRegistrationStatus = {}));

});

unwrapExports(DeviceRegistrationStatus_1);
var DeviceRegistrationStatus_2 = DeviceRegistrationStatus_1.DeviceRegistrationStatus;

var DeviceRegistrationService_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });



/**
 * This class allows registration of a new device.
 */
var DeviceRegistrationService = /** @class */ (function (_super) {
    __extends(DeviceRegistrationService, _super);
    function DeviceRegistrationService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.baseUrl = 'devicecontrol';
        _this.listUrl = 'newDeviceRequests';
        _this.propertyName = 'newDeviceRequests';
        return _this;
    }
    /**
     * Gets the details of device registration.
     *
     * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *    const entityId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await deviceRegistrationService.detail(entityId);
     *    })();
     * ```
     */
    DeviceRegistrationService.prototype.detail = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
            });
        });
    };
    /**
     * Creates a new device registration.
     *
     * @param {IDeviceRegistrationCreate} entity Device registration object with mandantory fragments.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *    const mandantoryObject: IDeviceRegistrationCreate = {
     *      id: 1,
     *    };
     *
     *    (async () => {
     *      const {data, res} = await deviceRegistrationService.create(mandantoryObject);
     *    })();
     * ```
     */
    DeviceRegistrationService.prototype.create = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.create.call(this, entity)];
            });
        });
    };
    /**
     * Gets the list of device registrations by parameters.
     *
     * @returns Response wrapped in [[IResultList]]
     *
     * @param {object} filter Object containing filters for querying registrations.
     *
     * @example
     * ```typescript
     *
     *   const filter: object = {
     *     pageSize: 100,
     *     withTotalPages: true
     *   };
     *
     *   (async () => {
     *     const {data, res, paging} = await deviceRegistrationService.list(filter);
     *   })();
     * ```
     */
    DeviceRegistrationService.prototype.list = function (filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.list.call(this, filter)];
            });
        });
    };
    /**
     * Gets a list as observable.
     *
     * @param {object} filter Object containing filters for querying
     * @param {object} options To configure the observable
     *
     * @returns Data wrapped as Observable.
     *
     * @example
     * ```typescript
     *
     *   const list$ = deviceRegistrationService.list$();
     *   list$.subscribe((data) => console.log(data));
     * ```
     *
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use [[Realtime]] for realtime connection and
     * rxjs `defer()` or `from()` to composite an observable on your own.
     */
    DeviceRegistrationService.prototype.list$ = function (filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return _super.prototype.list$.call(this, filter, options);
    };
    /**
     * Removes an registration with given id.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {string | number | IIdentified} entityOrId entity or id of the registration.
     *
     * @example
     * ```typescript
     *
     *   const id = 'abc';
     *
     *   (async () => {
     *     const {data, res} = await deviceRegistrationService.delete(id);
     *     // data will be null
     *   })();
     * ```
     */
    DeviceRegistrationService.prototype.delete = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.delete.call(this, entityOrId)];
            });
        });
    };
    /**
     * Accepts the device registration for given id.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {string | number | IIdentified} entityOrId entity or id of registration.
     *
     * @example
     * ```typescript
     *
     *   const id = 'abc';
     *
     *   (async () => {
     *     const {data, res} = await deviceRegistrationService.accept(id);
     *   })();
     * ```
     */
    DeviceRegistrationService.prototype.accept = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            var id, update;
            return __generator(this, function (_a) {
                id = this.getIdString(entityOrId);
                update = Object.getPrototypeOf(this).update.bind(this);
                return [2 /*return*/, update({ id: id, status: DeviceRegistrationStatus_1.DeviceRegistrationStatus.ACCEPTED })];
            });
        });
    };
    /**
     * Bootstraps the device with given id.
     *
     * @param entityOrId entity or id of registration.
     * @param options for details see [[IDeviceBootstrapOptions]]
     *
     * @example
     * ```typescript
     *
     *   const id: 'abc';
     *   const options: IDeviceBootstrapOptions = {
     *     basicAuthToken: 'Basic dGVuYW50L3VzZXJuYW1lOnBhc3N3b3Jk',
     *     basicAuth: {
     *       user: 'username',
     *       pass: 'password'
     *     }
     *   };
     *
     *   (async () => {
     *     const {data, res} = await deviceRegistrationService.bootstrap(id, options);
     *   })();
     * ```
     */
    DeviceRegistrationService.prototype.bootstrap = function (entityOrId, options) {
        return __awaiter(this, void 0, void 0, function () {
            var id, body, url, basicAuth, basicAuthToken, user, pass, headers, method, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        id = this.getIdString(entityOrId);
                        body = JSON.stringify({ id: id });
                        url = this.baseUrl + "/deviceCredentials";
                        basicAuth = options.basicAuth;
                        basicAuthToken = options.basicAuthToken;
                        if (basicAuth) {
                            user = basicAuth.user, pass = basicAuth.pass;
                            basicAuthToken = b2a_1.btoa(user + ":" + pass);
                        }
                        headers = {
                            Authorization: "Basic " + basicAuthToken,
                            accept: 'application/json',
                            'content-type': 'application/json',
                        };
                        method = 'POST';
                        return [4 /*yield*/, this.client.fetch(url, { body: body, headers: headers, method: method })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        if (res.status > 400) {
                            throw { res: res, data: data };
                        }
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    DeviceRegistrationService.prototype.onBeforeCreate = function (entity) {
        return entity;
    };
    DeviceRegistrationService.prototype.onBeforeUpdate = function (entity) {
        var noIdEntity = Object.assign({}, entity);
        delete noIdEntity.id;
        return noIdEntity;
    };
    return DeviceRegistrationService;
}(core.Service));
exports.DeviceRegistrationService = DeviceRegistrationService;

});

unwrapExports(DeviceRegistrationService_1);
var DeviceRegistrationService_2 = DeviceRegistrationService_1.DeviceRegistrationService;

var DeviceRegistrationBulkService_1 = createCommonjsModule(function (module, exports) {
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var form_data_1 = __importDefault(browser$1);
/**
 * This class allows for bulk registering devices.
 */
var DeviceRegistrationBulkService = /** @class */ (function () {
    /**
     * Instantiate class and assign client
     * @param {IFetchClient} client
     */
    function DeviceRegistrationBulkService(client) {
        this.client = client;
    }
    /**
     * A new device registration as bulk.
     *
     * @param {Stream | Buffer} csv
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *  const csvString = `
     *  ID,CREDENTIALS,TENANT,TYPE,NAME,ICCID,IDTYPE,PATH,SHELL
     *  e2eDeviceRegistrationId,e2epassword123!,e2edocker,c8y_e2eDevice,e2eDevice,123456789,89456,e2eDeviceGroup,1
     *  900001,e2epassword123!,e2edocker,c8y_e2eDevice1,e2eDevice1,123456789,89456,e2eDeviceGroup,1
     *  900002,e2epassword123!,e2edocker,c8y_e2eDevice2,e2eDevice2,123456789,89456,e2eDeviceGroup,1`.trim();
     *
     *  const csvBuffer = Buffer.from(csvString):
     *
     *  (async () => {
     *    const {data, res} = await deviceRegistrationBulkService.create(csvBuffer);
     *  })();
     * ```
     */
    DeviceRegistrationBulkService.prototype.create = function (csv) {
        return __awaiter(this, void 0, void 0, function () {
            var url, method, body, fileName, bodyHeaders, headers, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = '/devicecontrol/bulkNewDeviceRequests';
                        method = 'POST';
                        body = new form_data_1.default();
                        fileName = 'bulk-registration.csv';
                        if (typeof (File) !== 'undefined' && csv instanceof File) {
                            fileName = csv.name;
                        }
                        body.append('file', csv, fileName);
                        if (typeof body.getHeaders === 'function') {
                            bodyHeaders = body.getHeaders();
                        }
                        headers = Object.assign({
                            accept: 'application/json'
                        }, bodyHeaders);
                        return [4 /*yield*/, this.client.fetch(url, { method: method, body: body, headers: headers })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    return DeviceRegistrationBulkService;
}());
exports.DeviceRegistrationBulkService = DeviceRegistrationBulkService;

});

unwrapExports(DeviceRegistrationBulkService_1);
var DeviceRegistrationBulkService_2 = DeviceRegistrationBulkService_1.DeviceRegistrationBulkService;

var deviceRegistration = createCommonjsModule(function (module, exports) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(DeviceRegistrationService_1);
__export(DeviceRegistrationBulkService_1);
__export(DeviceRegistrationStatus_1);

});

unwrapExports(deviceRegistration);

var UserRoleService_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * @description
 * This service allows for fetch user roles.
 */
var UserRoleService = /** @class */ (function (_super) {
    __extends(UserRoleService, _super);
    function UserRoleService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.baseUrl = 'user';
        _this.listUrl = 'roles';
        _this.propertyName = 'roles';
        return _this;
    }
    /**
     * Gets the details of given role.
     *
     * @param {string|number|IRole} entityOrId Roles's id or role object.
     *
     * @returns Returns promise object that is resolved with the IRole wrapped by IResult.
     *
     * @example
     * ```typescript
     *
     *    const roleId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await userRoleService.detail(roleId);
     *   })();
     * ```
     */
    UserRoleService.prototype.detail = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
            });
        });
    };
    /**
     * Gets the list of user roles filtered by parameters.
     *
     * @param {object} filter Object containing filters for querying roles.
     *
     * @returns Returns promise object that is resolved with the IRole wrapped by IResultList.
     *
     * @example
     * ```typescript
     *
     *  const filter: object = {
     *     severity: Severity.MAJOR,
     *     pageSize: 100,
     *     withTotalPages: true
     *   };
     *
     *   (async () => {
     *     const {data, res, paging} = await userRoleService.list(filter);
     *   })();
     * ```
     */
    UserRoleService.prototype.list = function (filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.list.call(this, filter)];
            });
        });
    };
    /**
     * Gets a list as observable.
     *
     * @param {object} filter Object containing filters for querying
     * @param {object} options To configure the observable
     *
     * @returns Data wrapped as Observable.
     *
     * @example
     * ```typescript
     *
     *   const list$ = userRoleService.list$();
     *   list$.subscribe((data) => console.log(data));
     * ```
     *
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use [[Realtime]] for realtime connection and
     * rxjs `defer()` or `from()` to composite an observable on your own.
     */
    UserRoleService.prototype.list$ = function (filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return _super.prototype.list$.call(this, filter, options);
    };
    return UserRoleService;
}(core.Service));
exports.UserRoleService = UserRoleService;

});

unwrapExports(UserRoleService_1);
var UserRoleService_2 = UserRoleService_1.UserRoleService;

var userRole = createCommonjsModule(function (module, exports) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(UserRoleService_1);

});

unwrapExports(userRole);

var UserGroupService_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });

var ChildType;
(function (ChildType) {
    ChildType["ROLES"] = "roles";
    ChildType["USERS"] = "users";
})(ChildType || (ChildType = {}));
/**
 * @description
 * This service allows for managing user groups.
 */
var UserGroupService = /** @class */ (function (_super) {
    __extends(UserGroupService, _super);
    function UserGroupService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.baseUrl = 'user';
        _this.propertyName = 'groups';
        return _this;
    }
    Object.defineProperty(UserGroupService.prototype, "listUrl", {
        get: function () {
            return this.client.tenant + "/groups";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the details of given user group.
     *
     * @param {string|number|IUserGroup} entityOrId Group's id or role object.
     *
     * @returns Returns promise object that is resolved with the IUserGroup wrapped by IResult.
     *
     * @example
     * ```typescript
     *
     *    const groupId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await userGroupService.detail(roleId);
     *   })();
     * ```
     */
    UserGroupService.prototype.detail = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
            });
        });
    };
    /**
     * Creates a new user group.
     *
     * @param {IUserGroup} entity User Group object.
     *
     * @returns {IResult<IUserGroup>} Returns promise object that is resolved with
     * the details of newly created user group.
     *
     * @example
     * ```typescript
     *
     *  const userGroupObject: IUserGroup = {
     *    name: "new user group"
     *  };
     *
     *  (async () => {
     *    const {data, res} = await userGroupService.create(userGroupObject);
     *  })();
     * ```
     */
    UserGroupService.prototype.create = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.create.call(this, entity)];
            });
        });
    };
    /**
     * Updates user group data.
     *
     * @param {Partial<IUserGroup>} entity User group is partially updatable.
     *
     * @returns {IResult<IUserGroup>} Returns promise object that is resolved with the saved user group object.
     *
     * @example
     * ```typescript
     *
     *  const partialUpdateObject: Partial<IUserGroup> = {
     *     "id" : 1,
     *     "self" : "[URL to this resource]",
     *     "name" : "PlatformAdministrators",
     *     ...
     *   }
     *
     *  (async () => {
     *    const {data, res} = await userGroupService.update(partialUpdateObject);
     *  })();
     * ```
     */
    UserGroupService.prototype.update = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.update.call(this, entity)];
            });
        });
    };
    /**
     * Gets the list of user groups filtered by parameters.
     *
     * @param {object} filter Object containing filters for querying User Groups.
     *
     * @returns Returns promise object that is resolved with the IUserGroup wrapped by IResultList.
     *
     * @example
     * ```typescript
     *
     *  const filter: object = {
     *     severity: Severity.MAJOR,
     *     pageSize: 100,
     *     withTotalPages: true
     *   };
     *
     *   (async () => {
     *     const {data, res, paging} = await userGroupService.list(filter);
     *   })();
     * ```
     */
    UserGroupService.prototype.list = function (filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.list.call(this, filter)];
            });
        });
    };
    /**
     * Gets a list as observable.
     *
     * @param {object} filter Object containing filters for querying
     * @param {object} options To configure the observable
     *
     * @returns Data wrapped as Observable.
     *
     * @example
     * ```typescript
     *
     *   const list$ = userGroupService.list$();
     *   list$.subscribe((data) => console.log(data));
     * ```
     *
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use [[Realtime]] for realtime connection and
     * rxjs `defer()` or `from()` to composite an observable on your own.
     */
    UserGroupService.prototype.list$ = function (filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return _super.prototype.list$.call(this, filter, options);
    };
    /**
     * Removes user group.
     *
     * @param {number | IIdentified} entityOrId User group's id or user group object.
     *
     * @returns Returns promise object that is resolved with the IResult of null.
     *
     * @example
     * ```typescript
     *
     *    const userGroupId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await userGroupService.delete(userGroupId);
     *   })();
     * ```
     * When group is removed, suitable audit records are created with type 'User'
     * and activity 'User updated' with information that user has been removed from group.
     *
     * Please, note that the ADMINS and DEVICES groups can not be deleted.
     */
    UserGroupService.prototype.delete = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.delete.call(this, entityOrId)];
            });
        });
    };
    /**
     * Assign role to user group.
     *
     * @param {string | number | Partial<IUserGroup>} entityOrId User group's id or user group object.
     * @param {string | Partial<ISource>} childEntityOrSelf Url to role resource or IRoleReference object.
     *
     * @returns Returns promise object that is resolved with the IRoleReference wrapped by IResult.
     *
     * @example
     * ```typescript
     *
     *    const userGroupId: number = 1;
     *    const roleResource: string = "[URL to the Role resource]";
     *
     *    (async () => {
     *      const {data, res} = await userGroupService.addRoleToGroup(userGroupId, roleResource);
     *   })();
     * ```
     * When role is assigned to user, suitable audit record is created with type 'User' and activity 'User updated'.
     */
    UserGroupService.prototype.addRoleToGroup = function (entityOrId, childEntityOrSelf) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.addChild(ChildType.ROLES, entityOrId, childEntityOrSelf)];
            });
        });
    };
    /**
     * Unassign role from user
     *
     * @param {string | number | Partial<IUserGroup>} entityOrId User group's id or user group object.
     * @param {string | Partial<ISource>} childEntityOrSelf Url to user resource or IRoleReference object.
     *
     * @returns Returns promise object that is resolved with the IResult of null.
     *
     * @example
     * ```typescript
     *
     *    const userGroupId: number = 1;
     *    const userResource: string = "[URL to the Role resource]";
     *
     *    (async () => {
     *      const {data, res} = await userGroupService.removeRoleFromGroup(userGroupId, userResource);
     *   })();
     * ```
     */
    UserGroupService.prototype.removeRoleFromGroup = function (entityOrId, childEntityOrSelf) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.removeChild(ChildType.ROLES, entityOrId, childEntityOrSelf)];
            });
        });
    };
    /**
     * Assign user to user group.
     *
     * @param {string | number | Partial<IUserGroup>} entityOrId User group's id or user group object.
     * @param {string | Partial<ISource>} childEntityOrSelf Url to user resource or IUserReference object.
     *
     * @returns Returns promise object that is resolved with the IUserReference wrapped by IResult.
     *
     * @example
     * ```typescript
     *
     *    const userGroupId: number = 1;
     *    const userResource: string = "[URL to the User resource]";
     *
     *    (async () => {
     *      const {data, res} = await userGroupService.addUserToGroup(userGroupId, userResource);
     *   })();
     * ```
     * When user is added to group, suitable audit record is created with type 'User' and activity 'User updated'.
     */
    UserGroupService.prototype.addUserToGroup = function (entityOrId, childEntityOrSelf) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.addChild(ChildType.USERS, entityOrId, childEntityOrSelf)];
            });
        });
    };
    /**
     * Remove user from a group
     *
     * @param {string | number | Partial<IUserGroup>} entityOrId User group's id or user group object.
     * @param {string | Partial<ISource>} childEntityOrSelf Url to user resource or IUserReference object.
     *
     * @returns Returns promise object that is resolved with the IResult of null.
     *
     * @example
     * ```typescript
     *
     *    const userGroupId: number = 1;
     *    const userResource: string = "[URL to the User resource]";
     *
     *    (async () => {
     *      const {data, res} = await userGroupService.removeUserFromGroup(userGroupId, userResource);
     *   })();
     * ```
     * When user is removed from group, suitable audit record is created with type 'User' and activity 'User updated'.
     */
    UserGroupService.prototype.removeUserFromGroup = function (entityOrId, childEntityOrSelf) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.removeChild(ChildType.USERS, entityOrId, childEntityOrSelf)];
            });
        });
    };
    UserGroupService.prototype.getSelf = function (childReference) {
        if (typeof childReference === 'object' && childReference.self) {
            return childReference.self;
        }
        else {
            return childReference;
        }
    };
    UserGroupService.prototype.getChildUrl = function (type, userGroupOrId) {
        return this.getDetailUrl(userGroupOrId) + "/" + type;
    };
    UserGroupService.prototype.getChildReferenceAsBody = function (type, childReference) {
        var childSelf = this.getSelf(childReference);
        switch (type) {
            case ChildType.ROLES:
                return JSON.stringify({ role: { self: String(childSelf) } });
            case ChildType.USERS:
                return JSON.stringify({ user: { self: String(childSelf) } });
        }
        throw new Error('UserGroupService -> getChild -> unsupported child type');
    };
    UserGroupService.prototype.addChild = function (type, userGroupOrId, childReference) {
        return __awaiter(this, void 0, void 0, function () {
            var url, method, body, headers, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.getChildUrl(type, userGroupOrId);
                        method = 'POST';
                        body = this.getChildReferenceAsBody(type, childReference);
                        headers = {
                            accept: 'application/json',
                            'content-type': 'application/json'
                        };
                        return [4 /*yield*/, this.fetch(url, { method: method, body: body, headers: headers })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        data = data.managedObject;
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    UserGroupService.prototype.removeChild = function (type, userGroupOrId, childReference) {
        return __awaiter(this, void 0, void 0, function () {
            var childId, url, method, headers, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        childId = this.getIdString(childReference);
                        url = this.getChildUrl(type, userGroupOrId) + "/" + encodeURIComponent(String(childId));
                        method = 'DELETE';
                        headers = { accept: 'application/json' };
                        return [4 /*yield*/, this.fetch(url, { method: method, headers: headers })];
                    case 1:
                        res = _a.sent();
                        data = null;
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    return UserGroupService;
}(core.Service));
exports.UserGroupService = UserGroupService;

});

unwrapExports(UserGroupService_1);
var UserGroupService_2 = UserGroupService_1.UserGroupService;

var userGroup = createCommonjsModule(function (module, exports) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(UserGroupService_1);

});

unwrapExports(userGroup);

var IdentityService_1 = createCommonjsModule(function (module, exports) {
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This class allwos for managing external identifiers.
 */
var IdentityService = /** @class */ (function () {
    function IdentityService(client) {
        this.baseUrl = 'identity';
        this.propertyName = 'externalIds';
        this.client = client;
    }
    /**
     * Gets the list of identities filtered by parameters.
     *
     * @returns Response wrapped in [[IResultList]]
     *
     * @param {object} filter Object containing filters for querying identity.
     *
     * @example
     * ```typescript
     *
     *  const filter: object = {
     *     pageSize: 100,
     *     withTotalPages: true
     *   };
     *
     *   (async () => {
     *     const {data, res, paging} = await identityService.list(filter);
     *   })();
     * ```
     */
    IdentityService.prototype.list = function (managedObjectId) {
        return __awaiter(this, void 0, void 0, function () {
            var headers, url, res, json, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        headers = { accept: 'application/json' };
                        url = this.getExternalIdsOfGlobalIdUrl(managedObjectId);
                        return [4 /*yield*/, this.fetch(url, { headers: headers })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        json = _a.sent();
                        data = json[this.propertyName];
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    /**
     * Creates a new identity.
     *
     * @param {IExternalIdentity} identity Identity object with mandantory fragments.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *   const linkedManagedObjectId = '123';
     *   const identity: IExternalIdentity = {
     *      type: 'type',
     *      externalId: '1',
     *      managedObject: {
     *        id: linkedManagedObjectId
     *      }
     *    };
     *
     *    (async () => {
     *      const {data, res} = await identityService.create(identity);
     *   })();
     * ```
     */
    IdentityService.prototype.create = function (identity) {
        return __awaiter(this, void 0, void 0, function () {
            var headers, method, body, url, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        headers = { 'content-type': 'application/json', accept: 'application/json' };
                        method = 'POST';
                        body = JSON.stringify(identity);
                        url = this.getExternalIdsOfGlobalIdUrl(identity.managedObject.id);
                        return [4 /*yield*/, this.fetch(url, { headers: headers, method: method, body: body })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    /**
     * Gets the details of an identity.
     *
     * @param {IExternalIdentity} identity Identity object with mandantory fragments.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *    const identity: IExternalIdentity = {
     *      type: 'type',
     *      externalId: '1'
     *    };
     *
     *    (async () => {
     *      const {data, res} = await identityService.detail(identity);
     *   })();
     * ```
     */
    IdentityService.prototype.detail = function (identity) {
        return __awaiter(this, void 0, void 0, function () {
            var headers, url, res, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        headers = { accept: 'application/json' };
                        url = this.getExternalIdUrl(identity);
                        return [4 /*yield*/, this.fetch(url, { headers: headers })];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, { res: res, data: data }];
                }
            });
        });
    };
    /**
     * Removes an identity with given id.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {IExternalIdentity} identity Identity object with mandantory fragments.
     *
     * @example
     * ```typescript
     *
     *   const identity: IExternalIdentity = {
     *      type: 'type',
     *      externalId: '1'
     *    };
     *
     *    (async () => {
     *      const {data, res} = await identityService.delete(identity);
     *   })();
     * ```
     */
    IdentityService.prototype.delete = function (identity) {
        return __awaiter(this, void 0, void 0, function () {
            var headers, method, url, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        headers = { accept: 'application/json' };
                        method = 'DELETE';
                        url = this.getExternalIdUrl(identity);
                        return [4 /*yield*/, this.fetch(url, { headers: headers, method: method })];
                    case 1:
                        res = _a.sent();
                        return [2 /*return*/, { res: res, data: null }];
                }
            });
        });
    };
    IdentityService.prototype.fetch = function (url, init) {
        return __awaiter(this, void 0, void 0, function () {
            var res, data, ex_1, ex_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.client.fetch(url, init)];
                    case 1:
                        res = _a.sent();
                        if (!(res.status >= 400)) return [3 /*break*/, 10];
                        data = null;
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 9]);
                        return [4 /*yield*/, res.json()];
                    case 3:
                        data = _a.sent();
                        return [3 /*break*/, 9];
                    case 4:
                        ex_1 = _a.sent();
                        _a.label = 5;
                    case 5:
                        _a.trys.push([5, 7, , 8]);
                        return [4 /*yield*/, res.text()];
                    case 6:
                        data = _a.sent();
                        return [3 /*break*/, 8];
                    case 7:
                        ex_2 = _a.sent();
                        return [3 /*break*/, 8];
                    case 8: return [3 /*break*/, 9];
                    case 9: throw { res: res, data: data };
                    case 10: return [2 /*return*/, res];
                }
            });
        });
    };
    IdentityService.prototype.getExternalIdsOfGlobalIdUrl = function (managedObjectId) {
        return "/" + this.baseUrl + "/globalIds/" + managedObjectId + "/externalIds";
    };
    IdentityService.prototype.getExternalIdUrl = function (identity) {
        return "/" + this.baseUrl + "/externalIds/" + identity.type + "/" + identity.externalId;
    };
    return IdentityService;
}());
exports.IdentityService = IdentityService;

});

unwrapExports(IdentityService_1);
var IdentityService_2 = IdentityService_1.IdentityService;

var identity$1 = createCommonjsModule(function (module, exports) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(IdentityService_1);

});

unwrapExports(identity$1);

var TrustedCertificateService_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * This class allows for managing trusted certificates.
 */
var TrustedCertificateService = /** @class */ (function (_super) {
    __extends(TrustedCertificateService, _super);
    function TrustedCertificateService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.listUrl = 'trusted-certificates';
        _this.propertyName = 'certificates';
        return _this;
    }
    Object.defineProperty(TrustedCertificateService.prototype, "baseUrl", {
        get: function () {
            return "/tenant/tenants/" + this.client.tenant;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets a list of trusted certificates.
     *
     * @returns Response wrapped in [[IResultList]].
     *
     * @example
     * ```typescript
     *
     *   (async () => {
     *     const {data, res} = await trustedCertificateService.list();
     *   })();
     * ```
     */
    TrustedCertificateService.prototype.list = function (filter) {
        if (filter === void 0) { filter = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.list.call(this, filter)];
            });
        });
    };
    /**
     * Gets the details of trusted certificate
     *
     * @param {string | ITrustedCertificate} entityOrId Trusted certificate object or trusted certificate fingerprint.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *    const fingerprint: string = 'abc';
     *
     *    (async () => {
     *      const {data, res} = await trustedCertificateService.detail(fingerprint);
     *   })();
     * ```
     */
    TrustedCertificateService.prototype.detail = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
            });
        });
    };
    /**
     * Removes a trusted certificate with given fingerprint.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {string | ITrustedCertificate} entityOrId Trusted certificate object or trusted certificate fingerprint.
     *
     * @example
     * ```typescript
     *
     *   const fingerprint: string = 'abc';
     *
     *    (async () => {
     *      const {data, res} = await trustedCertificateService.delete(fingerprint);
     *   })();
     * ```
     */
    TrustedCertificateService.prototype.delete = function (entityOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.delete.call(this, entityOrId)];
            });
        });
    };
    /**
     * Updates trusted certificate data.
     *
     * @param entity Trusted certificate partial object.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *  const certificate: Partial<ITrustedCertificate> = {
     *    name: 'Name'
     *  };
     *
     *  (async () => {
     *    const {data, res} = await trustedCertificateService.update(certificate);
     *  })();
     * ```
     */
    TrustedCertificateService.prototype.update = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.update.call(this, entity)];
            });
        });
    };
    /**
     * Creates a new trusted certificate.
     *
     * @param {Partial<ITrustedCertificate>} Trusted certificate object.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @example
     * ```typescript
     *
     *  const certificate: Partial<ITrustedCertificate> = {
     *    name: 'Name',
     *    certInPemFormat: 'MIID+DCCAuCgAwIBAgIJAO1Q9t/M9gYlMA0GC...',
     *    status: 'ENABLED'
     *  };
     *
     *  (async () => {
     *    const {data, res} = await trustedCertificateService.create(certificate);
     *  })();
     * ```
     */
    TrustedCertificateService.prototype.create = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.create.call(this, entity)];
            });
        });
    };
    TrustedCertificateService.prototype.getDetailUrl = function (entityOrId) {
        var id;
        if (typeof entityOrId === 'object' && entityOrId.fingerprint) {
            id = entityOrId.fingerprint;
        }
        else {
            id = entityOrId;
        }
        return this.listUrl + "/" + id;
    };
    return TrustedCertificateService;
}(core.Service));
exports.TrustedCertificateService = TrustedCertificateService;

});

unwrapExports(TrustedCertificateService_1);
var TrustedCertificateService_2 = TrustedCertificateService_1.TrustedCertificateService;

var trustedCertificates = createCommonjsModule(function (module, exports) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(TrustedCertificateService_1);

});

unwrapExports(trustedCertificates);

var services = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

exports.FetchClient = core.FetchClient;
exports.BasicAuth = core.BasicAuth;

exports.EventService = event.EventService;
exports.EventBinaryService = event.EventBinaryService;

exports.InventoryService = inventory.InventoryService;
exports.InventoryBinaryService = inventory.InventoryBinaryService;

exports.MeasurementService = measurement.MeasurementService;

exports.AlarmService = alarm.AlarmService;

exports.OperationBulkService = operation.OperationBulkService;
exports.OperationService = operation.OperationService;

exports.ApplicationService = application.ApplicationService;

exports.UserService = user.UserService;

exports.TenantService = tenant.TenantService;

exports.SystemOptionsService = systemOptions.SystemOptionsService;

exports.TenantOptionsService = tenantOptions.TenantOptionsService;

exports.TenantSecurityOptionsService = tenantSecurityOptions.TenantSecurityOptionsService;

exports.TenantLoginOptionsService = tenantLoginOptions.TenantLoginOptionsService;

exports.AuditService = audit$1.AuditService;

exports.InventoryRoleService = inventoryRole.InventoryRoleService;

exports.DeviceRegistrationService = deviceRegistration.DeviceRegistrationService;
exports.DeviceRegistrationBulkService = deviceRegistration.DeviceRegistrationBulkService;

exports.UserRoleService = userRole.UserRoleService;

exports.UserGroupService = userGroup.UserGroupService;

exports.Realtime = realtime.Realtime;

exports.IdentityService = identity$1.IdentityService;

exports.TrustedCertificateService = trustedCertificates.TrustedCertificateService;

});

unwrapExports(services);
var services_1 = services.FetchClient;
var services_2 = services.BasicAuth;
var services_3 = services.EventService;
var services_4 = services.EventBinaryService;
var services_5 = services.InventoryService;
var services_6 = services.InventoryBinaryService;
var services_7 = services.MeasurementService;
var services_8 = services.AlarmService;
var services_9 = services.OperationBulkService;
var services_10 = services.OperationService;
var services_11 = services.ApplicationService;
var services_12 = services.UserService;
var services_13 = services.TenantService;
var services_14 = services.SystemOptionsService;
var services_15 = services.TenantOptionsService;
var services_16 = services.TenantSecurityOptionsService;
var services_17 = services.TenantLoginOptionsService;
var services_18 = services.AuditService;
var services_19 = services.InventoryRoleService;
var services_20 = services.DeviceRegistrationService;
var services_21 = services.DeviceRegistrationBulkService;
var services_22 = services.UserRoleService;
var services_23 = services.UserGroupService;
var services_24 = services.Realtime;
var services_25 = services.IdentityService;
var services_26 = services.TrustedCertificateService;

var Client_1 = createCommonjsModule(function (module, exports) {
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });


var Client = /** @class */ (function () {
    /**
     * Initializes a new Client, which allows to request data from the API. Differently
     * to Client.authenticate([...]) it needs a tenant given and does not verify if the
     * login is correct.
     *
     * @example
     * ```typescript
     *
     * const auth = new BasicAuth({
     *   user: 'youruser',
     *   password: 'yourpassword',
     *   tenant: 'acme'
     * }); // use CookieAuth() if your platform uses oauth (only in browser!)
     *
     * const baseUrl = 'https://acme.cumulocity.com';
     * const client = new Client(auth, baseUrl);
     * (async () => {
     *   const { data, paging, res }); =  await client.inventory.list({ pageSize: 100 });
     * })();
     * ```
     *
     * @param auth The Authentication strategy to use (e.g. new BasicAuth())
     * @param baseUrl The URL to request (optional in browser, mandatory in node)
     */
    function Client(auth, baseUrl) {
        var client = new services.FetchClient(auth, baseUrl);
        this.realtime = new realtime.Realtime(client);
        this.alarm = new services.AlarmService(client, this.realtime);
        this.application = new services.ApplicationService(client, this.realtime);
        this.audit = new services.AuditService(client);
        this.core = client;
        this.deviceRegistration = new services.DeviceRegistrationService(client);
        this.deviceRegistrationBulk = new services.DeviceRegistrationBulkService(client);
        this.event = new services.EventService(client, this.realtime);
        this.inventory = new services.InventoryService(client, this.realtime);
        this.inventoryBinary = new services.InventoryBinaryService(client);
        this.inventoryRole = new services.InventoryRoleService(client);
        this.measurement = new services.MeasurementService(client, this.realtime);
        this.operation = new services.OperationService(client);
        this.operationBulk = new services.OperationBulkService(client);
        this.options = {
            security: new services.TenantSecurityOptionsService(client),
            system: new services.SystemOptionsService(client),
            login: new services.TenantLoginOptionsService(client),
            tenant: new services.TenantOptionsService(client),
        };
        this.role = new services.InventoryRoleService(client);
        this.tenant = new services.TenantService(client);
        this.user = new services.UserService(client);
        this.userGroup = new services.UserGroupService(client);
        this.userRole = new services.UserRoleService(client);
        this.identity = new services.IdentityService(client);
    }
    /**
     * Authenticates the given user. Determines the tenant by itself via a call to tenant/currentTenant.
     *
     * @example
     * ```typescript
     *
     * let client: Client;
     * (async () => {
     *  client = await Client.authenticate({
     *    user: 'testuser',
     *    password: 'password1337!'
     *  }, 'https://acme.cumulocity.com');
     *
     *  //you have access to the client api now
     *  const { data, paging, res }); =  await client.inventory.list({ pageSize: 100 });
     * })();
     * ```
     */
    Client.authenticate = function (credentials, baseUrl) {
        return __awaiter(this, void 0, void 0, function () {
            var auth, clientCore, res, name, client;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        auth = new services.BasicAuth(credentials);
                        clientCore = new services.FetchClient(auth, baseUrl);
                        return [4 /*yield*/, clientCore.fetch('/tenant/currentTenant', { method: 'GET' })];
                    case 1:
                        res = _a.sent();
                        if (res.status !== 200) {
                            throw { res: res };
                        }
                        return [4 /*yield*/, res.json()];
                    case 2:
                        name = (_a.sent()).name;
                        client = new Client(auth, baseUrl);
                        client.core.tenant = name;
                        return [2 /*return*/, client];
                }
            });
        });
    };
    /**
     * Allows to use http to register a device on the platform.
     *
     * @deprecated Please use MQTT to bootstrap a device.
     */
    Client.deviceBootstrap = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var deviceId, timeout, baseUrl, basicAuthToken, expire, clientCore, deviceRegistration, client, data, username, password, tenantId, auth, error_1, retry;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        deviceId = options.deviceId, timeout = options.timeout, baseUrl = options.baseUrl, basicAuthToken = options.basicAuthToken;
                        expire = options.expire;
                        if (timeout && !expire) {
                            expire = Date.now() + timeout;
                        }
                        clientCore = new services.FetchClient(undefined, baseUrl);
                        deviceRegistration = new services.DeviceRegistrationService(clientCore);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, deviceRegistration.bootstrap(deviceId, { basicAuthToken: basicAuthToken })];
                    case 2:
                        data = (_a.sent()).data;
                        username = data.username, password = data.password, tenantId = data.tenantId;
                        auth = new services.BasicAuth({ user: username, tenant: tenantId, password: password });
                        client = new Client(auth, baseUrl);
                        client.core.tenant = tenantId;
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        retry = (!expire || Date.now() < expire) && error_1.res.status === 404;
                        if (retry) {
                            return [2 /*return*/, Client.deviceBootstrap(Object.assign({ expire: expire }, options))];
                        }
                        else {
                            throw error_1;
                        }
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/, client];
                }
            });
        });
    };
    /**
     * Allows to change the current Authentication
     * @param auth The new Authentication information.
     */
    Client.prototype.setAuth = function (auth) {
        this.core.setAuth(auth);
        this.realtime.disconnect();
    };
    return Client;
}());
exports.Client = Client;

});

unwrapExports(Client_1);
var Client_2 = Client_1.Client;

var public_api = createCommonjsModule(function (module, exports) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var cross_fetch_1 = __importDefault(browserPonyfill);
__export(Client_1);
__export(alarm);
__export(application);
__export(audit$1);
__export(core);
__export(trustedCertificates);
__export(deviceRegistration);
__export(event);
__export(identity$1);
__export(inventory);
__export(inventoryRole);
__export(measurement);
__export(operation);
__export(realtime);
__export(systemOptions);
__export(tenant);
__export(tenantOptions);
__export(tenantSecurityOptions);
__export(tenantLoginOptions);
__export(user);
__export(userGroup);
__export(userRole);
function polyfillFetch() {
    if (!window.fetch) {
        window.fetch = cross_fetch_1.default;
    }
}
exports.polyfillFetch = polyfillFetch;

});

unwrapExports(public_api);
var public_api_1 = public_api.polyfillFetch;

var esm5 = createCommonjsModule(function (module, exports) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(public_api);

});

var index$21 = unwrapExports(esm5);

export default index$21;
//# sourceMappingURL=client.js.map
