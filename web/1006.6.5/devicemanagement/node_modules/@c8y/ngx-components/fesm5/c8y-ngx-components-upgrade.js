import { __assign, __read, __decorate, __awaiter, __generator, __param, __extends } from 'tslib';
import { ViewContext, EmptyComponent, gettext, AppStateService, RouterService, ActionService, TabsService, RouterModule, HOOK_NAVIGATOR_NODES, HOOK_TABS, HOOK_ACTION_BAR, HOOK_ACTION, HOOK_BREADCRUMB, HOOK_SEARCH, HOOK_DOCS, getActivatedRoute, HOOK_COMPONENTS, BootstrapComponent, UserTotpRevokeComponent, DataGridComponent, HOOK_PATTERN_MESSAGES, HeaderService, AlertService, UserMenuService, DocsService, PasswordService, NavigatorNodeRoot } from '@c8y/ngx-components';
import { ReplaySubject, BehaviorSubject, of, combineLatest, from, fromEventPattern, Subject, defer } from 'rxjs';
import { filter, merge, debounceTime, switchMap, startWith, map as map$1 } from 'rxjs/operators';
import { ActivationEnd, Router } from '@angular/router';
import { FetchClient } from '@c8y/client';
import { NgZone, Injectable, NgModule, ElementRef, Component, ChangeDetectionStrategy, ViewContainerRef, ViewChild, TemplateRef, Optional, Inject } from '@angular/core';
import { map, unary, find, forEach, startsWith, assign, pick, property, some, every } from 'lodash-es';
import { ContextDashboardService } from '@c8y/ngx-components/context-dashboard';
import { CommonModule } from '@angular/common';
import { TranslateModule, TranslateService } from '@ngx-translate/core';
import { downgradeComponent, downgradeInjectable } from '@angular/upgrade/static';
import { bind, element, module } from 'angular';
import { AppLogsAutoRefreshComponent } from '@c8y/ngx-components/app-logs';
import { ApiService } from '@c8y/ngx-components/api';

var ViewContextLegacyParameter;
(function (ViewContextLegacyParameter) {
    ViewContextLegacyParameter["Device"] = "deviceId";
    ViewContextLegacyParameter["Group"] = "groupId";
    ViewContextLegacyParameter["User"] = "userId";
    ViewContextLegacyParameter["Application"] = "applicationId";
    ViewContextLegacyParameter["SubscribedApplications"] = "applicationId";
    ViewContextLegacyParameter["Tenant"] = "tenantId";
})(ViewContextLegacyParameter || (ViewContextLegacyParameter = {}));
function c8yViewsProvider($routeProvider, c8yTabsProvider, c8yPathUtils) {
    'ngInject';
    var viewMap = {};
    var contextViews = new ReplaySubject();
    return {
        when: when,
        $get: function () {
            return {
                contextViews: contextViews,
                when: function (path, cfg) {
                    return when(path, cfg, true);
                },
                getByPath: getByPath,
                prefixWithSlash: prefixWithSlash
            };
        }
    };
    /**
     * @ngdoc function
     * @name when
     * @methodOf c8y.ui.provider:c8yViewsProvider
     *
     * @description
     * Defines a view for given route.
     * If multiple views are defined for a single route then there will be a separate tab for each view available when user visits that route.
     *
     * @param path Target route.
     * @param cfg View configuration object with the following properties:
     *
     * - **name** - `string` - View's name (in case of multiple views at single route this will be displayed as tab's title).
     * - **priority** - `integer` - View's priority (in case of multiple views at single route this will determine the position of view's tab in the tabs stack).
     * - **icon** - `string` - Font Awesome icon name for the view (displayed on the tab's header).
     * - **showIf** - `function` - Function returning boolean value indicating whether to show a tab for the view or not.
     * - **templateUrl** - `string` - Path to the template to use for displaying the view.
     *
     * You can also provide other view options - the same as available for standard {@link https://docs.angularjs.org/api/ngRoute/provider/$routeProvider $routeProvider} in AngularJS.
     *
     * @example
     * The following example demonstrates how to add a new view to device details route
     * (which will be displayed as a tab if other views are assigned to the same route):
     * <pre>
     *   c8yViewsProvider.when('/device/:deviceId', {
     *     name: 'Tracking',
     *     templateUrl: ':::PLUGIN_PATH:::/views/index.html',
     *     icon: 'crosshairs',
     *     showIf: ['$routeParams', 'c8yDevices', function ($routeParams, c8yDevices) {
     *       var deviceId = $routeParams.deviceId;
     *       return c8yDevices.detailCached(deviceId).then(function (res) {
     *         var device = res.data;
     *         return device && (device.c8y_MotionTracking || device.c8y_Geofence);
     *       });
     *     }]
     *   });
     * </pre>
     */
    function when(path, cfg, runPhase) {
        var newPath = prefixWithSlash(path);
        cfg.resolve = cfg.resolve || {};
        // eslint-disable-next-line no-underscore-dangle
        cfg.resolve.__c8y_locales = [
            'c8yLocales',
            function (c8yLocales) {
                return c8yLocales.initDone;
            }
        ];
        var currentCfg = viewMap[newPath];
        var originalPath = newPath;
        if (!cfg.name) {
            // console.warn('View name not defined');
        }
        if (!currentCfg) {
            viewMap[newPath] = [];
            currentCfg = viewMap[newPath];
        }
        var upgradedContext = Object.keys(ViewContext)
            .map(function (key) { return ({
            key: key,
            isUpgrade: prefixWithSlash(ViewContext[key].replace('id', ViewContextLegacyParameter[key])) === path
        }); })
            .find(function (_a) {
            var isUpgrade = _a.isUpgrade;
            return isUpgrade;
        });
        if (upgradedContext) {
            currentCfg.push(cfg);
            cfg.path = newPath;
            var p = c8yPathUtils.appendSegment(originalPath.replace(path, ''), cfg.name);
            contextViews.next(__assign({}, cfg, { path: cfg.name ? p.substring(1) : '', contextKey: upgradedContext.key, runPhase: runPhase }));
            cfg.showIf = undefined;
            if (cfg.name) {
                cfg.path = c8yPathUtils.appendSegment(originalPath, cfg.name);
            }
        }
        else {
            if (currentCfg.length === 1) {
                var _a = __read(currentCfg, 1), existingConfig = _a[0];
                existingConfig.path = c8yPathUtils.appendSegment(originalPath, existingConfig.name);
                existingConfig.tab = createTab(originalPath, existingConfig);
                $routeProvider.when(existingConfig.path, existingConfig);
            }
            currentCfg.push(cfg);
            cfg.path = newPath;
            if (currentCfg.length > 1) {
                cfg.path = c8yPathUtils.appendSegment(originalPath, cfg.name);
                createTab(originalPath, cfg);
                $routeProvider.when(prefixWithSlash(originalPath), {
                    resolveRedirectTo: function ($route, $q, c8yUiUtil, c8yTabs, gettextCatalog) {
                        'ngInject';
                        var sortedCurrentCfg = c8yTabsProvider.sortTabsViews(currentCfg, gettextCatalog);
                        var params = $route.current.pathParams;
                        return $q
                            .all(map(sortedCurrentCfg, unary(c8yUiUtil.configureVisibility)))
                            .then(function (views) {
                            var first = find(views, 'show');
                            var url = first.path;
                            forEach(params, function (val, key) {
                                url = url.replace(":" + key, val);
                            });
                            c8yTabs.redirectedViewPath = url;
                            return url;
                        });
                    }
                });
            }
        }
        return $routeProvider.when(prefixWithSlash(cfg.path), cfg);
    }
    function getByPath(path) {
        return viewMap[prefixWithSlash(path)];
    }
    function createTab(path, cfg) {
        c8yTabsProvider.addTab(path, cfg);
    }
    function prefixWithSlash(path) {
        var prefix = startsWith(path, '/') ? '' : '/';
        return prefix + path;
    }
}

var BridgeService = /** @class */ (function () {
    function BridgeService(injector, appState, fetchClient, router, ngZone, routerService, actionService) {
        this.injector = injector;
        this.appState = appState;
        this.fetchClient = fetchClient;
        this.router = router;
        this.ngZone = ngZone;
        this.routerService = routerService;
        this.actionService = actionService;
        this.$liveTabs = new BehaviorSubject([]);
        this.fixE2eIssues();
        this.$ng1RouteChangeSuccess = this.fromNg1Event(this.injector.get('$rootScope'), '$routeChangeSuccess');
        this.$ng1RouteChangeStart = this.fromNg1Event(this.injector.get('$rootScope'), '$routeChangeStart');
        this.hookAuth();
        this.hookLanguage();
        this.hookTabs();
        this.hookNavigator();
        this.hookUserMenu();
        this.hookViewProvider();
        this.router.initialNavigation();
        this.ng1Routes();
    }
    BridgeService.prototype.hookViewProvider = function () {
        var _this = this;
        var c8yViews = this.injector.get('c8yViews');
        c8yViews.contextViews.subscribe(function (cfg) { return _this.addRoute(cfg); });
    };
    BridgeService.prototype.addRoute = function (cfg) {
        var _this = this;
        this.routerService.addRoute({
            label: cfg.label || cfg.name,
            path: cfg.path,
            icon: cfg.icon,
            context: ViewContext[cfg.contextKey],
            priority: cfg.priority,
            component: EmptyComponent,
            data: {
                showIf: cfg.showIf
                    ? function (ngxRoute) {
                        var _a;
                        var params = __assign({}, ngxRoute.params, (_a = {}, _a[ViewContextLegacyParameter[cfg.contextKey]] = ngxRoute.params.id, _a));
                        var showIfResult = _this.injector.invoke(cfg.showIf, undefined, {
                            $routeParams: params
                        });
                        // make sure showIf result is a promise with boolean result:
                        return _this.injector
                            .get('$q')
                            .when(showIfResult)
                            .then(Boolean);
                    }
                    : undefined
            }
        });
        if (cfg.runPhase) {
            this.router.navigateByUrl(this.router.url);
        }
    };
    BridgeService.prototype.ng1Routes = function () {
        var template = '';
        var fallbackRoutes = [];
        // tslint:disable-next-line: forin
        for (var context in ViewContext) {
            var path = ViewContext[context].match(/(\w+)\//)[1];
            var regexp = new RegExp("^/" + path + "/(?:([^/]+)).*$");
            fallbackRoutes.push({
                keys: [{ name: ViewContextLegacyParameter[context], optional: false }],
                regexp: regexp,
                template: template
            });
        }
        /**
         * When asset detail routes (/device/:id,  /group/:id) are matched in Angular Router, ngRoute in
         * angular.js must also have matching generic routes so that the ids can be extracted from the paths and
         * injected in multiple calls (showIf, c8yActions, etc) as properties of $routeParams.
         *
         * The function in src/ngRoute/route.js (angular.js) where the routes are matched is called parseRoute(). This
         * function calls angular.forEach and in turn this function checks for the presence of a forEach method before
         * trying object key iteration.
         * By attaching a non enumerable forEach method to the routes object we guarantee that the fallback generic routes
         * are only matched after any other registered through $routeProvider.when.
         */
        var $route = this.injector.get('$route');
        Object.defineProperty($route.routes, 'forEach', {
            // make non enumerable
            value: function forEach(iterator, context) {
                // tslint:disable-next-line: forin
                for (var key in this) {
                    iterator.call(context, this[key], key, this);
                }
                fallbackRoutes.forEach(function (r) { return iterator.call(context, r); });
            }
        });
        /**
         * Some functions use the current context. As some parts are upgraded and some not, the following updates the
         * angularjs getContext function to resolve always the right context.
         */
        var c8yUiUtil = this.injector.get('c8yUiUtil');
        var _getContext = c8yUiUtil.getContext;
        this.router.events
            .pipe(filter(function (event) { return event instanceof ActivationEnd; }))
            .subscribe(function (event) {
            if (event.snapshot.routeConfig.path === '**') {
                c8yUiUtil.getContext = _getContext;
            }
            else if (event.snapshot.data && event.snapshot.data.context) {
                c8yUiUtil.getContext = function () {
                    return {
                        context: event.snapshot.data.context.replace('/:id', ''),
                        id: event.snapshot.data.contextData.id
                    };
                };
            }
            else {
                c8yUiUtil.getContext = function () { return ({ context: null, id: null }); };
            }
        });
    };
    BridgeService.prototype.fixE2eIssues = function () {
        try {
            var ngZone_1 = this.ngZone;
            var Utils_1 = window.org.cometd.Utils;
            var timeoutFn_1 = Utils_1.setTimeout;
            // tslint:disable-next-line:only-arrow-functions
            Utils_1.setTimeout = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return ngZone_1.runOutsideAngular(function () { return timeoutFn_1.apply(Utils_1, args); });
            };
        }
        catch (e) {
            // do nothing
        }
        try {
            var ace_1 = window.ace;
            var editFn_1 = ace_1.edit;
            var ngZone_2 = this.ngZone;
            // tslint:disable-next-line:only-arrow-functions
            ace_1.edit = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return ngZone_2.runOutsideAngular(function () { return editFn_1.apply(ace_1, args); });
            };
        }
        catch (e) {
            // do nothing
        }
    };
    BridgeService.prototype.setToken = function (token, tfa, type) {
        if (type === void 0) { type = 'Basic'; }
        var c8yAuth = this.injector.get('c8yAuth');
        if (type === 'Basic') {
            c8yAuth.onSetToken({ token: token, type: type });
            if (tfa) {
                c8yAuth.setTFAToken(tfa);
            }
        }
        else {
            c8yAuth.authReady();
        }
    };
    BridgeService.prototype.hookAuth = function () {
        var _this = this;
        this.appState.currentUser.subscribe(function (u) {
            if (u) {
                var headers = _this.fetchClient.getFetchOptions({}).headers;
                _this.injector.get('c8yAuth').headers = function () { return _this.fetchClient.getFetchOptions({}).headers; };
                if (headers.Authorization) {
                    var token = headers.Authorization.match(/basic\s(.*)$/i)[1];
                    if (token) {
                        _this.setToken(token, headers.tfatoken);
                    }
                    else {
                        _this.setToken(token, headers.tfatoken, 'Oauth');
                    }
                }
                _this.injector.get('$rootScope').$emit('authStateChange', { hasAuth: true });
            }
            else {
                _this.injector.get('$rootScope').$emit('authStateChange', { hasAuth: false });
            }
        });
    };
    BridgeService.prototype.hookLanguage = function () {
        var _this = this;
        var first = true;
        this.appState
            .map(function (store) { return store.lang; })
            .subscribe(function (lang) {
            _this.injector.get('c8yLocales').switchToLanguage(lang);
            if (!first) {
                _this.injector.get('$rootScope').$apply();
            }
            first = false;
        });
    };
    BridgeService.prototype.hookTabs = function () {
        var _this = this;
        // Just for instantiation of the c8yAction service
        this.injector.get('c8yActions');
        var $location = this.injector.get('$location');
        var c8yTabs = this.injector.get('c8yTabs');
        var liveTabs = [];
        c8yTabs.addTab = function (tab) {
            liveTabs.push(__assign({}, tab, { label: tab.label || tab.name, path: decodeURIComponent(tab.path) }));
            _this.$liveTabs.next(liveTabs);
        };
        this.$ng1RouteChangeStart.subscribe(function (e) {
            liveTabs = [];
            _this.$liveTabs.next(liveTabs);
        });
        this.$ng1RouteChangeSuccess
            .subscribe(function (e) {
            var path = $location.path();
            if (_this.router.url !== path) {
                _this.router.navigate(path.split('/'), {
                    queryParams: $location.search(),
                    skipLocationChange: true
                });
            }
            if (_this.actionService) {
                _this.actionService.refresh();
            }
        });
        this.$routeChanges = this.$ng1RouteChangeSuccess.pipe(merge(this.fromNg1Event(c8yTabs, c8yTabs.EVENT_UPDATE), of(1)), debounceTime(100));
    };
    BridgeService.prototype.hookNavigator = function () {
        this.navigationNodes$ = this.injector.get('c8yNavigator').rootNodes$;
    };
    BridgeService.prototype.getTabs = function () {
        var _this = this;
        var onlyVisible = function (_a) {
            var show = _a.show;
            return show;
        };
        var upgradeTab = function (tab) { return (__assign({}, tab, { label: tab.label || tab.name, path: decodeURIComponent(tab.path) })); };
        var routeTabs = this.$routeChanges.pipe(switchMap(function () {
            var routes = _this.injector.get('c8yTabs').routeTabs;
            var visibilityPromise = Promise.all(routes.map(function (_a) {
                var checkingVisibility = _a.checkingVisibility;
                return checkingVisibility;
            }));
            return visibilityPromise.then(function () { return routes.filter(onlyVisible).map(upgradeTab); });
        }), startWith([]));
        return combineLatest(routeTabs, this.$liveTabs).pipe(map$1(function (_a) {
            var _b = __read(_a, 2), route = _b[0], live = _b[1];
            return route.concat(live);
        }));
    };
    BridgeService.prototype.getQuickLinks = function () {
        var c8yQuickLinks = this.injector.get('c8yQuickLinks');
        return c8yQuickLinks.list();
    };
    BridgeService.prototype.getActionBarItems = function () {
        var c8yActionBar = this.injector.get('c8yActionBar');
        var $rootScope = this.injector.get('$rootScope');
        var getActionBarElements = function () {
            return c8yActionBar.elements.map(function (element) { return ({
                priority: element.getAttribute('action-bar-priority') || 0,
                template: element,
                placement: element.getAttribute('action-bar-position') || 'right'
            }); });
        };
        return this.fromNg1Event($rootScope, 'c8yActionBarChanged').pipe(startWith(1), map$1(getActionBarElements));
    };
    BridgeService.prototype.getBreadcrumbs = function () {
        var $location = this.injector.get('$location');
        var path = $location.path();
        var c8yBreadcrumbs = this.injector.get('c8yBreadcrumbs');
        var breadcrumbs = c8yBreadcrumbs.get(path) || {};
        var breadcrumbsData = breadcrumbs.data ? this.injector.invoke(breadcrumbs.data) : of([]);
        return from(breadcrumbsData).pipe(map$1(function (value) {
            value = value.concat(c8yBreadcrumbs.getLiveBreadcrumbs());
            return value.map(function (items) { return ({ items: items.slice(0, items.length - 1) }); });
        }));
    };
    BridgeService.prototype.getSearch = function () {
        var c8ySearch = this.injector.get('c8ySearch');
        return c8ySearch.list().map(function (item) {
            return {
                icon: 'search',
                name: item.name,
                term: '',
                onSearch: function () {
                    if (this.term) {
                        c8ySearch.search(this.term);
                    }
                }
            };
        });
    };
    BridgeService.prototype.getActions = function () {
        var _this = this;
        var registeredActions = this.injector.get('c8yActions').registeredActions;
        return of(registeredActions
            .filter(function (action) { return !action.hidden; })
            .map(function (action) { return ({
            // The priority was reversed: Aligned it to dashboard, high first, low last.
            priority: (action.priority || 0) * -1,
            label: action.text,
            icon: action.icon,
            disabled: action.disabled,
            action: function () {
                _this.injector.invoke(action.action, action);
            }
        }); }));
    };
    BridgeService.prototype.fromNg1Event = function (obj, evt) {
        var stopListening;
        function add(handler) {
            stopListening = obj.$on(evt, handler);
        }
        return fromEventPattern(add, function () { return stopListening(); });
    };
    BridgeService.prototype.hookUserMenu = function () {
        var userMenuService = this.injector.get('c8yUserMenuService');
        var c8yAccessDenied = this.injector.get('c8yAccessDenied');
        userMenuService.add({
            icon: 'exclamation-triangle',
            priority: 10,
            label: gettext('Access denied requests'),
            click: c8yAccessDenied.showAccessDeniedRequestsList
        });
    };
    return BridgeService;
}());
function bridgeServiceFactory(injector, appState, fetchClient, router, ngZone, routerService, actionService) {
    return new BridgeService(injector, appState, fetchClient, router, ngZone, routerService, actionService);
}
var bridgeServiceProvider = {
    provide: BridgeService,
    useFactory: bridgeServiceFactory,
    deps: ['$injector', AppStateService, FetchClient, Router, NgZone, RouterService, ActionService]
};

var Ng1ActionBarFactoryService = /** @class */ (function () {
    function Ng1ActionBarFactoryService(bridge) {
        this.bridge = bridge;
        this.routeChanges$ = bridge.$routeChanges;
    }
    Ng1ActionBarFactoryService.prototype.get = function () {
        return this.bridge.getActionBarItems();
    };
    Ng1ActionBarFactoryService.ctorParameters = function () { return [
        { type: BridgeService }
    ]; };
    Ng1ActionBarFactoryService = __decorate([
        Injectable()
    ], Ng1ActionBarFactoryService);
    return Ng1ActionBarFactoryService;
}());

var Ng1ActionFactoryService = /** @class */ (function () {
    function Ng1ActionFactoryService(bridge, tabs) {
        var _this = this;
        this.bridge = bridge;
        this.tabs = tabs;
        this.routeChanges$ = bridge.$routeChanges;
        this.$location = bridge.injector.get('$location');
        this.tabs.items$.subscribe(function (newTabs) { return _this.handleTabsRedirect(newTabs); });
    }
    Ng1ActionFactoryService.prototype.handleTabsRedirect = function (tabs) {
        /**
         * This function is doing the same process as function redirect in the file
         * modules/core/ui/navigation/tabs.provider.js
         * That function  is not run because bridge.service.ts overrides the method addTab where the redirect() was called.
         */
        var redirectedTab = tabs.find(function (tab) { return tab.redirectedTo; });
        var _a = __read(tabs, 1), topPriorityTab = _a[0];
        if (redirectedTab && !topPriorityTab.redirectedTo) {
            this.$location.replace();
            this.$location.path(topPriorityTab.path);
            topPriorityTab.redirectedTo = true;
            redirectedTab.redirectedTo = false;
        }
    };
    Ng1ActionFactoryService.prototype.get = function () {
        return this.bridge.getActions();
    };
    Ng1ActionFactoryService.ctorParameters = function () { return [
        { type: BridgeService },
        { type: TabsService }
    ]; };
    Ng1ActionFactoryService = __decorate([
        Injectable()
    ], Ng1ActionFactoryService);
    return Ng1ActionFactoryService;
}());

var Ng1BreadcrumbFactoryService = /** @class */ (function () {
    function Ng1BreadcrumbFactoryService(bridge) {
        var _this = this;
        this.bridge = bridge;
        this.trigger = new ReplaySubject(1);
        this.breadcrumbs = this.trigger.pipe(debounceTime(100), switchMap(function () {
            return _this.bridge.getBreadcrumbs();
        }));
    }
    Ng1BreadcrumbFactoryService.prototype.get = function () {
        this.trigger.next();
        return this.breadcrumbs;
    };
    Ng1BreadcrumbFactoryService.ctorParameters = function () { return [
        { type: BridgeService }
    ]; };
    Ng1BreadcrumbFactoryService = __decorate([
        Injectable()
    ], Ng1BreadcrumbFactoryService);
    return Ng1BreadcrumbFactoryService;
}());

var Ng1NodesFactoryService = /** @class */ (function () {
    function Ng1NodesFactoryService(bridge) {
        this.bridge = bridge;
    }
    Ng1NodesFactoryService.prototype.get = function () {
        return this.bridge.navigationNodes$;
    };
    Ng1NodesFactoryService.ctorParameters = function () { return [
        { type: BridgeService }
    ]; };
    Ng1NodesFactoryService = __decorate([
        Injectable()
    ], Ng1NodesFactoryService);
    return Ng1NodesFactoryService;
}());

var Ng1SearchFactoryService = /** @class */ (function () {
    function Ng1SearchFactoryService(bridge) {
        this.bridge = bridge;
        this.search = this.bridge.getSearch();
    }
    Ng1SearchFactoryService.prototype.get = function () {
        return this.search;
    };
    Ng1SearchFactoryService.ctorParameters = function () { return [
        { type: BridgeService }
    ]; };
    Ng1SearchFactoryService = __decorate([
        Injectable()
    ], Ng1SearchFactoryService);
    return Ng1SearchFactoryService;
}());

var Ng1TabsFactoryService = /** @class */ (function () {
    function Ng1TabsFactoryService(bridge) {
        this.bridge = bridge;
        this.tabsObservable = bridge.getTabs();
    }
    Ng1TabsFactoryService.prototype.get = function () {
        return this.tabsObservable;
    };
    Ng1TabsFactoryService.ctorParameters = function () { return [
        { type: BridgeService }
    ]; };
    Ng1TabsFactoryService = __decorate([
        Injectable()
    ], Ng1TabsFactoryService);
    return Ng1TabsFactoryService;
}());

var Ng1DocsFactoryService = /** @class */ (function () {
    function Ng1DocsFactoryService(bridge) {
        this.bridge = bridge;
        this.links = this.bridge.getQuickLinks();
        this.links.then(function (list) {
            list.map(function (el) {
                el.type = el.type || 'quicklink';
                return el;
            });
        });
    }
    Ng1DocsFactoryService.prototype.get = function () {
        return this.links;
    };
    Ng1DocsFactoryService.ctorParameters = function () { return [
        { type: BridgeService }
    ]; };
    Ng1DocsFactoryService = __decorate([
        Injectable()
    ], Ng1DocsFactoryService);
    return Ng1DocsFactoryService;
}());

var UpgradeModule = /** @class */ (function () {
    function UpgradeModule() {
    }
    UpgradeModule = __decorate([
        NgModule({
            imports: [RouterModule],
            exports: [],
            providers: [
                bridgeServiceProvider,
                { provide: HOOK_NAVIGATOR_NODES, useClass: Ng1NodesFactoryService, multi: true },
                { provide: HOOK_TABS, useClass: Ng1TabsFactoryService, multi: true },
                { provide: HOOK_ACTION_BAR, useClass: Ng1ActionBarFactoryService, multi: true },
                { provide: HOOK_ACTION, useClass: Ng1ActionFactoryService, multi: true },
                { provide: HOOK_BREADCRUMB, useClass: Ng1BreadcrumbFactoryService, multi: true },
                { provide: HOOK_SEARCH, useClass: Ng1SearchFactoryService, multi: true },
                { provide: HOOK_DOCS, useClass: Ng1DocsFactoryService, multi: true }
            ]
        })
    ], UpgradeModule);
    return UpgradeModule;
}());

var DashboardBridgeService = /** @class */ (function () {
    function DashboardBridgeService(ng1Injector, zone, router, contextDashboardService) {
        this.ng1Injector = ng1Injector;
        this.zone = zone;
        this.router = router;
        this.contextDashboardService = contextDashboardService;
        this.dashboardSvc = ng1Injector.get('dashboardSvc');
        this.compile = ng1Injector.get('$compile');
    }
    Object.defineProperty(DashboardBridgeService.prototype, "ng1Components", {
        get: function () {
            return this.ng1Injector.get('c8yComponents');
        },
        enumerable: true,
        configurable: true
    });
    DashboardBridgeService.prototype.instantiateComponent = function (widget, element) {
        return __awaiter(this, void 0, void 0, function () {
            var dashboard, context, child, transformedChild_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        dashboard = widget.dashboard, context = widget.context, child = widget.child;
                        if (!dashboard) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.dashboardSvc.transformChildWithContext(this.dashboardSvc.forcedContext || context, dashboard, child)];
                    case 1:
                        transformedChild_1 = _a.sent();
                        if (!(this.dashboardSvc.forcedContext || dashboard.deviceType)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.dashboardSvc.updateConfigTargetsWithContext(this.dashboardSvc.forcedContext || context, transformedChild_1.config)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2 /*return*/, this.zone.runOutsideAngular(function () {
                            return _this.loadTemplate(transformedChild_1, child, element, context);
                        })];
                    case 4: return [2 /*return*/, this.loadConfigTemplate(element, widget)];
                }
            });
        });
    };
    DashboardBridgeService.prototype.editDashboard = function (dashboard) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.dashboardSvc.editCurrentDashboard({ dashboardId: dashboard.id })];
            });
        });
    };
    DashboardBridgeService.prototype.copyDashboard = function () {
        var dashboard = this.getDashboard();
        var couldCopy = this.dashboardSvc.copyDashboard(dashboard.c8y_Dashboard);
        if (couldCopy) {
            this.dashboardClipboard = dashboard;
            return dashboard;
        }
    };
    DashboardBridgeService.prototype.pasteDashboard = function () {
        return __awaiter(this, void 0, void 0, function () {
            var newDashboard, ex_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 3, , 4]);
                        return [4 /*yield*/, this.dashboardSvc.pasteDashboard()];
                    case 1:
                        newDashboard = _a.sent();
                        return [4 /*yield*/, this.contextDashboardService.addTab(newDashboard)];
                    case 2:
                        _a.sent();
                        this.navigateToDashboard(newDashboard);
                        this.dashboardClipboard = undefined;
                        return [3 /*break*/, 4];
                    case 3:
                        ex_1 = _a.sent();
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    DashboardBridgeService.prototype.instantiateDeviceSelector = function (element, widgetConfig) {
        return this.loadConfigTemplate(element, widgetConfig, true);
    };
    DashboardBridgeService.prototype.loadTemplate = function (transformedChild, child, element, context) {
        var scope = this.ng1Injector.get('$rootScope').$new(true);
        scope.child = transformedChild;
        scope.dashboardContext = context;
        if (child.widgetComponent) {
            element.innerHTML = "<c8y-ui-component component-name=\"'" + child.widgetComponent + "'\" config=\"child.config\" context=\"dashboardContext\"></c8y-ui-component>";
        }
        else if (child.templateUrl) {
            element.innerHTML = "<ng-include src=\"'" + child.templateUrl + "'\"></ng-include>";
        }
        this.compile(element)(scope);
        return scope;
    };
    DashboardBridgeService.prototype.navigateToDashboard = function (dashboard) {
        if (/dashboard/.test(this.router.url)) {
            this.router.navigate(['..', dashboard.id], {
                relativeTo: getActivatedRoute(this.router)
            });
        }
        else {
            this.router.navigate(['..', 'dashboard', dashboard.id], {
                relativeTo: getActivatedRoute(this.router)
            });
        }
    };
    DashboardBridgeService.prototype.getDashboard = function () {
        return getActivatedRoute(this.router).snapshot.data.dashboard;
    };
    DashboardBridgeService.prototype.loadConfigTemplate = function (element, widgetConfig, onlyDeviceSelector) {
        var _this = this;
        if (onlyDeviceSelector === void 0) { onlyDeviceSelector = false; }
        var settings = widgetConfig.settings;
        var scope = this.ng1Injector.get('$rootScope').$new(true);
        scope.settings = __assign({}, settings, settings.ng1);
        scope.options = widgetConfig.options;
        scope.config = widgetConfig;
        scope.forms = {};
        scope.dashboard = widgetConfig.dashboardMo;
        scope.rootId = settings.context.id;
        var configCmp = '';
        if (!onlyDeviceSelector) {
            if (widgetConfig.settings.configComponent) {
                configCmp = "<c8y-ui-component component-name=\"'" + widgetConfig.settings.configComponent + "'\" config=\"config\"></c8y-ui-component>";
            }
            else if (widgetConfig.settings.configTemplateUrl) {
                configCmp = "<ng-include src=\"'" + widgetConfig.settings.configTemplateUrl + "'\"></ng-include>";
            }
        }
        element.innerHTML = "\n    <ng-form name=\"forms.componentForm\">\n      <div class=\"form-group\"\n        ng-if=\"!settings.noDeviceTarget\"\n        ng-style=\"{height: settings.hideTarget && '0', overflow: 'hidden'}\"\n      >\n        <label translate>" + gettext('Target assets or devices') + "</label>\n        <c8y-device-selector-combo parent=\"rootId\"\n          selected-child-device=\"config.device\"\n          groups-selectable=\"settings.groupsSelectable\"\n        ></c8y-device-selector-combo>\n      </div>\n      " + configCmp + "\n    </ng-form>";
        scope.$watch('forms.componentForm.$invalid', function (formStatus) {
            _this.contextDashboardService.formDisabled = formStatus;
        });
        this.compile(element)(scope);
        this.contextDashboardService.formDisabled = scope.forms.componentForm.$invalid;
        return scope;
    };
    DashboardBridgeService.ctorParameters = function () { return [
        { type: undefined },
        { type: NgZone },
        { type: Router },
        { type: ContextDashboardService }
    ]; };
    DashboardBridgeService = __decorate([
        Injectable()
    ], DashboardBridgeService);
    return DashboardBridgeService;
}());

var WidgetComponent = /** @class */ (function () {
    function WidgetComponent(dashboardBridgeService, el) {
        this.dashboardBridgeService = dashboardBridgeService;
        this.el = el;
    }
    WidgetComponent.prototype.ngOnInit = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this;
                        return [4 /*yield*/, this.dashboardBridgeService.instantiateComponent(this.config, this.el.nativeElement)];
                    case 1:
                        _a.ng1Scope = _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    WidgetComponent.prototype.ngOnDestroy = function () {
        if (this.ng1Scope) {
            this.ng1Scope.$destroy();
        }
    };
    WidgetComponent.ctorParameters = function () { return [
        { type: DashboardBridgeService },
        { type: ElementRef }
    ]; };
    WidgetComponent = __decorate([
        Component({
            selector: 'c8y-widget-legacy',
            template: '',
            changeDetection: ChangeDetectionStrategy.OnPush
        })
    ], WidgetComponent);
    return WidgetComponent;
}());

var DeviceSelectorComponent = /** @class */ (function () {
    function DeviceSelectorComponent(dashboardBridgeService, el) {
        this.dashboardBridgeService = dashboardBridgeService;
        this.el = el;
    }
    DeviceSelectorComponent.prototype.ngOnInit = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.ng1Scope = this.dashboardBridgeService.instantiateDeviceSelector(this.el.nativeElement, this.config);
                return [2 /*return*/];
            });
        });
    };
    DeviceSelectorComponent.prototype.ngOnDestroy = function () {
        if (this.ng1Scope) {
            this.ng1Scope.$destroy();
        }
    };
    DeviceSelectorComponent.ctorParameters = function () { return [
        { type: DashboardBridgeService },
        { type: ElementRef }
    ]; };
    DeviceSelectorComponent = __decorate([
        Component({
            selector: 'c8y-device-selector-legacy',
            template: '',
            changeDetection: ChangeDetectionStrategy.OnPush
        })
    ], DeviceSelectorComponent);
    return DeviceSelectorComponent;
}());

var Ng1ComponentFactoryService = /** @class */ (function () {
    function Ng1ComponentFactoryService(bridge) {
        this.bridge = bridge;
    }
    Ng1ComponentFactoryService.prototype.get = function () {
        return __awaiter(this, void 0, void 0, function () {
            var components;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.bridge.ng1Components.list()];
                    case 1:
                        components = (_a.sent()).map(function (cmp) {
                            var data = {
                                settings: __assign({}, cmp.options, { configTemplateUrl: cmp.configTemplateUrl, widgetComponent: cmp.widgetComponent, configComponent: cmp.configComponent, transformConfigWithContext: cmp.transformConfigWithContext || cmp.componentTransformConfigWithContext, upgrade: true })
                            };
                            data.settings.templateUrl = cmp.templateUrl; // workaround as in object it creates build error
                            return {
                                id: cmp.name,
                                label: cmp.nameDisplay || cmp.name,
                                description: cmp.description,
                                component: WidgetComponent,
                                configComponent: WidgetComponent,
                                previewImage: cmp.previewImage,
                                data: data
                            };
                        });
                        // add the device selector legacy component
                        components.push({
                            id: 'device.selector.legacy',
                            label: 'Device selector',
                            description: '',
                            data: { settings: { noNewWidgets: true, upgrade: true } },
                            component: DeviceSelectorComponent
                        });
                        return [2 /*return*/, components];
                }
            });
        });
    };
    Ng1ComponentFactoryService.ctorParameters = function () { return [
        { type: DashboardBridgeService }
    ]; };
    Ng1ComponentFactoryService = __decorate([
        Injectable()
    ], Ng1ComponentFactoryService);
    return Ng1ComponentFactoryService;
}());

var CopyActionComponent = /** @class */ (function () {
    function CopyActionComponent(vcRef, dashboardBridgeService) {
        this.vcRef = vcRef;
        this.dashboardBridgeService = dashboardBridgeService;
    }
    CopyActionComponent.prototype.ngOnInit = function () {
        this.vcRef.createEmbeddedView(this.templateCopy);
    };
    CopyActionComponent.prototype.copyDashboard = function () {
        this.dashboardBridgeService.copyDashboard();
    };
    CopyActionComponent.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: DashboardBridgeService }
    ]; };
    __decorate([
        ViewChild('templateCopy', { read: TemplateRef, static: true })
    ], CopyActionComponent.prototype, "templateCopy", void 0);
    CopyActionComponent = __decorate([
        Component({
            selector: 'c8y-copy-action-legacy',
            template: "\n    <ng-template #templateCopy>\n      <li>\n        <button title=\"{{'Copy dashboard' | translate}}\" (click)=\"copyDashboard()\">\n          <i class=\"fa fw fa-clone\"></i>&nbsp;<span translate>Copy dashboard</span>\n        </button>\n      </li>\n    </ng-template>\n  "
        })
    ], CopyActionComponent);
    return CopyActionComponent;
}());

var PasteActionComponent = /** @class */ (function () {
    function PasteActionComponent(vcRef, dashboardBridgeService) {
        this.vcRef = vcRef;
        this.dashboardBridgeService = dashboardBridgeService;
        this.dashboardName = '';
    }
    PasteActionComponent.prototype.ngOnInit = function () {
        this.vcRef.createEmbeddedView(this.templatePaste);
        this.dashboardName = this.dashboardBridgeService.dashboardClipboard.c8y_Dashboard.name;
    };
    PasteActionComponent.prototype.pasteDashboard = function () {
        this.dashboardBridgeService.pasteDashboard();
    };
    PasteActionComponent.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: DashboardBridgeService }
    ]; };
    __decorate([
        ViewChild('templatePaste', { read: TemplateRef, static: true })
    ], PasteActionComponent.prototype, "templatePaste", void 0);
    PasteActionComponent = __decorate([
        Component({
            selector: 'c8y-copy-action-legacy',
            template: "\n    <ng-template #templatePaste>\n      <li>\n        <button title=\"{{'Paste dashboard' | translate}}\" (click)=\"pasteDashboard()\">\n          <i class=\"fa fw fa-clipboard\"></i>&nbsp;<span translate>Paste dashboard</span>&nbsp;<span\n            >\"{{ dashboardName }}\"</span\n          >\n        </button>\n      </li>\n    </ng-template>\n  "
        })
    ], PasteActionComponent);
    return PasteActionComponent;
}());

var Ng1DashboardActionFactoryService = /** @class */ (function () {
    function Ng1DashboardActionFactoryService(dashboardBridgeService) {
        this.dashboardBridgeService = dashboardBridgeService;
    }
    Ng1DashboardActionFactoryService.prototype.get = function (activeRoute) {
        var actions = [];
        var data = !activeRoute.parent || activeRoute.snapshot.data.context
            ? activeRoute.snapshot.data
            : activeRoute.parent.snapshot.data;
        var contextData = data.contextData;
        var isDashboard = contextData && activeRoute.snapshot.data.dashboard;
        var canPaste = contextData &&
            [ViewContext.Device, ViewContext.Group].includes(data.context) &&
            this.dashboardBridgeService.dashboardClipboard;
        if (isDashboard) {
            actions.push({
                priority: -20,
                placement: 'more',
                template: CopyActionComponent
            });
        }
        if (canPaste) {
            actions.push({
                priority: -10,
                placement: 'more',
                template: PasteActionComponent
            });
        }
        return actions;
    };
    Ng1DashboardActionFactoryService.ctorParameters = function () { return [
        { type: DashboardBridgeService }
    ]; };
    Ng1DashboardActionFactoryService = __decorate([
        Injectable()
    ], Ng1DashboardActionFactoryService);
    return Ng1DashboardActionFactoryService;
}());

var DashboardUpgradeModule = /** @class */ (function () {
    function DashboardUpgradeModule() {
    }
    DashboardUpgradeModule = __decorate([
        NgModule({
            declarations: [DeviceSelectorComponent, WidgetComponent, CopyActionComponent, PasteActionComponent],
            entryComponents: [DeviceSelectorComponent, WidgetComponent, CopyActionComponent, PasteActionComponent],
            imports: [CommonModule, TranslateModule],
            providers: [
                {
                    provide: DashboardBridgeService,
                    useFactory: dashboardBridgeFactory,
                    deps: ['$injector', NgZone, Router, [new Optional(), ContextDashboardService]]
                },
                { provide: HOOK_COMPONENTS, useClass: Ng1ComponentFactoryService, multi: true },
                { provide: HOOK_ACTION_BAR, useClass: Ng1DashboardActionFactoryService, multi: true }
            ]
        })
    ], DashboardUpgradeModule);
    return DashboardUpgradeModule;
}());
function dashboardBridgeFactory(injector, ngZone, router, contextDashboardService) {
    return new DashboardBridgeService(injector, ngZone, router, contextDashboardService);
}

function c8yAlertDecorator($delegate, $rootScope, $injector) {
    'ngInject';
    $delegate.add = function (alert) {
        $delegate.addAlert(transformAlert(alert));
    };
    $rootScope.$on('alert', function (evt, alert) {
        $delegate.addAlert(transformAlert(alert));
    });
    $rootScope.$on('message', function (evt, alert) {
        $delegate.addAlert(transformAlert(alert));
    });
    for (var property in $delegate) {
        if (typeof $delegate[property] === 'function') {
            $delegate[property] = $delegate[property].bind($delegate);
        }
    }
    function transformAlert(alert) {
        var newAlert = __assign({}, alert);
        if (alert.onClose) {
            newAlert.onClose = function () {
                $injector.invoke(alert.onClose);
            };
        }
        if (alert.onDetail) {
            newAlert.onDetail = function () {
                $injector.invoke(alert.onDetail);
            };
        }
        return newAlert;
    }
    return $delegate;
}

var bootstrapComponent = downgradeComponent({ component: BootstrapComponent });
var userTotpComponent = downgradeComponent({ component: UserTotpRevokeComponent });
var appLogsAutoRefreshComponent = downgradeComponent({
    component: AppLogsAutoRefreshComponent
});
var dataGridComponent = downgradeComponent({ component: DataGridComponent });

var ServerMessagesService = /** @class */ (function () {
    function ServerMessagesService(translateService, patterns) {
        this.translateService = translateService;
        this.MESSAGE_PATTERNS = patterns;
    }
    ServerMessagesService.prototype.translate = function (s) {
        return this.translateService.instant(s);
    };
    ServerMessagesService.ctorParameters = function () { return [
        { type: TranslateService },
        { type: undefined, decorators: [{ type: Inject, args: [HOOK_PATTERN_MESSAGES,] }] }
    ]; };
    ServerMessagesService = __decorate([
        Injectable(),
        __param(1, Inject(HOOK_PATTERN_MESSAGES))
    ], ServerMessagesService);
    return ServerMessagesService;
}());

var bridgeService = downgradeInjectable(BridgeService);
var appStateService = downgradeInjectable(AppStateService);
var headerService = downgradeInjectable(HeaderService);
var alertsService = downgradeInjectable(AlertService);
var userMenuService = downgradeInjectable(UserMenuService);
var apiService = downgradeInjectable(ApiService);
var docsService = downgradeInjectable(DocsService);
var passwordService = downgradeInjectable(PasswordService);
var translateService = downgradeInjectable(TranslateService);
var serverMessagesService = downgradeInjectable(ServerMessagesService);

function gettextCatalogDecorator($delegate, $interpolate, c8yTranslate) {
    'ngInject';
    var gettextCatalog = $delegate;
    var originalGetString = bind(gettextCatalog, gettextCatalog.getString);
    function newGetString(input, scope, context) {
        if (typeof input === 'string') {
            var translatedString = originalGetString(input, scope, context);
            var interpolatedString = scope ? $interpolate(input)(scope) : input;
            var stringToReturn = translatedString;
            if (translatedString && translatedString === interpolatedString) {
                var translatedServerMessage = c8yTranslate.instant(interpolatedString);
                stringToReturn = translatedServerMessage;
            }
            return stringToReturn;
        }
        return input;
    }
    gettextCatalog.getString = newGetString;
    return gettextCatalog;
}

function groupTypesHierarchyNavigatorDecorator($delegate, $q) {
    'ngInject';
    $delegate.loadAll = function () { return $q.when(); };
    $delegate.addGroupNavigation = function () { return $q.when(); };
    return $delegate;
}

function c8yNg1HttpInterceptor($q, c8yLoadingIndicator, c8yApiService) {
    'ngInject';
    function request(config) {
        var url = config.url, method = config.method;
        c8yApiService.onStart({ url: url, method: method, options: config });
        return config;
    }
    function requestError(rejection) {
        finishRequest(rejection);
        return $q.reject(rejection);
    }
    function response(res) {
        finishRequest(res);
        return res;
    }
    function responseError(rejection) {
        finishRequest(rejection);
        c8yLoadingIndicator.responseError(rejection);
        return $q.reject(rejection);
    }
    function finishRequest(res) {
        var _a = res.config, url = _a.url, method = _a.method;
        c8yApiService.onFinish({
            url: url,
            method: method,
            response: res,
            options: res.config
        });
    }
    return {
        request: request,
        requestError: requestError,
        response: response,
        responseError: responseError
    };
}

var NavigatorNodeRootLegacy = /** @class */ (function (_super) {
    __extends(NavigatorNodeRootLegacy, _super);
    function NavigatorNodeRootLegacy() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NavigatorNodeRootLegacy.prototype.addRoot = function (nodeData) {
        var duplicate;
        if (nodeData.path === '') {
            nodeData.path = '/';
        }
        nodeData.label = nodeData.name;
        if (typeof nodeData.parent === 'object') {
            nodeData.parent.label = nodeData.parent.name;
        }
        if (nodeData.preventDuplicates) {
            duplicate = this.find(function (_a) {
                var path = _a.path, parents = _a.parents, label = _a.label;
                return path === nodeData.path &&
                    (label === nodeData.label) &&
                    parents.some(function (p) { return p.label === nodeData.parent; });
            });
            if (duplicate) {
                duplicate.routerLinkExact = false;
            }
        }
        return duplicate || _super.prototype.addRoot.call(this, nodeData);
    };
    NavigatorNodeRootLegacy.prototype.createNode = function (node) {
        var newNode = _super.prototype.createNode.call(this, node);
        var update = newNode.update.bind(newNode);
        var root = this;
        return Object.defineProperties(assign(newNode, {
            realName: newNode.name || newNode.label,
            _parent: true,
            update: function (data) {
                if (this._parent === undefined) {
                    // _parent was deleted somene instead to put this in root
                    root.addRoot(this);
                    // put it back so it can be deleted again
                    this._parent = true;
                }
                update(data);
            },
            addChild: function (nodeChild) {
                this.add(root.createNode(nodeChild));
            }
        }), {
            label: {
                get: function () {
                    return this.realName || '';
                },
                set: function (name) {
                    this.realName = name;
                }
            },
            name: {
                get: function () {
                    return this.realName || '';
                },
                set: function (name) {
                    this.realName = name;
                }
            },
            show: {
                get: function () {
                    return !this.hidden;
                },
                set: function (show) {
                    this.hidden = !show;
                }
            }
        });
    };
    return NavigatorNodeRootLegacy;
}(NavigatorNodeRoot));

// Just to hook into the bridge service
function c8yNavigatorProvider() {
    var root = new NavigatorNodeRootLegacy();
    var rootNodesSubject = new Subject();
    var conditionalNodes = [];
    var rootNodes$ = rootNodesSubject.pipe(merge(defer(function () { return of(root.children); })));
    function addNavigation(nodes) {
        var nodeList = (Array.isArray(nodes) ? nodes : [nodes]);
        nodeList.forEach(function (node) {
            if (isConditional(node)) {
                node.hidden = undefined;
                conditionalNodes.push(node);
            }
            node.navNode = root.addRoot(node);
        });
        rootNodesSubject.next(root.children);
    }
    function removeNavigation(node) {
        var found = root.find(function (n) { return n === node; });
        if (found) {
            found.parents.forEach(function (p) { return p.remove(found); });
            rootNodesSubject.next(root.children);
        }
    }
    function findNode(node) {
        return root.find(node);
    }
    function isConditional(node) {
        return node.showIf || node.showIfPermissions || node.showIfContainsVisibleViews;
    }
    function $get($q, $injector) {
        'ngInject';
        // This avoids the circular dependency
        setTimeout(function () { return conditionalNodes.forEach(processShowIf); });
        function processShowIf(node) {
            var c8yUiUtil = $injector.get('c8yUiUtil');
            var visibilityPromises = [];
            var showIf = node.showIf, showIfPermissions = node.showIfPermissions, showIfContainsVisibleViews = node.showIfContainsVisibleViews;
            if (showIf) {
                visibilityPromises.push($injector.invoke(showIf));
            }
            if (showIfContainsVisibleViews) {
                visibilityPromises.push(viewsConditionalVisibility(node));
            }
            c8yUiUtil.configureVisibility({
                showIf: function () { return $q.all(visibilityPromises).then(every); },
                showIfPermissions: showIfPermissions
            }, 'visible')
                .then(function (_a) {
                var visible = _a.visible;
                if (visible) {
                    node.navNode.update({
                        hidden: false,
                        showIf: null,
                        showIfPermission: null,
                        showIfContainsVisibleViews: null
                    });
                }
                else {
                    node.navNode.update({
                        hidden: true
                    });
                }
            });
        }
        function viewsConditionalVisibility(node) {
            var c8yUiUtil = $injector.get('c8yUiUtil');
            var c8yViews = $injector.get('c8yViews');
            var views = c8yViews.getByPath(node.path);
            return $q.all(map(views, function (view) { return c8yUiUtil
                .configureVisibility(pick(view, ['showIf', 'showIfPermissions']), 'show', false)
                .then(property('show')); }))
                .then(some);
        }
        return {
            rootNodes: function () {
                return root.children;
            },
            findNode: findNode,
            addNavigation: addNavigation,
            removeNavigation: removeNavigation,
            rootNodes$: rootNodes$
        };
    }
    return {
        $get: $get,
        addNavigation: addNavigation,
        removeNavigation: removeNavigation
    };
}

var rootComponent = {
    template: "\n  <c8y-bootstrap>\n    <div id=\"c8y-legacy-view\">\n      <div ng-view ng-if=\"vm.widthSet && vm.authState.hasAuth\"></div>\n    </div>\n  </c8y-bootstrap>",
    controller: c8yUiRootController,
    controllerAs: 'vm'
};
function c8yUiRootController($rootScope, $timeout, c8yBase, c8yNavigator, c8yApplication, c8yHeaderService) {
    'ngInject';
    var vm = this;
    Object.assign(vm, {
        $onInit: $onInit,
        navOpen: false
    });
    ////////////
    function $onInit() {
        c8yHeaderService.map(function (states) { return states.nav.open; }).subscribe(function (isOpen) {
            vm.navOpen = isOpen;
        });
        c8yHeaderService.configNavigator({ canToggle: true });
        $rootScope.$on('authStateChange', onAuthStateChange);
        vm.rootNodes = c8yNavigator.rootNodes;
        c8yApplication.currentAppCached().then(onAppInfo);
        vm.navHiddenOnStartup = c8yBase.appOption('hide_navigator');
        checkReady();
    }
    function onAuthStateChange(evt, data) {
        vm.authState = data;
    }
    function onAppInfo() {
        vm.tabsHorizontal = c8yBase.appOption('tabsHorizontal');
    }
    function checkReady() {
        var element = document.querySelector('#c8y-legacy-view');
        var hasWidth = element && element.clientWidth;
        if (hasWidth) {
            vm.widthSet = true;
        }
        else {
            $timeout(checkReady);
        }
    }
}

function c8yTitleDecorator($q, $delegate, $injector, $rootScope, $location, $templateCache, $compile, c8yHeaderService) {
    'ngInject';
    $delegate.changeTitle = changeTitle;
    $delegate.setTitleElement = setTitleElement;
    $rootScope.$on('$routeChangeStart', function () {
        changeTitle({});
    });
    $rootScope.$on('$routeChangeSuccess', function (event) {
        var title = $delegate.get($location.path());
        if (title) {
            var titleData = $q.when(title.data ? $injector.invoke(title.data) : {});
            titleData.then(function (data) {
                var templateUrl = data.templateUrl;
                if (templateUrl) {
                    var template = $templateCache.get(templateUrl);
                    setTitleElement($compile(template)(event.targetScope));
                }
                else {
                    changeTitle(data);
                }
            });
        }
    });
    function changeTitle(newTitle) {
        $q.when(newTitle).then(function (title) { return changeTitleInAngular(translate(title)); });
    }
    function translate(_a) {
        var title = _a.title, subtitle = _a.subtitle;
        var isolatedScope = $rootScope.$new(true);
        isolatedScope.title = title;
        isolatedScope.subtitle = subtitle;
        return $compile(element("\n      <h1 class=\"text-truncate\">{{title | translate}}\n      <small>{{ subtitle | translate }}</small></h1>\n    "))(isolatedScope)[0];
    }
    function changeTitleInAngular(domElement) {
        c8yHeaderService.changeTitle(domElement);
    }
    function setTitleElement($element) {
        $element.show();
        changeTitleInAngular($element[0]);
    }
    return $delegate;
}

var NAME = 'c8y.upgrade';
window.preventNg1Bootstrap = true;
module(NAME, [])
    .config(function ($httpProvider) {
    'ngInject';
    var ng1InterceptorIndex = $httpProvider.interceptors.indexOf('c8yLoadingIndicator');
    if (ng1InterceptorIndex > -1) {
        $httpProvider.interceptors.splice(ng1InterceptorIndex, 1);
    }
    $httpProvider.interceptors.push(c8yNg1HttpInterceptor);
})
    .component('c8yUiRoot', rootComponent)
    .directive('c8yBootstrap', bootstrapComponent)
    .factory('c8yBridgeService', bridgeService)
    .factory('c8yAppStateService', appStateService)
    .factory('c8yHeaderService', headerService)
    .factory('c8yUserMenuService', userMenuService)
    .decorator('c8yTitle', c8yTitleDecorator)
    .factory('c8yAlert', alertsService)
    .decorator('c8yAlert', c8yAlertDecorator)
    .decorator('groupTypesHierarchyNavigator', groupTypesHierarchyNavigatorDecorator) // prevents loading the groups
    .factory('c8yApiService', apiService)
    .factory('c8yDocs', docsService)
    .service('c8yPasswordConfirm', passwordService);
module('c8y.ui')
    .provider('c8yNavigator', c8yNavigatorProvider)
    .provider('c8yViews', c8yViewsProvider)
    .directive('c8yUserTotpRevoke', userTotpComponent)
    .directive('c8yAppLogsAutoRefresh', appLogsAutoRefreshComponent)
    .directive('c8yDataGrid', dataGridComponent)
    .factory('c8yTranslate', translateService)
    .decorator('gettextCatalog', gettextCatalogDecorator)
    .factory('c8yServerMessages', serverMessagesService)
    .factory('ngZone', downgradeInjectable(NgZone));
var ng1Modules = ['app', NAME];

var HybridAppModule = /** @class */ (function () {
    function HybridAppModule() {
        this.ng1Modules = ng1Modules;
    }
    HybridAppModule.prototype.ngDoBootstrap = function () {
        window.bootstrap();
        this.upgrade.bootstrap(document.getElementById('app'), this.ng1Modules, { strictDi: false });
    };
    return HybridAppModule;
}());

var UPGRADE_ROUTES = [
    { path: '**', component: EmptyComponent }
];

/**
 * Generated bundle index. Do not edit.
 */

export { BridgeService, DashboardBridgeService, DashboardUpgradeModule, HybridAppModule, UPGRADE_ROUTES, UpgradeModule, ng1Modules, bridgeServiceFactory as a, bridgeServiceProvider as b, dashboardBridgeFactory as c, Ng1NodesFactoryService as d, Ng1TabsFactoryService as e, Ng1ActionBarFactoryService as f, Ng1ActionFactoryService as g, Ng1BreadcrumbFactoryService as h, Ng1SearchFactoryService as i, Ng1DocsFactoryService as j, DeviceSelectorComponent as k, WidgetComponent as l, CopyActionComponent as m, PasteActionComponent as n, Ng1ComponentFactoryService as o, Ng1DashboardActionFactoryService as p };
//# sourceMappingURL=c8y-ngx-components-upgrade.js.map
