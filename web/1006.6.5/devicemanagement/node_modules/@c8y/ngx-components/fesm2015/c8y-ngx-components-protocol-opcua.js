import { __awaiter, __decorate, __param } from 'tslib';
import { NestedTreeControl, CdkTreeModule } from '@angular/cdk/tree';
import { Router, RouterModule } from '@angular/router';
import { Injectable, EventEmitter, Input, Output, Component, ElementRef, Injector, Directive, ViewChild, ChangeDetectorRef, ViewChildren, Optional, forwardRef, NgModule } from '@angular/core';
import { AlertService, gettext, AppStateService, DropAreaComponent, ContextRouteComponent, ViewContext, CoreModule, FormsModule, DropAreaModule, DeviceStatusModule, HOOK_ONCE_ROUTE } from '@c8y/ngx-components';
import { ButtonsModule } from 'ngx-bootstrap/buttons';
import { FetchClient, InventoryService } from '@c8y/client';
import { BehaviorSubject, merge } from 'rxjs';
import { omit, get as get$1, cloneDeep as cloneDeep$1, isEmpty as isEmpty$1, some, isEqual } from 'lodash-es';
import { assign, cloneDeep, isEmpty, get, unset, find, findIndex, omit as omit$1, pick, toInteger, set, clone } from 'lodash';
import { ControlContainer, NgModelGroup, NgForm, NG_VALIDATORS, ReactiveFormsModule } from '@angular/forms';
import { UpgradeComponent, downgradeComponent } from '@angular/upgrade/static';
import { TranslateService } from '@ngx-translate/core';
import { CollapseModule } from 'ngx-bootstrap/collapse';
import { BsDropdownModule } from 'ngx-bootstrap/dropdown';
import { TooltipModule } from 'ngx-bootstrap/tooltip';
import { PopoverModule } from 'ngx-bootstrap/popover';
import { map } from 'rxjs/operators';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { module } from 'angular';
import { registerNgModule } from '@c8y/ng1-modules/core/bootstrap';

let AddressSpaceService = class AddressSpaceService {
    constructor(fetchClient) {
        this.client = fetchClient;
        this.microserviceUrl = '/service/opcua-mgmt-service/address-space';
        this.header = { 'Content-Type': 'application/json' };
        this.nodeNavigationData$ = new BehaviorSubject({
            node: undefined,
            selectedAncestorIds: []
        });
    }
    resetTreeToRootNode() {
        this.triggerNodeToOpen({ node: undefined, selectedAncestorIds: [] });
    }
    triggerNodeToOpen(nodeNavigationData) {
        this.nodeNavigationData$.next(nodeNavigationData);
    }
    getNodeNavData$() {
        return this.nodeNavigationData$.asObservable();
    }
    getNode(serverId, nodeId) {
        if (serverId && serverId.length > 0) {
            if (nodeId && nodeId.length > 0) {
                return this.getNodeById(serverId, nodeId);
            }
            return this.getRootNode(serverId);
        }
    }
    getRootNode(serverId) {
        if (serverId && serverId.length > 0) {
            const options = {
                method: 'GET',
                headers: this.header
            };
            return this.client.fetch(`${this.microserviceUrl}/${serverId}`, options);
        }
    }
    getNodeById(serverId, nodeId) {
        if (serverId && nodeId && serverId.length > 0 && nodeId.length > 0) {
            const options = {
                method: 'GET',
                headers: this.header
            };
            const param = encodeURIComponent(nodeId);
            return this.client.fetch(`${this.microserviceUrl}/${serverId}?nodeId=${param}`, options);
        }
    }
    getChildrenOf(node, serverId) {
        if (serverId && node.nodeId && serverId.length > 0 && node.nodeId.length > 0) {
            const options = {
                method: 'GET',
                headers: this.header
            };
            const param = encodeURIComponent(node.nodeId);
            return this.client.fetch(`${this.microserviceUrl}/${serverId}/children?nodeId=${param}`, options);
        }
    }
    childrenAvailable(nodeReferences) {
        if (!nodeReferences || nodeReferences.length === 0) {
            return false;
        }
        return nodeReferences.some(ref => !ref.inverse && ref.hierarchical);
    }
    getSearchedNodes(searchKey, serverId) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `service/opcua-mgmt-service/search/${serverId}/`;
            const options = {
                headers: this.header,
                params: {
                    searchString: '*' + searchKey + '*'
                }
            };
            const res = yield this.client.fetch(url, options);
            return res.json();
        });
    }
    getIcon(nodeClassName) {
        const iconList = {
            Object: 'cube',
            Variable: 'th-list',
            Method: 'random',
            View: 'window-maximize',
            ObjectType: 'c8y-group',
            VariableType: 'c8y-group',
            ReferenceType: 'c8y-group',
            DataType: 'c8y-group'
        };
        return iconList[nodeClassName] || 'circle';
    }
};
AddressSpaceService.ctorParameters = () => [
    { type: FetchClient }
];
AddressSpaceService = __decorate([
    Injectable()
], AddressSpaceService);

let OpcuaAddressSpaceDetailComponent = class OpcuaAddressSpaceDetailComponent {
    constructor(addressSpaceService) {
        this.addressSpaceService = addressSpaceService;
        this.selected = false;
        this.showDetails = false;
        this.toggleAttrDetail = new EventEmitter();
    }
    set node(n) {
        this._node = n;
        if (n) {
            this.setNodeData(n);
        }
        else {
            // remove details from current view
            this.showDetails = false;
        }
    }
    setNodeData(nodeData) {
        this.showDetails = true;
        const { attributes, references } = nodeData;
        this.nodeDataRef = references;
        const omitList = [
            'attributes',
            'references',
            'children',
            'currentlyLoadingChildren',
            'expanded',
            'browsePath',
            'relativePath',
            'parentNode'
        ];
        this.nodeDataAttr = Object.assign({}, attributes, omit(nodeData, omitList));
    }
    toggleDetail(node) {
        this.showDetails = !this.showDetails;
        this.toggleAttrDetail.emit(node);
    }
    navigateTo(ancestors) {
        const nodeNavData = {
            node: this._node,
            selectedAncestorIds: ancestors
        };
        this.toggleDetail(this._node);
        this.addressSpaceService.triggerNodeToOpen(nodeNavData);
    }
};
OpcuaAddressSpaceDetailComponent.ctorParameters = () => [
    { type: AddressSpaceService }
];
__decorate([
    Input()
], OpcuaAddressSpaceDetailComponent.prototype, "node", null);
__decorate([
    Output()
], OpcuaAddressSpaceDetailComponent.prototype, "toggleAttrDetail", void 0);
OpcuaAddressSpaceDetailComponent = __decorate([
    Component({
        selector: 'opcua-address-space-detail',
        template: "<div\n  class=\"card flex-scroll bottom-m-xs split-row-2 animated fast\"\n  style=\"pointer-events: all\"\n  [ngClass]=\"{ fadeInRightBig: showDetails, fadeOutRightBig: !showDetails }\"\n>\n  <div class=\"card-header separator \">\n    <h4>{{ 'Attributes' | translate }}</h4>\n    <button\n      class=\"close flex-item-right visible-sm visible-xs\"\n      title=\"{{ 'Close' | translate }}\"\n      (click)=\"toggleDetail(nodeDataAttr)\"\n    >\n      &times;\n    </button>\n  </div>\n  <div class=\"card-inner-scroll\">\n    <div class=\"card-block\">\n      <table class=\"table table-striped table-condensed\">\n        <colgroup>\n          <col width=\"50%\" />\n          <col width=\"50%\" />\n        </colgroup>\n        <thead>\n          <tr>\n            <th>{{ 'Attribute' | translate }}</th>\n            <th>{{ 'Value' | translate }}</th>\n          </tr>\n        </thead>\n        <tbody>\n          <tr *ngFor=\"let item of nodeDataAttr | keyvalue\">\n            <td>{{ item.key }}</td>\n            <td *ngIf=\"item.key === 'absolutePaths'\" class=\"text-break-word\">\n              {{ item.value | json }}\n            </td>\n            <td *ngIf=\"item.key === 'ancestorNodeIds'\" class=\"text-break-word\">\n              <a *ngFor=\"let value of item.value\" (click)=\"navigateTo(value)\">\n                {{ value | json }}</a\n              >\n            </td>\n            <td *ngIf=\"item.key !== 'absolutePaths' && item.key !== 'ancestorNodeIds'\">\n              {{ item.value }}\n            </td>\n          </tr>\n        </tbody>\n      </table>\n    </div>\n  </div>\n</div>\n<div\n  class=\"card flex-scroll split-row-2 animated fast\"\n  style=\"pointer-events: all\"\n  [ngClass]=\"{ fadeInRightBig: showDetails, fadeOutRightBig: !showDetails }\"\n>\n  <div class=\"card-header separator\">\n    <h4>{{ 'References' | translate }}</h4>\n  </div>\n  <div class=\"card-inner-scroll\">\n    <div class=\"card-block\">\n      <table class=\"table table-striped table-condensed\">\n        <colgroup>\n          <col width=\"50%\" />\n          <col width=\"50%\" />\n        </colgroup>\n        <thead>\n          <tr>\n            <th>{{ 'Attribute' | translate }}</th>\n            <th>{{ 'Value' | translate }}</th>\n          </tr>\n        </thead>\n        <tbody>\n          <tr *ngFor=\"let item of nodeDataRef\">\n            <td>{{ item.referenceLabel }}</td>\n            <td class=\"text-break-word\">{{ item.targetLabel }}</td>\n          </tr>\n        </tbody>\n      </table>\n    </div>\n  </div>\n</div>\n"
    })
], OpcuaAddressSpaceDetailComponent);

let OpcuaService = class OpcuaService {
    constructor(client, inventoryService, router, alertService) {
        this.client = client;
        this.inventoryService = inventoryService;
        this.router = router;
        this.alertService = alertService;
        this.microserviceUrl = '/service/opcua-mgmt-service/server';
        this.deviceTypeProtocolUrl = '/service/opcua-mgmt-service/deviceTypes';
        this.header = { 'Content-Type': 'application/json' };
        this.binaryService = inventoryService.binary;
    }
    getServers(id) {
        if (id && id.length > 0) {
            const options = {
                method: 'GET',
                headers: this.header
            };
            return this.client.fetch(`${this.microserviceUrl}/${id}`, options);
        }
    }
    createServer(data) {
        if (this.doesGatewayIdExist(data)) {
            this.cleanUpPayload(data);
            const options = {
                method: 'POST',
                headers: this.header,
                body: JSON.stringify(data)
            };
            return this.client.fetch(`${this.microserviceUrl}`, options);
        }
    }
    updateServer(server) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.doesGatewayIdExist(server) && this.doesIdExist(server)) {
                this.cleanUpPayload(server);
                const options = {
                    method: 'POST',
                    headers: this.header,
                    body: JSON.stringify(server)
                };
                const res = yield this.client.fetch(`${this.microserviceUrl}`, options);
                let data;
                try {
                    data = yield res.json();
                }
                catch (e) {
                    // nothing
                }
                if (res.status !== 200) {
                    this.alertService.addServerFailure({ data, res });
                }
                else {
                    return data;
                }
            }
        });
    }
    removeServer(data) {
        if (this.doesGatewayIdExist(data) && this.doesIdExist(data)) {
            const options = {
                method: 'DELETE'
            };
            return this.client.fetch(`${this.microserviceUrl}/${data.gatewayId}/${data.id}`, options);
        }
    }
    getKeystore(binaryId) {
        if (binaryId && binaryId.length > 0) {
            return this.inventoryService.detail(binaryId);
        }
        return null;
    }
    uploadKeystore(file) {
        if (file && file.size > 0) {
            return this.binaryService.create(file);
        }
        return Promise.reject('Invalid file');
    }
    updateKeystore(id, file) {
        return __awaiter(this, void 0, void 0, function* () {
            if (id && id.length > 0 && file && file.size > 0) {
                const { res } = yield this.removeKeystore(id);
                if (res && res.status === 204) {
                    return this.uploadKeystore(file);
                }
            }
            return Promise.reject('Invalid file');
        });
    }
    removeKeystore(id) {
        if (id && id.length > 0) {
            return this.binaryService.delete(id);
        }
    }
    getMoId() {
        const currentUrl = this.router.routerState.snapshot.url;
        const isDevice = new RegExp(/device\/\d+/).test(currentUrl);
        if (isDevice) {
            return currentUrl.match(/\d+/)[0];
        }
        return '';
    }
    getId() {
        const currentUrl = this.router.routerState.snapshot.url;
        const isDeviceprotocol = new RegExp(/deviceprotocols/).test(currentUrl);
        if (isDeviceprotocol && RegExp(/\d+$/).test(currentUrl)) {
            return currentUrl.match(/\d+$/)[0];
        }
    }
    getDeviceProtocol(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = {
                method: 'GET',
                headers: this.header,
            };
            return this.client.fetch(`${this.deviceTypeProtocolUrl}/${id}`, options);
        });
    }
    updateDeviceProtocol(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = {
                method: 'PUT',
                headers: this.header,
                body: JSON.stringify(data)
            };
            return this.client.fetch(`${this.deviceTypeProtocolUrl}/${data.id}`, options);
        });
    }
    createDeviceProtocol(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = {
                method: 'POST',
                headers: this.header,
                body: JSON.stringify(data)
            };
            return this.client.fetch(`${this.deviceTypeProtocolUrl}`, options);
        });
    }
    doesGatewayIdExist(data) {
        return data && data.gatewayId && data.gatewayId.length > 0;
    }
    doesIdExist(data) {
        return data && data.id && data.id.length > 0 && data.id !== 'new';
    }
    cleanUpPayload(data) {
        if (data) {
            if (data.id && data.id === 'new') {
                delete data.id;
            }
            if (data.quickInfo) {
                delete data.quickInfo;
            }
        }
    }
};
OpcuaService.ctorParameters = () => [
    { type: FetchClient },
    { type: InventoryService },
    { type: Router },
    { type: AlertService }
];
OpcuaService = __decorate([
    Injectable()
], OpcuaService);

let OpcuaDeviceProtocolObjectMapping = class OpcuaDeviceProtocolObjectMapping extends UpgradeComponent {
    constructor(elementRef, injector) {
        super('c8yObjectMapping', elementRef, injector);
    }
};
OpcuaDeviceProtocolObjectMapping.ctorParameters = () => [
    { type: ElementRef },
    { type: Injector }
];
__decorate([
    Input()
], OpcuaDeviceProtocolObjectMapping.prototype, "mapping", void 0);
__decorate([
    Input()
], OpcuaDeviceProtocolObjectMapping.prototype, "customActions", void 0);
__decorate([
    Input()
], OpcuaDeviceProtocolObjectMapping.prototype, "autoObserveParams", void 0);
__decorate([
    Input()
], OpcuaDeviceProtocolObjectMapping.prototype, "hideAutoObserve", void 0);
OpcuaDeviceProtocolObjectMapping = __decorate([
    Directive({
        selector: 'c8y-object-mapping'
    })
], OpcuaDeviceProtocolObjectMapping);

let OpcuaDeviceProtocolMapping = class OpcuaDeviceProtocolMapping {
    constructor(alertService, addressSpaceService) {
        this.alertService = alertService;
        this.addressSpaceService = addressSpaceService;
        this.onAction = new EventEmitter();
        this.isPathFocused = false;
        this.isBrowsePathUniq = true;
        this.dataReporting = 'default';
        this.isTreeOpen = false;
        this.isNew = false;
        this.resetModel = false;
        this.moId = '';
        this.getMappings = () => this.getParentAttr('mappings');
    }
    toggleDetail() {
        this.isDetailOpen = !this.isDetailOpen;
        if (this.resetModel) {
            this.initialFormSetup();
        }
    }
    ngOnInit() {
        this.initialFormSetup();
    }
    initialFormSetup() {
        const mapping = {
            id: '',
            browsePath: [],
            name: '',
            subscriptionType: {
                type: 'None'
            }
        };
        const customAction = {
            headers: [{ key: 'Authorization', value: '' }, { key: 'Content-Type', value: '' }],
            bodyTemplate: '',
            type: 'HttpPost',
            endpoint: ''
        };
        this.mapping = assign({}, mapping, cloneDeep(this._model));
        if (isEmpty(this.mapping.browsePath)) {
            this.isNew = true;
            this.isDetailOpen = true;
        }
        else {
            this.browsePath = this.stringfyBrowsePath(this.mapping.browsePath);
            this.nodeDisplayName = this.mapping.name;
        }
        if (this.referencedRootNodeId) {
            this.referencedNode = { nodeId: this.referencedRootNodeId };
            this.addressSpaceService.triggerNodeToOpen({
                node: {
                    nodeId: this.referencedRootNodeId,
                    children: [],
                    expanded: false,
                    absolutePaths: [[]]
                },
                selectedAncestorIds: []
            });
        }
        else {
            this.referencedNode = { nodeId: '' };
        }
        if (get(this.mapping, 'customAction')) {
            this.customAction = assign(customAction, get(this.mapping, 'customAction'));
            this.customAction.headers = this.mapHeadersObjectToList(get(this.customAction, 'headers'));
        }
        else {
            this.customAction = assign({}, customAction);
        }
        unset(this.mapping, 'customAction');
        if (get(this._model, 'subscriptionType')) {
            this.dataReporting = 'custom';
        }
        else {
            this.dataReporting = 'default';
        }
        this.resetModel = false;
    }
    showAddressSpaceTree() {
        return !isEmpty(this.referencedServerId);
    }
    ngAfterViewInit() {
        if (get(this.mapping, 'subscriptionType') &&
            get(this.mapping, 'subscriptionType.type') !== 'None') {
            this.dataReporting = 'custom';
        }
    }
    mapHeadersObjectToList(headers) {
        if (Object.keys(headers).length > 0) {
            return Object.keys(headers).map(item => {
                return { key: item, value: headers[item] };
            });
        }
    }
    stringfyBrowsePath(path) {
        return JSON.stringify(path);
    }
    updateBrowsePath(node) {
        this.mapping.browsePath = node.relativePath;
        this.nodeDisplayName = node.displayName;
        this.mapping.name = this.nodeDisplayName;
        this.browsePath = this.stringfyBrowsePath(this.mapping.browsePath);
        this.browsePathModel.control.markAsDirty();
    }
    updateDisplayname() {
        this.mapping.name = this.nodeDisplayName;
    }
    updateBrowsePathInput() {
        if (this.browsePath) {
            try {
                this.mapping.browsePath = JSON.parse(this.browsePath);
            }
            catch (error) {
                return;
            }
        }
    }
    save() {
        if (this.dataReporting === 'default') {
            unset(this.mapping, 'subscriptionType');
        }
        const { customAction } = this.subFormRef.value;
        if (customAction.hasCustomAction) {
            const reducedHeaders = this.customAction.headers.reduce((result, item) => {
                result[item.key] = item.value;
                return result;
            }, {});
            if (customAction.bodyTemplate) {
                const bodyTemplateAsString = customAction.bodyTemplate;
                // parsing the string back into object and then stringify it back
                // will remove all whitespaces, linebreaks etc.
                const obj = JSON.parse(bodyTemplateAsString);
                const result = JSON.stringify(obj);
                this.customAction.bodyTemplate = result;
            }
            this.customAction = assign(this.customAction, { headers: reducedHeaders });
            this.mapping = assign(this.mapping, { customAction: this.customAction });
        }
        this.onAction.emit({ action: 'save', data: assign({}, this.mapping) });
        this.isDetailOpen = false;
    }
    cancel() {
        this.isDetailOpen = false;
        this.resetModel = true;
        if (this.mapping.id === 'new') {
            this.onAction.emit({ action: 'delete', data: assign({}, this.mapping) });
        }
    }
    onDelete() {
        this.onAction.emit({ action: 'delete', data: this.mapping });
    }
    isFormValid(variableForm) {
        return variableForm.valid && this.objectMappingForm.$componentScope.mappingForm.$valid;
    }
    isActive() {
        return this.isDetailOpen;
    }
    setTreeFromRefNode() {
        if (this.referencedRootNodeId) {
            this.addressSpaceService.triggerNodeToOpen({
                node: {
                    nodeId: this.referencedRootNodeId,
                    children: [],
                    expanded: false,
                    absolutePaths: [[]]
                },
                selectedAncestorIds: []
            });
        }
    }
};
OpcuaDeviceProtocolMapping.ctorParameters = () => [
    { type: AlertService },
    { type: AddressSpaceService }
];
__decorate([
    ViewChild(OpcuaDeviceProtocolObjectMapping, { static: false })
], OpcuaDeviceProtocolMapping.prototype, "objectMappingForm", void 0);
__decorate([
    ViewChild('variableForm', { static: false })
], OpcuaDeviceProtocolMapping.prototype, "subFormRef", void 0);
__decorate([
    ViewChild('browsePathModel', { static: false })
], OpcuaDeviceProtocolMapping.prototype, "browsePathModel", void 0);
__decorate([
    Input('resource')
], OpcuaDeviceProtocolMapping.prototype, "_model", void 0);
__decorate([
    Input()
], OpcuaDeviceProtocolMapping.prototype, "index", void 0);
__decorate([
    Input()
], OpcuaDeviceProtocolMapping.prototype, "getParentAttr", void 0);
__decorate([
    Input()
], OpcuaDeviceProtocolMapping.prototype, "referencedServerId", void 0);
__decorate([
    Input()
], OpcuaDeviceProtocolMapping.prototype, "referencedRootNodeId", void 0);
__decorate([
    Output()
], OpcuaDeviceProtocolMapping.prototype, "onAction", void 0);
OpcuaDeviceProtocolMapping = __decorate([
    Component({
        selector: 'opcua-device-protocol-mapping',
        template: "<div class=\"list-group-item collapsible\" [ngClass]=\"{ expanded: isDetailOpen }\">\n  <div class=\"flex-row\" (click)=\"toggleDetail()\">\n    <div class=\"list-item-actions\">\n      <button class=\"btn btn-clean showOnHover flex-item-right\" title=\"{{ 'Delete' | translate }}\">\n        <i c8yIcon=\"minus-circle\" class=\"text-danger\" (click)=\"onDelete()\"></i>\n      </button>\n      <button\n        type=\"button\"\n        title=\"{{ 'Expand' | translate }}\"\n        class=\"collapse-btn\"\n        [ngClass]=\"{ active: isDetailOpen }\"\n      >\n        <i class=\"fa fw fa-chevron-down\"></i>\n      </button>\n    </div>\n\n    <div class=\"list-item-icon\">\n      <i c8yIcon=\"sliders\"></i>\n    </div>\n\n    <div class=\"list-item-body\">\n      <div class=\"row flex-row\">\n        <div class=\"col-sm-7 col-xs-12\">\n          <p>\n            {{ nodeDisplayName }}<br />\n            <small\n              *ngIf=\"mapping.browsePath.length > 0\"\n              class=\"text-muted text-truncate\"\n              title=\"{{ mapping.browsePath | json }}\"\n              >{{ mapping.browsePath | json }}</small\n            >\n          </p>\n\n          <p></p>\n        </div>\n\n        <div class=\"col-sm-4 col-xs-10\">\n          <div class=\"list-functionalities\">\n            <label class=\"small right-m hidden-xs\" translate>Functionalities</label>&nbsp;\n            <c8y-object-mapping-status-icons [mapping]=\"mapping\"></c8y-object-mapping-status-icons>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n  <div class=\"detail\" [collapse]=\"!isDetailOpen\" [isAnimated]=\"true\">\n    <div class=\"form\" [ngModelGroup]=\"index\" #variableForm=\"ngModelGroup\" *ngIf=\"isDetailOpen\">\n      <div class=\"row top-p-sm\">\n        <c8y-form-group class=\"col-md-4\" [status]=\"!isBrowsePathUniq ? 'error' : ''\">\n          <label translate>Path</label>\n          <div\n            class=\"dropdown\"\n            dropdown\n            #dropdown=\"bs-dropdown\"\n            [insideClick]=\"true\"\n            style=\"width:100%;\"\n          >\n            <input\n              class=\"form-control\"\n              c8yBrowsePathValidator\n              [getMappings]=\"getMappings\"\n              [model]=\"mapping\"\n              type=\"text\"\n              name=\"browsePath\"\n              dropdownToggle\n              placeholder=\"{{ 'e.g.' | translate }} {{ ['2:Node1', '2:SubNode1'] | json }}\"\n              [(ngModel)]=\"browsePath\"\n              (change)=\"updateBrowsePathInput()\"\n              (focus)=\"setTreeFromRefNode()\"\n              required\n              #browsePathModel=\"ngModel\"\n            />\n            <div\n              *dropdownMenu\n              class=\"dropdown-menu panel-inner-scroll\"\n              style=\"max-height:200px; width: 100%;\"\n            >\n              <opcua-address-space-tree\n                *ngIf=\"showAddressSpaceTree()\"\n                [node]=\"referencedNode\"\n                [moId]=\"referencedServerId\"\n                (selectedNode)=\"updateBrowsePath($event); dropdown.hide()\"\n              ></opcua-address-space-tree>\n            </div>\n          </div>\n          <c8y-messages>\n            <c8y-message\n              name=\"invalidBrowsePathNotation\"\n              text=\"{{ 'Must be a valid array of strings.' | translate }}\"\n            ></c8y-message>\n            <c8y-message\n              name=\"browsePathNotUnique\"\n              text=\"{{ 'Variable with this path is already added.' | translate }}\"\n            ></c8y-message>\n          </c8y-messages>\n        </c8y-form-group>\n\n        <c8y-form-group class=\"col-md-4\">\n          <label translate>Name</label>\n          <div class=\"input-group\">\n            <input\n              class=\"form-control\"\n              type=\"test\"\n              name=\"displayName\"\n              placeholder=\"{{ 'e.g. childDevice2' | translate }} \"\n              required\n              [(ngModel)]=\"nodeDisplayName\"\n              (change)=\"updateDisplayname()\"\n            />\n          </div>\n        </c8y-form-group>\n      </div>\n      <div class=\"row\" ngModelGroup=\"dataReportingSection\">\n        <c8y-form-group class=\"col-sm-4 col-md-3 col-lg-2\">\n          <label>\n            <span translate>Data reporting</span>\n          </label>\n          <div class=\"input-group\">\n            <label class=\"c8y-radio radio-inline\">\n              <input\n                type=\"radio\"\n                [(ngModel)]=\"dataReporting\"\n                name=\"ReportingMode\"\n                value=\"default\"\n              />\n              <span></span> {{ 'Default' | translate }}\n            </label>\n            <label class=\"c8y-radio radio-inline\">\n              <input type=\"radio\" [(ngModel)]=\"dataReporting\" name=\"ReportingMode\" value=\"custom\" />\n              <span></span> {{ 'Custom' | translate }}\n            </label>\n          </div>\n        </c8y-form-group>\n        <div\n          class=\"col-sm-8 col-md-9 col-lg-10\"\n          *ngIf=\"dataReporting === 'custom'\"\n          ngModelGroup=\"overriddenSubscription\"\n        >\n          <opcua-device-protocol-data-reporting\n            [model]=\"mapping\"\n          ></opcua-device-protocol-data-reporting>\n        </div>\n      </div>\n\n      <c8y-object-mapping [mapping]=\"mapping\" [hideAutoObserve]=\"true\"></c8y-object-mapping>\n      <div ngModelGroup=\"customAction\">\n        <opcua-device-protocol-mapping-customaction\n          [customAction]=\"customAction\"\n        ></opcua-device-protocol-mapping-customaction>\n      </div>\n      <button\n        id=\"cancelBtn\"\n        class=\"btn btn-default top-m-md bottom-m-lg\"\n        style=\"min-width: 100px;\"\n        (click)=\"cancel()\"\n        translate\n      >\n        Cancel\n      </button>\n      <button\n        id=\"saveBtn\"\n        class=\"btn btn-primary top-m-md bottom-m-lg\"\n        style=\"min-width: 100px;\"\n        (click)=\"save()\"\n        [disabled]=\"!isFormValid(variableForm)\"\n        translate\n      >\n        Save\n      </button>\n    </div>\n  </div>\n</div>\n",
        viewProviders: [{ provide: ControlContainer, useExisting: NgModelGroup }]
    })
], OpcuaDeviceProtocolMapping);

let OpcuaDeviceProtocolDetailComponent = class OpcuaDeviceProtocolDetailComponent {
    constructor(changeDetectorRef, opcuaService, alertService, router) {
        this.changeDetectorRef = changeDetectorRef;
        this.opcuaService = opcuaService;
        this.alertService = alertService;
        this.router = router;
        this.initialModel = {
            id: '',
            fieldbusType: 'opcuaV2',
            description: '',
            unit: '',
            fieldbusVersion: 4,
            name: '',
            referencedServerId: '',
            referencedRootNodeId: '',
            subscriptionType: {
                type: 'None'
            },
            mappings: [],
            overriddenSubscriptions: [],
            applyConstraints: {
                browsePathMatchesRegex: '',
                matchesNodeIds: [],
                serverObjectHasFragment: '',
                matchesServerIds: []
            },
            enabled: ''
        };
        this.isLoaded = true;
        this.getParentAttr = key => get(this.model, key);
    }
    ngAfterContentChecked() {
        this.changeDetectorRef.detectChanges();
    }
    getMapping() {
        return this.model.mappings;
    }
    getEmptyMappingObject() {
        return {
            id: 'new',
            browsePath: []
        };
    }
    getOverriddenSubscriptionsByPath(browsePath) {
        return find(this.model.overriddenSubscriptions, { browsePath });
    }
    getStructuredResource(resource) {
        const overriddenSubscriptions = this.getOverriddenSubscriptionsByPath(resource.browsePath);
        let result = assign({}, resource);
        if (overriddenSubscriptions) {
            result = assign({}, resource, { subscriptionType: overriddenSubscriptions.subscriptionType });
        }
        return result;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const id = this.opcuaService.getId();
            if (id) {
                const res = yield this.opcuaService.getDeviceProtocol(id);
                if (res && res.status !== 200) {
                    const data = res.json ? yield res.json() : undefined;
                    this.alertService.addServerFailure({ data, res });
                    this.isLoaded = false;
                }
                else {
                    const data = yield res.json();
                    if (data && data.applyConstraints === null) {
                        delete data.applyConstraints;
                    }
                    if (data && data.subscriptionType === null) {
                        delete data.subscriptionType;
                    }
                    this.model = assign(this.initialModel, data);
                    if (!this.model.mappings) {
                        this.model.mappings = [];
                    }
                    this.model = assign(this.initialModel, this.updateViableMapping(data));
                    this.isLoaded = false;
                }
            }
        });
    }
    updateViableMapping(model) {
        const { mappings } = model;
        let result = [];
        if (mappings) {
            result = mappings.map((item, i) => {
                return assign(item, { id: i });
            });
        }
        return assign(model, { mappings: result });
    }
    trackByIndex(index) {
        return index;
    }
    addVariable() {
        this.model.mappings.push(this.getEmptyMappingObject());
    }
    updateVariable(mappingObject) {
        const { mappings } = this.model;
        const index = findIndex(mappings, { id: mappingObject.id });
        mappings.splice(index, 1);
        if (mappingObject.id === 'new') {
            mappingObject.id = mappings.length;
        }
        mappings.push(mappingObject);
    }
    removeVariable(mappingObject) {
        const { mappings } = this.model;
        const index = findIndex(mappings, { id: mappingObject.id });
        mappings.splice(index, 1);
    }
    actionHandler(actionObject) {
        switch (actionObject.action) {
            case 'save':
                this.updateVariable(actionObject.data);
                break;
            case 'delete':
                this.removeVariable(actionObject.data);
                break;
        }
    }
    extractOverridSubscriptionType(_mapping) {
        const overriddenSubscriptions = [];
        const variableMapping = [];
        _mapping.forEach(element => {
            if (element.id !== 'new') {
                if (element.subscriptionType) {
                    overriddenSubscriptions.push(assign({ browsePath: element.browsePath }, { subscriptionType: element.subscriptionType }));
                }
                variableMapping.push(omit$1(element, ['subscriptionType']));
            }
        });
        return [variableMapping, overriddenSubscriptions];
    }
    prepareRequestJson(_model) {
        let requestJson = {};
        const [mappings, overriddenSubscriptions] = this.extractOverridSubscriptionType(_model.mappings);
        requestJson = assign(requestJson, pick(_model, Object.keys(this.initialModel)), {
            mappings,
            overriddenSubscriptions
        });
        return requestJson;
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield this.opcuaService.updateDeviceProtocol(this.prepareRequestJson(this.model));
                if (res && res.status === 200) {
                    this.router.navigate(['deviceprotocols']);
                    this.alertService.success(gettext('Device protocol saved.'));
                }
                else {
                    this.alertService.addServerFailure({ res });
                }
            }
            catch (ex) {
                this.alertService.danger(gettext('Failed to save. Try again.'));
            }
        });
    }
    canSave(deviceTypeForm) {
        if (this.instanceList) {
            const activeInstances = this.instanceList.filter(item => item.isActive());
            if (activeInstances.length > 0) {
                return true;
            }
        }
        return !deviceTypeForm.form.valid;
    }
};
OpcuaDeviceProtocolDetailComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: OpcuaService },
    { type: AlertService },
    { type: Router }
];
__decorate([
    ViewChildren(OpcuaDeviceProtocolMapping)
], OpcuaDeviceProtocolDetailComponent.prototype, "instanceList", void 0);
OpcuaDeviceProtocolDetailComponent = __decorate([
    Component({
        selector: 'opcua-device-protocol-detail',
        template: "<c8y-title *ngIf=\"!isLoaded\">{{ model.name }}</c8y-title>\n<div>\n  <form #deviceTypeForm=\"ngForm\" name=\"detailForm\" *ngIf=\"!isLoaded\">\n    <opcua-device-protocol-description [model]=\"model\"></opcua-device-protocol-description>\n    <div class=\"card m-b-4\">\n      <div class=\"card-header separator\">\n        <h4 translate>Variables</h4>\n      </div>\n      <div class=\"list-group\" *ngIf=\"model.mappings.length > 0\" ngModelGroup=\"variable\">\n        <opcua-device-protocol-mapping\n          *ngFor=\"let resource of getMapping(); trackBy: trackByIndex; let i = index\"\n          [index]=\"i\"\n          [referencedServerId]=\"model.referencedServerId\"\n          [referencedRootNodeId]=\"model.referencedRootNodeId\"\n          [resource]=\"getStructuredResource(resource)\"\n          [getParentAttr]=\"getParentAttr\"\n          (onAction)=\"actionHandler($event)\"\n        >\n        </opcua-device-protocol-mapping>\n      </div>\n      <div class=\"card-block\">\n        <div class=\"c8y-empty-state text-left\" *ngIf=\"model.mappings.length === 0\">\n          <h1 c8yIcon=\"sliders\"></h1>\n          <p translate>No variables to display. Click below to add.</p>\n        </div>\n        <button\n          title=\"{{ 'Add variable' | translate }}\"\n          class=\"btn-add-block addVariableBtn\"\n          (click)=\"addVariable()\"\n        >\n          <i c8yIcon=\"plus-square\"></i> {{ 'Add variable' | translate }}\n        </button>\n      </div>\n    </div>\n    <div class=\"card m-b-4\">\n      <div class=\"card-header separator\">\n        <h4 translate>Data reporting</h4>\n      </div>\n      <div class=\"card-block\" ngModelGroup=\"subscription\">\n        <opcua-device-protocol-data-reporting\n          [groupName]=\"'subscription'\"\n          [model]=\"model\"\n        ></opcua-device-protocol-data-reporting>\n      </div>\n    </div>\n    <div class=\"card\">\n      <div class=\"card-header separator\">\n        <h4 translate>Auto apply constraints</h4>\n      </div>\n      <div class=\"card-block overflow-visible\" ngModelGroup=\"autoApply\">\n        <opcua-auto-apply [model]=\"model\"></opcua-auto-apply>\n      </div>\n    </div>\n\n    <span>\n      <div class=\"text-center page-footer m-t-16\">\n        <div class=\"btn-save-wrapper animated\">\n          <button\n            title=\"{{ 'Save' | translate }}\"\n            id=\"deviceTypeSave\"\n            class=\"btn btn-primary\"\n            (click)=\"save()\"\n            [disabled]=\"canSave(deviceTypeForm)\"\n            translate\n          >\n            Save\n          </button>\n        </div>\n      </div>\n    </span>\n  </form>\n</div>\n"
    })
], OpcuaDeviceProtocolDetailComponent);

let OpcuaDeviceProtocolDataReportingComponent = class OpcuaDeviceProtocolDataReportingComponent {
    constructor() {
        this.onSubscriptionChange = new EventEmitter();
        this.subscription = {
            type: 'None'
        };
        this.subscriptionParameters = {
            samplingRate: undefined,
            deadbandType: 'None',
            deadbandValue: undefined,
            ranges: '',
            queueSize: undefined,
            dataChangeTrigger: 'Status',
            discardOldest: true
        };
        this.cyclicReadParameters = {
            rate: undefined
        };
        this.types = [
            { value: 'None', label: gettext('None') },
            { value: 'CyclicRead', label: gettext('Cyclic read') },
            { value: 'Subscription', label: gettext('Subscription') }
        ];
        this.filters = [
            { value: 'None', label: gettext('None') },
            { value: 'absolute', label: gettext('Absolute') },
            { value: 'percent', label: gettext('Percent') }
        ];
        this.triggers = [
            { value: 'Status', label: gettext('Status') },
            { value: 'StatusValue', label: gettext('Status/Value') },
            { value: 'StatusValueTimestamp', label: gettext('Status/Value/Timestamp') }
        ];
        this.discard = [
            { value: true, label: gettext('oldest`data`') },
            { value: false, label: gettext('newest`data`') }
        ];
        this.requireCyclic = false;
        this.requireSubscription = false;
        this.parseReadingInterval = $event => toInteger($event.target.value);
    }
    set model(_model) {
        if (_model.subscriptionType) {
            this.subscription = _model.subscriptionType;
            if (this.subscription.type === 'CyclicRead') {
                this.cyclicReadParameters = _model.subscriptionType.cyclicReadParameters;
                this.requireCyclic = true;
                this.requireSubscription = false;
            }
            if (this.subscription.type === 'Subscription') {
                this.subscriptionParameters = _model.subscriptionType.subscriptionParameters;
                this.requireCyclic = false;
                this.requireSubscription = true;
            }
            if (this.subscription.type === 'None') {
                this.requireCyclic = false;
                this.requireSubscription = false;
            }
        }
        this._model = _model;
    }
    updateModel() {
        setTimeout(() => {
            unset(this.subscription, 'subscriptionParameters');
            unset(this.subscription, 'cyclicReadParameters');
            if (this.subscription.type === 'CyclicRead') {
                this.requireCyclic = true;
                this.requireSubscription = false;
                set(this.subscription, 'cyclicReadParameters', this.cyclicReadParameters);
            }
            else if (this.subscription.type === 'Subscription') {
                this.requireCyclic = false;
                this.requireSubscription = true;
                set(this.subscription, 'subscriptionParameters', this.subscriptionParameters);
            }
            else if (this.subscription.type === 'None') {
                this.requireCyclic = false;
                this.requireSubscription = false;
            }
        });
    }
};
__decorate([
    Input()
], OpcuaDeviceProtocolDataReportingComponent.prototype, "model", null);
__decorate([
    Input()
], OpcuaDeviceProtocolDataReportingComponent.prototype, "groupName", void 0);
__decorate([
    Output()
], OpcuaDeviceProtocolDataReportingComponent.prototype, "onSubscriptionChange", void 0);
OpcuaDeviceProtocolDataReportingComponent = __decorate([
    Component({
        selector: 'opcua-device-protocol-data-reporting',
        template: "<c8y-form-group>\n  <label translate>Mechanism</label>\n  <label\n    *ngFor=\"let mechanism of types\"\n    title=\"{{ mechanism.label | translate }}\"\n    class=\"c8y-radio radio-inline\"\n  >\n    <input\n      type=\"radio\"\n      name=\"subscriptionType\"\n      [value]=\"mechanism.value\"\n      [(ngModel)]=\"subscription.type\"\n      (change)=\"updateModel()\"\n      required\n    />\n    <span></span> {{ mechanism.label | translate }}\n  </label>\n</c8y-form-group>\n\n<div class=\"row collapse\" [collapse]=\"subscription.type != 'CyclicRead'\" [isAnimated]=\"true\">\n  <div class=\"col-sm-6 col-md-4 col-lg-3\">\n    <c8y-form-group>\n      <label translate>Reading interval</label>\n      <div class=\"input-group\">\n        <input\n          class=\"form-control\"\n          type=\"number\"\n          name=\"rate\"\n          [(ngModel)]=\"cyclicReadParameters.rate\"\n          placeholder=\"{{ 'e.g.' | translate }} 50\"\n          [required]=\"requireCyclic\"\n          min=\"0\"\n        />\n        <span class=\"input-group-addon units\" title=\"{{ 'Milliseconds' | translate }}\" translate>\n          msec\n        </span>\n      </div>\n    </c8y-form-group>\n  </div>\n</div>\n\n<div class=\"row collapse\" [collapse]=\"subscription.type != 'Subscription'\" [isAnimated]=\"true\">\n  <div class=\"col-sm-6 col-lg-4\">\n    <c8y-form-group>\n      <label translate>Sampling interval</label>\n      <div class=\"input-group\">\n        <input\n          class=\"form-control\"\n          type=\"number\"\n          name=\"samplingRate\"\n          [(ngModel)]=\"subscriptionParameters.samplingRate\"\n          placeholder=\"{{ 'e.g.' | translate }} 500\"\n          [required]=\"requireSubscription\"\n          min=\"0\"\n        />\n        <span class=\"input-group-addon units\" title=\"{{ 'Milliseconds' | translate }}\" translate>\n          msec\n        </span>\n      </div>\n    </c8y-form-group>\n  </div>\n  <div class=\"col-sm-6 col-lg-4\">\n    <c8y-form-group>\n      <label translate>Queue size</label>\n      <div class=\"input-group\">\n        <input\n          class=\"form-control\"\n          type=\"number\"\n          name=\"queueSize\"\n          [(ngModel)]=\"subscriptionParameters.queueSize\"\n          placeholder=\"{{ 'e.g.' | translate }} 10\"\n          min=\"1\"\n          [required]=\"requireSubscription\"\n        />\n        <span class=\"input-group-addon\">\n          <strong translate>Discard</strong>&nbsp;\n          <label\n            *ngFor=\"let discardOption of discard\"\n            title=\"{{ discardOption.label | translate }}\"\n            class=\"c8y-radio radio-inline\"\n          >\n            <input\n              type=\"radio\"\n              name=\"discard\"\n              [value]=\"discardOption.value\"\n              [(ngModel)]=\"subscriptionParameters.discardOldest\"\n              [required]=\"requireSubscription\"\n            />\n            <span></span> {{ discardOption.label | translate }}\n          </label>\n        </span>\n      </div>\n    </c8y-form-group>\n  </div>\n  <div class=\"clearfix\"></div>\n  <div class=\"col-sm-6 col-lg-4\">\n    <c8y-form-group>\n      <label translate>Data change trigger</label>\n      <label\n        *ngFor=\"let trigger of triggers\"\n        title=\"{{ trigger.label | translate }}\"\n        class=\"c8y-radio radio-inline\"\n      >\n        <input\n          type=\"radio\"\n          name=\"dataChangeTrigger\"\n          [value]=\"trigger.value\"\n          [(ngModel)]=\"subscriptionParameters.dataChangeTrigger\"\n          [required]=\"requireSubscription\"\n        />\n        <span></span> {{ trigger.label | translate }}\n      </label>\n    </c8y-form-group>\n  </div>\n  <div class=\"col-sm-6 col-lg-4\">\n    <c8y-form-group>\n      <label translate>Deadband filter</label>\n      <label\n        *ngFor=\"let deadbandFilter of filters\"\n        title=\"{{ deadbandFilter.label | translate }}\"\n        class=\"c8y-radio radio-inline\"\n      >\n        <input\n          type=\"radio\"\n          name=\"deadbandType\"\n          [value]=\"deadbandFilter.value\"\n          [(ngModel)]=\"subscriptionParameters.deadbandType\"\n          [required]=\"requireSubscription\"\n        />\n        <span></span> {{ deadbandFilter.label | translate }}\n      </label>\n    </c8y-form-group>\n    <div [collapse]=\"subscriptionParameters.deadbandType == 'None'\" [isAnimated]=\"true\">\n      <c8y-form-group>\n        <label translate>Deadband value</label>\n        <input\n          class=\"form-control\"\n          type=\"number\"\n          name=\"deadbandValue\"\n          [(ngModel)]=\"subscriptionParameters.deadbandValue\"\n          placeholder=\"{{ 'e.g.' | translate }} 10\"\n          [required]=\"subscriptionParameters.deadbandType != 'None'\"\n          min=\"0\"\n        />\n      </c8y-form-group>\n    </div>\n  </div>\n</div>\n",
        viewProviders: [{ provide: ControlContainer, useExisting: NgModelGroup }]
    })
], OpcuaDeviceProtocolDataReportingComponent);

let OpcuaDeviceProtocolMappingCustomAction = class OpcuaDeviceProtocolMappingCustomAction {
    constructor() {
        this.hasCustomAction = false;
    }
    getHeaderPair() {
        return { key: '', value: '' };
    }
    get headers() {
        return this.customAction.headers;
    }
    addHeader() {
        const { headers } = this.customAction;
        headers.push(this.getHeaderPair());
    }
    updateCustomAction() {
        this.hasCustomAction = !this.hasCustomAction;
    }
    removeCustomAction(index) {
        const { headers } = this.customAction;
        headers.splice(index, 1);
    }
    trackByIndex(index) {
        return index;
    }
    ngOnInit() {
        if (get$1(this.customAction, 'endpoint')) {
            this.hasCustomAction = true;
        }
    }
    placeholder() {
        const exampleBody = {
            value: '${value}',
            serverId: '${serverId}',
            nodeId: '${nodeId}',
            deviceId: '${deviceId}'
        };
        const pretty = JSON.stringify(exampleBody, undefined, 2);
        return pretty.replace(/"\$\{value\}\"/, '${value}');
    }
    bodyTemplateMessage(text) {
        this.bodyTemplateInvalidMessage = text;
    }
};
__decorate([
    Input()
], OpcuaDeviceProtocolMappingCustomAction.prototype, "customAction", void 0);
OpcuaDeviceProtocolMappingCustomAction = __decorate([
    Component({
        selector: 'opcua-device-protocol-mapping-customaction',
        template: "<div class=\"list-group\" style=\"box-shadow:none;\">\n  <div class=\"list-group-item\">\n    <div class=\"flex-row\">\n      <div class=\"list-item-switch\">\n        <label class=\"c8y-switch\">\n          <input\n            type=\"checkbox\"\n            name=\"hasCustomAction\"\n            [(ngModel)]=\"hasCustomAction\"\n            (click)=\"updateCustomAction()\"\n          />\n          <span></span>\n        </label>\n      </div>\n      <div class=\"list-item-icon\">\n        <i c8yIcon=\"wrench\"></i>\n      </div>\n      <div class=\"list-item-title\" translate>\n        Custom action\n      </div>\n    </div>\n    <div [collapse]=\"!hasCustomAction\" [isAnimated]=\"true\">\n      <div class=\"top-p-sm\" *ngIf=\"hasCustomAction\">\n        <fieldset ngModelGroup=\"headers\">\n          <div class=\"legend form-block\" translate>Headers</div>\n          <div class=\"tight-grid flex-row hidden-xs\">\n            <div class=\"col-sm-4\">\n              <label translate>Key</label>\n            </div>\n            <div class=\"col-sm-4\">\n              <label translate>Value</label>\n            </div>\n          </div>\n          <div\n            *ngFor=\"let header of headers; trackBy: trackByIndex; let i = index; last as isLast\"\n            class=\"flex-row tight-grid row\"\n            [ngModelGroup]=\"i\"\n          >\n            <div class=\"col-xs-5 col-sm-4\">\n              <c8y-form-group class=\"form-group-sm\">\n                <label class=\"visible-xs\" translate>Key</label>\n                <div class=\"input-group\">\n                  <input\n                    class=\"form-control\"\n                    type=\"text\"\n                    name=\"key\"\n                    placeholder=\"{{ 'e.g.' | translate }} Content-Type\"\n                    required\n                    [(ngModel)]=\"header.key\"\n                  />\n                </div>\n              </c8y-form-group>\n            </div>\n            <div class=\"col-xs-5 col-sm-4\">\n              <c8y-form-group class=\"form-group-sm\">\n                <label class=\"visible-xs\" translate>Value</label>\n                <div class=\"input-group\">\n                  <input\n                    class=\"form-control\"\n                    type=\"text\"\n                    name=\"value\"\n                    placeholder=\"{{ 'e.g.' | translate }} application/json\"\n                    required\n                    [(ngModel)]=\"header.value\"\n                  />\n                </div>\n              </c8y-form-group>\n            </div>\n            <div class=\"col-xs-2\">\n              <div class=\"form-group\">\n                <label class=\"visible-xs\">&nbsp;</label>\n                <button class=\"btn btn-clean\" *ngIf=\"customAction.headers.length !== 1\">\n                  <i c8yIcon=\"minus-circle\" class=\"text-danger\" (click)=\"removeCustomAction(i)\"></i>\n                </button>\n                <button class=\"btn btn-clean\" *ngIf=\"isLast\">\n                  <i c8yIcon=\"plus-circle\" class=\"text-primary\" (click)=\"addHeader()\"></i>\n                </button>\n              </div>\n            </div>\n          </div>\n        </fieldset>\n        <div class=\"legend form-block\" translate>Action</div>\n        <div class=\"row\">\n          <div class=\"col-md-4\">\n            <c8y-form-group class=\"form-group-sm\">\n              <label>\n                <span translate>Endpoint</span>\n              </label>\n              <div class=\"input-group\">\n                <input\n                  class=\"form-control\"\n                  type=\"text\"\n                  name=\"endpoint\"\n                  placeholder=\"{{ 'e.g.' | translate }} http://localhost:1080/cucumber\"\n                  required\n                  [(ngModel)]=\"customAction.endpoint\"\n                />\n              </div>\n            </c8y-form-group>\n          </div>\n          <div class=\"col-md-4\">\n            <c8y-form-group class=\"form-group-sm\">\n              <label translate>Body template</label>\n              <textarea\n                [heightPerRow]=\"40\"\n                prettyValidJson\n                class=\"form-control\"\n                rows=\"3\"\n                name=\"bodyTemplate\"\n                [placeholder]=\"placeholder()\"\n                [(ngModel)]=\"customAction.bodyTemplate\"\n                (invalidJSON)=\"bodyTemplateMessage($event)\"\n              ></textarea>\n              <c8y-messages>\n                <c8y-message *ngIf=\"bodyTemplateInvalidMessage\">{{\n                  bodyTemplateInvalidMessage | translate\n                }}</c8y-message>\n              </c8y-messages>\n            </c8y-form-group>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n",
        viewProviders: [{ provide: ControlContainer, useExisting: NgModelGroup }]
    })
], OpcuaDeviceProtocolMappingCustomAction);

let OpcuaDeviceProtocolObjectMappingStatus = class OpcuaDeviceProtocolObjectMappingStatus extends UpgradeComponent {
    constructor(elementRef, injector) {
        super('c8yObjectMappingStatusIcons', elementRef, injector);
    }
};
OpcuaDeviceProtocolObjectMappingStatus.ctorParameters = () => [
    { type: ElementRef },
    { type: Injector }
];
__decorate([
    Input()
], OpcuaDeviceProtocolObjectMappingStatus.prototype, "mapping", void 0);
OpcuaDeviceProtocolObjectMappingStatus = __decorate([
    Directive({
        selector: 'c8y-object-mapping-status-icons'
    })
], OpcuaDeviceProtocolObjectMappingStatus);

let OpcuaAddressSpaceComponent = class OpcuaAddressSpaceComponent {
    constructor(addressSpaceService, opcuaService) {
        this.addressSpaceService = addressSpaceService;
        this.opcuaService = opcuaService;
        this.selectednode = false;
        this.loading = false;
        this.searchInProgress = false;
        this.focusStatus = new EventEmitter();
        this.moId = '';
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.filterLabel = gettext('Filter');
            this.moId = this.opcuaService.getMoId();
        });
    }
    ngOnDestroy() {
        // The BehaviourSubject will store the last array of ancestorNodes from the previous search
        // this would cause the component while subscribing in the init-phase to the subject to travers
        // to the last searched node again. From user perspective it does not make sense, because the user
        // left the Address space (tab) and should loose the context and just request a new search or
        // browse the tree manually.
        this.addressSpaceService.resetTreeToRootNode();
    }
    searchNodes() {
        return __awaiter(this, void 0, void 0, function* () {
            this.searchInProgress = true;
            this.clearNodeListAndCheckSearchString();
            if (this.isSearch) {
                this.currentNode = undefined;
                this.nodeList = yield this.addressSpaceService.getSearchedNodes(this.searchKey, this.moId);
                this.searchInProgress = false;
                this.nodeList.resultLabel = gettext('Results found');
            }
        });
    }
    clearNodeListAndCheckSearchString() {
        this.isSearch = this.searchKey !== undefined && this.searchKey !== '' ? true : false;
        if (!this.isSearch) {
            this.searchInProgress = false;
        }
    }
    clearSearch() {
        this.isSearch = false;
        this.searchKey = '';
        this.currentNode = undefined;
    }
    getIcon(nodeClassName) {
        return this.addressSpaceService.getIcon(nodeClassName);
    }
    selectNode(node) {
        return __awaiter(this, void 0, void 0, function* () {
            if (node && node.nodeId && node.nodeId.length > 0) {
                const res = yield this.addressSpaceService.getNodeById(this.moId, node.nodeId);
                this.toggleCurrentNode((yield res.json()));
            }
        });
    }
    toggleCurrentNode(node) {
        this.currentNode = this.isNodeSet(node) ? undefined : node;
    }
    backHandler(node) {
        this.isSearch = false;
        this.focusStatus.emit(node);
        this.toggleCurrentNode(node);
    }
    isNodeSet(node) {
        if (this.currentNode !== undefined && this.currentNode.nodeId === node.nodeId) {
            return true;
        }
        return false;
    }
};
OpcuaAddressSpaceComponent.ctorParameters = () => [
    { type: AddressSpaceService },
    { type: OpcuaService }
];
__decorate([
    Output()
], OpcuaAddressSpaceComponent.prototype, "focusStatus", void 0);
OpcuaAddressSpaceComponent = __decorate([
    Component({
        selector: 'opcua-address-space',
        template: "<div class=\"row split-scroll\">\n  <div class=\"col-md-5 col-xs-12 scroll-column no-gutter-r\">\n    <div class=\"card bg-gray-lighter split-scroll flex-scroll\">\n      <div class=\"card-block separator-bottom\">\n        <div class=\"input-group input-group-search\" style=\"margin: -4px 0;\">\n          <input\n            class=\"form-control\"\n            type=\"search\"\n            placeholder=\"{{ filterLabel | translate }}\"\n            (keydown.enter)=\"searchNodes()\"\n            [(ngModel)]=\"searchKey\"\n          />\n          <span class=\"input-group-btn\">\n            <button *ngIf=\"!isSearch\" type=\"submit\" class=\"btn btn-clean\" (click)=\"searchNodes()\">\n              <i c8yIcon=\"search\"></i>\n            </button>\n            <button *ngIf=\"isSearch\" class=\"btn btn-clean\" (click)=\"clearSearch()\">\n              <i c8yIcon=\"times\"></i>\n            </button>\n          </span>\n        </div>\n        <div *ngIf=\"isSearch && !loading\" class=\"p-t-16\">\n          <p *ngIf=\"!searchInProgress\">\n            <em>{{ nodeList.resultLabel | translate }}</em\n            >&nbsp;\n            <span class=\"badge badge-info\">{{ nodeList?.length }}</span>\n          </p>\n        </div>\n      </div>\n\n      <div style=\"padding: 8px;\" *ngIf=\"(isSearch && loading) || searchInProgress\">\n        <div class=\"spinner\" style=\"position: relative\">\n          <div class=\"rect1\"></div>\n          <div class=\"rect2\"></div>\n          <div class=\"rect3\"></div>\n          <div class=\"rect4\"></div>\n          <div class=\"rect5\"></div>\n        </div>\n      </div>\n\n      <div class=\"flex-content-scroll\" *ngIf=\"isSearch && !loading && !searchInProgress\">\n        <div\n          class=\"list-group list-group-links\"\n          *ngIf=\"isSearch && !loading\"\n          style=\"box-shadow: none;\"\n        >\n          <button\n            *ngFor=\"let nodeItem of nodeList\"\n            (click)=\"selectNode(nodeItem)\"\n            [ngClass]=\"{ 'list-group-item flex-row': true }\"\n          >\n            <div class=\"list-group-icon m-r-4\">\n              <i class=\"right-m-xs\" [c8yIcon]=\"getIcon(nodeItem.nodeClassName)\"></i>\n            </div>\n            <div class=\"list-item-body text-truncate\">\n              <span tile=\"nodeId\">{{ nodeItem.nodeId }}</span> {{ nodeItem.displayName }}\n            </div>\n          </button>\n        </div>\n      </div>\n      <div class=\"flex-content-scroll\" *ngIf=\"!isSearch\">\n        <opcua-address-space-tree\n          (selectedNode)=\"toggleCurrentNode($event)\"\n          [focusEmitter]=\"focusStatus\"\n        ></opcua-address-space-tree>\n      </div>\n    </div>\n  </div>\n  <opcua-address-space-detail\n    [node]=\"currentNode\"\n    class=\"col-md-7 col-xs-12 scroll-column no-gutter-l\"\n    style=\"pointer-events: none;\"\n    (toggleAttrDetail)=\"backHandler($event)\"\n  ></opcua-address-space-detail>\n</div>\n"
    })
], OpcuaAddressSpaceComponent);

let OpcuaAgentGuard = class OpcuaAgentGuard {
    constructor() {
        this.type = 'c8y_OPCUA_Device_Agent';
    }
    canActivate({ data }) {
        const { contextData } = data;
        return contextData && contextData.type === this.type;
    }
};
OpcuaAgentGuard = __decorate([
    Injectable()
], OpcuaAgentGuard);

let OpcuaMicroserviceGuard = class OpcuaMicroserviceGuard {
    constructor(app) {
        this.app = app;
        this.microserviceName = 'opcua-mgmt-service';
    }
    canActivate() {
        if (!this.checkApp) {
            this.checkApp = this.app.isApplicationAvailable(this.microserviceName);
        }
        return this.checkApp;
    }
};
OpcuaMicroserviceGuard.ctorParameters = () => [
    { type: AppStateService }
];
OpcuaMicroserviceGuard = __decorate([
    Injectable()
], OpcuaMicroserviceGuard);

let OpcuaServerConfigComponent = class OpcuaServerConfigComponent {
    constructor(opcuaService) {
        this.fileName = '';
        this.targetConnectionState = '1';
        this.minIntervalNumber = 1;
        this.connectionStatusLabel = '';
        this.canceled = new EventEmitter();
        this.removed = new EventEmitter();
        this.saved = new EventEmitter();
        this.NONE = 'NONE';
        this.SIGN = 'SIGN';
        this.SIGN_ENC = 'SIGN_ENCRYPT';
        this.securityPolicies = {
            sign: [
                `BASIC256_${this.SIGN}`,
                `BASIC128RSA15_${this.SIGN}`,
                `BASIC256SHA256_${this.SIGN}`
            ],
            sign_enc: [
                `BASIC256_${this.SIGN_ENC}`,
                `BASIC128RSA15_${this.SIGN_ENC}`,
                `BASIC256SHA256_${this.SIGN_ENC}`,
            ]
        };
        this.ANONYM = {
            id: 1,
            value: gettext('Anonymous')
        };
        this.USER_PASSWORD = {
            id: 2,
            value: gettext('Username/Password')
        };
        this.KEY_BASED = {
            id: 3,
            value: gettext('Key-based Authentication')
        };
        this.initialKeystore = {
            lastModified: 0,
            name: '',
            type: '',
            slice: null,
            size: 0
        };
        this.keystore = this.initialKeystore;
        this.authSwitch = false;
        this.opcuaService = opcuaService;
    }
    set server(server) {
        if (server) {
            this._server = cloneDeep$1(server);
            this.model = cloneDeep$1(server);
            this.fileName = this.model.config.keystoreFilename;
            if (server.id && server.id === 'new') {
                // enabled connection state
                this.targetConnectionState = '1';
                this.model.config.targetConnectionState = 'enabled';
            }
            else {
                this.targetConnectionState = (this.model.config.targetConnectionState === 'enabled') ? '1' : '0';
            }
            this.updateConnectionStatusLabel(this._server);
        }
    }
    get server() {
        return this._server;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.authSwitch = false;
            this.securityModes = [
                this.NONE,
                this.SIGN,
                this.SIGN_ENC
            ];
            this.authenticationModes = [
                this.ANONYM,
                this.USER_PASSWORD,
                this.KEY_BASED
            ];
            this.setCurrentAuthenticationMode();
            this.setCurrentSecurityMode();
        });
    }
    ngOnChanges() {
        this.setCurrentSecurityMode();
        this.setCurrentAuthenticationMode();
    }
    cancel() {
        this.canceled.emit(this.model);
    }
    remove() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.removeKeystore(this.model);
            this.removed.emit(this.model);
        });
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.keystore && this.keystore.size > 0 && this.keystore.name && this.keystore.name.length > 0) {
                const response = yield this.uploadKeystore(this.model.config.keystoreBinaryId);
                if (response && response.data && response.data.id) {
                    this.model.config.keystoreBinaryId = response.data.id;
                }
                // if the keystore was uploaded successful we can remove
                // the local keystore. This will prevent another request to binary api
                // when the user will edit other inputs in the form and hit save again.
                this.keystore = this.initialKeystore;
            }
            // will remove keystore (binary) when the user switched
            // authentication settings from key-based to anonymous or username/password
            if (this.authSwitch) {
                this.removeKeystore(this.server);
            }
            this.saved.emit(this.model);
        });
    }
    uploadFile(droppedFiles) {
        if (droppedFiles.length === 1) {
            this.keystore = droppedFiles[0].file;
            this.fileName = this.keystore.name;
        }
        else {
            // dropped more than one file
            console.warn('Tried to import... Import aborted.');
        }
    }
    setPolicy(data) {
        if (data === this.NONE) {
            this.model.config.securityMode = this.NONE;
        }
        else if (data === this.SIGN) {
            this.model.config.securityMode = this.securityPolicies.sign[0];
        }
        else if (data === this.SIGN_ENC) {
            this.model.config.securityMode = this.securityPolicies.sign_enc[0];
        }
    }
    setServerConnection(data) {
        this.model.config.targetConnectionState = (data !== '0') ? 'enabled' : 'disabled';
    }
    updateAuthentication(data) {
        if (data && data.id) {
            switch (data.id) {
                // Anonymous
                case 1:
                    this.resetUserAuthentication();
                    this.resetKeyBasedAuthentication();
                    break;
                // User/Password
                case 2:
                    this.resetKeyBasedAuthentication();
                    this.restoreUserData();
                    break;
                // Key-based
                case 3:
                    this.resetUserAuthentication();
                    this.restoreKeyBasedData();
                    break;
                default:
                    console.warn('Invalid authentication id', data.id);
                    break;
            }
        }
    }
    updateConnectionStatusLabel(server) {
        const connected = server.c8y_Connection && server.c8y_Connection.status === 'CONNECTED';
        const label = connected ? gettext('Connected') : gettext('Disconnected');
        this.connectionStatusLabel = label;
    }
    uploadKeystore(binaryId) {
        if (!binaryId) {
            return this.opcuaService.uploadKeystore(this.keystore);
        }
        else if (binaryId && binaryId.length > 0) {
            // update existing binary
            return this.opcuaService.updateKeystore(binaryId, this.keystore);
        }
    }
    removeKeystore(server) {
        if (server &&
            server.config &&
            server.config.keystoreBinaryId &&
            server.config.keystoreBinaryId.length > 0) {
            this.authSwitch = false;
            return this.opcuaService.removeKeystore(this.server.config.keystoreBinaryId);
        }
    }
    resetUserAuthentication() {
        this.model.config.userName = null;
        this.model.config.userPassword = null;
        this.model.config.userIdentityMode = 'none';
    }
    resetKeyBasedAuthentication() {
        this.authSwitch = true;
        this.model.config.keystorePass = null;
        this.model.config.certificatePass = null;
        this.model.config.keystoreBinaryId = '';
        this.model.config.keystoreFilename = '';
        this.model.config.userIdentityMode = 'none';
    }
    restoreUserData() {
        this.model.config.userName = this._server.config.userName;
        this.model.config.userPassword = this._server.config.userPassword;
        this.model.config.userIdentityMode = 'userAndPassword';
    }
    restoreKeyBasedData() {
        this.authSwitch = false;
        this.model.config.keystorePass = this._server.config.keystorePass;
        this.model.config.certificatePass = this._server.config.certificatePass;
        this.model.config.keystoreBinaryId = this._server.config.keystoreBinaryId;
        this.model.config.keystoreFilename = this._server.config.keystoreFilename;
        this.model.config.userIdentityMode = 'certificate';
    }
    getServerConfig() {
        let cfg = {
            securityMode: this.NONE,
            userIdentityMode: 'none'
        };
        if (this.server && this.server.config) {
            cfg = this.server.config;
        }
        return cfg;
    }
    setCurrentSecurityMode() {
        const { securityMode } = this.getServerConfig();
        if (securityMode) {
            const foundInSign = this.securityPolicies.sign.find((el) => el === securityMode);
            if (foundInSign) {
                this.currentSecMode = this.SIGN;
            }
            else {
                const foundInSignEncrypt = this.securityPolicies.sign_enc.find((el) => el === securityMode);
                foundInSignEncrypt ? this.currentSecMode = this.SIGN_ENC : this.currentSecMode = this.NONE;
            }
        }
    }
    setCurrentAuthenticationMode() {
        const { userIdentityMode } = this.getServerConfig();
        switch (userIdentityMode) {
            case 'certificate':
                this.authenticationMode = this.KEY_BASED;
                break;
            case 'userAndPassword':
                this.authenticationMode = this.USER_PASSWORD;
                break;
            case 'Anonymous':
                this.authenticationMode = this.ANONYM;
                break;
            case 'UserName':
                this.authenticationMode = this.USER_PASSWORD;
                break;
            case 'Certificate':
                this.authenticationMode = this.KEY_BASED;
                break;
            default:
                this.authenticationMode = this.ANONYM;
                break;
        }
    }
};
OpcuaServerConfigComponent.ctorParameters = () => [
    { type: OpcuaService }
];
__decorate([
    ViewChild('opcuaConfigForm', { static: false })
], OpcuaServerConfigComponent.prototype, "opcuaConfigForm", void 0);
__decorate([
    ViewChild(DropAreaComponent, { static: false })
], OpcuaServerConfigComponent.prototype, "dropArea", void 0);
__decorate([
    Output()
], OpcuaServerConfigComponent.prototype, "canceled", void 0);
__decorate([
    Output()
], OpcuaServerConfigComponent.prototype, "removed", void 0);
__decorate([
    Output()
], OpcuaServerConfigComponent.prototype, "saved", void 0);
__decorate([
    Input()
], OpcuaServerConfigComponent.prototype, "server", null);
OpcuaServerConfigComponent = __decorate([
    Component({
        selector: 'opcua-server-config',
        template: "<form #opcuaConfigForm=\"ngForm\" class=\"card card-scroll\" *ngIf=\"server\">\n  <div class=\"card-header\" style=\"flex-wrap: wrap;\">\n    <button\n      class=\"btn btn-clean visible-sm visible-xs\"\n      title=\"{{ 'Back' | translate }}\"\n      (click)=\"cancel()\"\n    >\n      <i c8y-icon=\"chevron-left\" class=\"fa fw fa-chevron-left\"></i\n      ><span translate>Back</span></button\n    ><br />\n    <!-- SERVER NAME -->\n    <label class=\"editable\" style=\"width: 100%;\">\n      <input\n        type=\"text\"\n        class=\"form-control input-lg\"\n        placeholder=\"{{ 'Server name' | translate }}\"\n        id=\"name\"\n        name=\"name\"\n        [(ngModel)]=\"model.name\"\n        required\n      />\n    </label>\n  </div>\n  <div class=\"inner-scroll\">\n    <div class=\"card-block bg-gray-lighter top-p-md\">\n      <div class=\"tight-grid\">\n        <div class=\"col-sm-6\">\n          <label style=\"width: 100%;\" translate>Server connection</label>\n          <button\n            type=\"button\"\n            class=\"btn top-m-xs\"\n            name=\"serverConnection\"\n            [(ngModel)]=\"targetConnectionState\"\n            (ngModelChange)=\"setServerConnection($event)\"\n            btnCheckbox\n            btnCheckboxTrue=\"1\"\n            btnCheckboxFalse=\"0\"\n          >\n            <span\n              title=\"{{ 'Enabled' | translate }}\"\n              [hidden]=\"targetConnectionState !== '1'\"\n              translate\n              >Enabled</span\n            >\n            <span\n              title=\"{{ 'Disabled' | translate }}\"\n              [hidden]=\"targetConnectionState !== '0'\"\n              translate\n              >Disabled</span\n            >\n          </button>\n        </div>\n        <div class=\"col-sm-6\">\n          <label translate>Connection status</label>\n          <div class=\"form-control-static\">\n            <device-status class=\"right-p-sm\" [mo]=\"server\"></device-status>\n            <span>{{ connectionStatusLabel | translate }}</span>\n          </div>\n        </div>\n      </div>\n    </div>\n    <div class=\"card-block\">\n      <!-- SERVER URL-->\n      <c8y-form-group>\n        <label for=\"configServerUrl\" translate>Server URL</label>\n        <input\n          type=\"text\"\n          class=\"form-control\"\n          id=\"configServerUrl\"\n          name=\"serverUrl\"\n          [(ngModel)]=\"model.config.serverUrl\"\n          c8yDefaultValidation=\"opcuaBrowsePath\"\n          required\n        />\n      </c8y-form-group>\n\n      <!-- TIMEOUT & STATUS-CHECK-INTERVAL-->\n      <div class=\"tight-grid\">\n        <div class=\"col-md-6\">\n          <c8y-form-group>\n            <label for=\"config.timeout\" translate>Timeout</label>\n            <div class=\"input-group\">\n              <input\n                type=\"number\"\n                class=\"form-control\"\n                id=\"config.timeout\"\n                name=\"timeout\"\n                [min]=\"minIntervalNumber\"\n                placeholder=\"{{ 'e.g.' | translate }} 30\"\n                [(ngModel)]=\"model.config.timeout\"\n                required\n              />\n              <span class=\"input-group-addon units\" translate>\n                seconds\n              </span>\n            </div>\n          </c8y-form-group>\n        </div>\n        <div class=\"col-md-6\">\n          <c8y-form-group>\n            <label for=\"config.statusCheckInterval\" translate>Status check interval</label>\n            <div class=\"input-group\">\n              <input\n                type=\"number\"\n                class=\"form-control\"\n                id=\"config.statusCheckInterval\"\n                name=\"statusCheckInterval\"\n                [min]=\"minIntervalNumber\"\n                placeholder=\"{{ 'e.g.' | translate }} 40\"\n                [(ngModel)]=\"model.config.statusCheckInterval\"\n                required\n              />\n              <span class=\"input-group-addon units\" translate>\n                seconds\n              </span>\n            </div>\n          </c8y-form-group>\n        </div>\n      </div>\n\n      <!-- SECURITY MODE -->\n      <div class=\"tight-grid\">\n        <div class=\"col-md-6\">\n          <div class=\"form-group\">\n            <!-- NONE, SIGN, SIGN & ENCRYPT-->\n            <label for=\"config.securityMode\" translate>Security mode</label>\n            <div class=\"c8y-select-wrapper\">\n              <select\n                class=\"form-control\"\n                id=\"config.securityMode\"\n                [(ngModel)]=\"currentSecMode\"\n                (ngModelChange)=\"setPolicy($event)\"\n                name=\"securityMode\"\n                required\n              >\n                <option *ngFor=\"let mode of securityModes\" [ngValue]=\"mode\">{{ mode }}</option>\n              </select>\n              <span></span>\n            </div>\n          </div>\n        </div>\n        <div *ngIf=\"currentSecMode === NONE\" class=\"col-md-6\">\n          <div class=\"form-group\">\n            <label for=\"config.securityPolicy\" translate>Security policy</label>\n            <input\n              type=\"text\"\n              class=\"form-control\"\n              id=\"config.securityPolicy\"\n              name=\"securityPolicy\"\n              [readonly]=\"true\"\n              [(ngModel)]=\"model.config.securityMode\"\n              required\n            />\n          </div>\n        </div>\n        <div *ngIf=\"currentSecMode !== NONE\" class=\"col-md-6\">\n          <div class=\"form-group\">\n            <label for=\"config.securityPolicy\" translate>Security policy</label>\n            <div class=\"c8y-select-wrapper\">\n              <select\n                *ngIf=\"currentSecMode === SIGN\"\n                class=\"form-control\"\n                id=\"config.securityPolicy\"\n                [(ngModel)]=\"model.config.securityMode\"\n                name=\"securityPolicy\"\n                required\n              >\n                <option *ngFor=\"let policy of securityPolicies.sign\" [ngValue]=\"policy\">{{\n                  policy\n                }}</option>\n              </select>\n              <select\n                *ngIf=\"currentSecMode === SIGN_ENC\"\n                class=\"form-control\"\n                id=\"config.securityPolicy\"\n                [(ngModel)]=\"model.config.securityMode\"\n                name=\"securityPolicy\"\n                required\n              >\n                <option *ngFor=\"let policy of securityPolicies.sign_enc\" [ngValue]=\"policy\">{{\n                  policy\n                }}</option>\n              </select>\n              <span></span>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <!-- AUTHENTICATION -->\n      <div class=\"form-group\">\n        <label for=\"config.authenticationMode\" translate>Authentication</label>\n        <div class=\"c8y-select-wrapper\">\n          <select\n            class=\"form-control\"\n            id=\"config.authenticationMode\"\n            [(ngModel)]=\"authenticationMode\"\n            name=\"authenticationMode\"\n            (ngModelChange)=\"updateAuthentication($event)\"\n            required\n          >\n            <option *ngFor=\"let auth of authenticationModes\" [ngValue]=\"auth\">{{\n              auth.value | translate\n            }}</option>\n          </select>\n          <span></span>\n        </div>\n      </div>\n\n      <!-- User/Pw-->\n      <div *ngIf=\"authenticationMode.id === 2\" class=\"tight-grid\">\n        <div class=\"col-md-6\">\n          <div class=\"form-group\">\n            <label for=\"config.userName\" translate>Username</label>\n            <input\n              type=\"text\"\n              class=\"form-control\"\n              id=\"config.userName\"\n              name=\"userName\"\n              placeholder=\"{{ 'e.g. joe.doe`LOCALIZE`' | translate }}\"\n              [(ngModel)]=\"model.config.userName\"\n              required\n            />\n          </div>\n        </div>\n        <div class=\"col-md-6\">\n          <div class=\"form-group\">\n            <label for=\"config.password\" translate>Password</label>\n            <input\n              type=\"password\"\n              class=\"form-control\"\n              id=\"config.userPassword\"\n              name=\"password\"\n              [(ngModel)]=\"model.config.userPassword\"\n              required\n            />\n          </div>\n        </div>\n      </div>\n      <!-- Key-based -->\n      <div *ngIf=\"authenticationMode.id === 3\" class=\"tight-grid\">\n        <!-- KEYSTORE PASSWORD -->\n        <div class=\"col-md-6\">\n          <div class=\"form-group\">\n            <label for=\"config.keystorePass\" translate>Keystore password</label>\n            <input\n              type=\"password\"\n              class=\"form-control\"\n              id=\"config.keystorePass\"\n              name=\"keystorePass\"\n              [(ngModel)]=\"model.config.keystorePass\"\n              required\n            />\n          </div>\n        </div>\n        <div class=\"col-md-6\">\n          <div class=\"form-group\">\n            <label for=\"config.certificatePass\" translate>Certificate password</label>\n            <input\n              type=\"password\"\n              class=\"form-control\"\n              id=\"config.certificatePass\"\n              name=\"keystorePass\"\n              [(ngModel)]=\"model.config.certificatePass\"\n              required\n            />\n          </div>\n        </div>\n        <!-- UPLOAD KEYSTORE -->\n        <div class=\"col-md-12\">\n          <div class=\"form-group\">\n            <label for=\"certificateUpload\" translate>Upload keystore</label>\n            <input\n              type=\"text\"\n              [readonly]=\"true\"\n              name=\"certificateUpload\"\n              class=\"form-control bottom-m-sm\"\n              [ngModel]=\"fileName\"\n              placeholder=\"{{ 'e.g.' | translate }} yourKeystore.jks\"\n              required\n            />\n            <c8y-drop-area\n              (dropped)=\"uploadFile($event)\"\n              [loadingMessage]=\"'Importing, please wait.' | translate\"\n              [title]=\"'Import keystore with jks file extension' | translate\"\n            >\n            </c8y-drop-area>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n  <div class=\"card-footer separator text-center\">\n    <button title=\"{{ 'Cancel' | translate }}\" class=\"btn btn-default\" (click)=\"cancel()\" translate>\n      Cancel\n    </button>\n    <button title=\"{{ 'Remove' | translate }}\" class=\"btn btn-danger\" (click)=\"remove()\" translate>\n      Remove\n    </button>\n    <!-- Add [disabled]=\"method()\" when form is invalid-->\n    <button\n      title=\"{{ 'Save' | translate }}\"\n      class=\"btn btn-primary\"\n      (click)=\"save()\"\n      [disabled]=\"!opcuaConfigForm.valid\"\n      translate\n    >\n      Save\n    </button>\n  </div>\n</form>\n"
    })
], OpcuaServerConfigComponent);

let OpcuaServerListComponent = class OpcuaServerListComponent {
    constructor() {
        this.serverList = [];
        this.present = new EventEmitter();
    }
    presentConfig(server) {
        server.active = true;
        this.present.emit(server);
    }
};
__decorate([
    Input()
], OpcuaServerListComponent.prototype, "serverList", void 0);
__decorate([
    Output()
], OpcuaServerListComponent.prototype, "present", void 0);
OpcuaServerListComponent = __decorate([
    Component({
        selector: 'opcua-server-list',
        template: "<!-- add active class to c8y-stacked-item when clicked -->\n<div\n  class=\"c8y-stacked-item\"\n  [class.active]=\"server.active\"\n  *ngFor=\"let server of serverList\"\n  (click)=\"presentConfig(server)\"\n>\n  <i [c8yIcon]=\"'server'\" style=\"font-size:1.4em;\" class=\"text-gray-darker\"></i>\n  <div class=\"left-p-md text-truncate\">\n    <p id=\"serverName\" class=\"text-truncate\">{{ server.name }}</p>\n    <small id=\"serverUrl\" class=\"text-truncate text-muted\">{{ server.config.serverUrl }}</small>\n  </div>\n  <div class=\"flex-item-right left-p-sm\" style=\"display: flex;\">\n    <device-status class=\"right-p-sm\" [mo]=\"server\"></device-status>\n    <a\n      tooltip=\"{{ server.quickInfo.padlockMsg | translate }}\"\n      placement=\"left\"\n      container=\"body\"\n      class=\"text-gray-darker\"\n    >\n      <i [c8yIcon]=\"server.quickInfo.padlock\"></i>\n    </a>\n  </div>\n</div>\n"
    })
], OpcuaServerListComponent);

let OpcuaServerGuard = class OpcuaServerGuard {
    constructor() {
        this.type = 'c8y_OpcuaServer';
    }
    canActivate({ data }) {
        const { contextData } = data;
        return contextData && contextData.type === this.type;
    }
};
OpcuaServerGuard = __decorate([
    Injectable()
], OpcuaServerGuard);

let OpcuaServersComponent = class OpcuaServersComponent {
    constructor(opcuaService, alertService, translateService, context) {
        this.opcuaService = opcuaService;
        this.alertService = alertService;
        this.translateService = translateService;
        this.context = context;
        this.serverObjectList = [];
        this.initialServerObject = {
            id: '',
            name: 'New Server',
            config: {
                securityMode: 'NONE',
                keystorePass: null,
                keystoreBinaryId: null,
                keystoreFilename: '',
                certificatePass: null,
                serverUrl: '',
                userName: '',
                userPassword: '',
                rescanCron: null,
                timeout: null,
                autoReconnect: true,
                statusCheckInterval: null,
                valid: true
            },
            quickInfo: {
                padlock: 'unlock',
                padlockMsg: ''
            },
            active: true
        };
        this.active = false;
        this.moId = '';
        this.NEW_SERVER_ID = 'new';
        this.initialServerObject.id = this.NEW_SERVER_ID;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.moId = this.opcuaService.getMoId();
            if (this.moId && this.moId.length > 0) {
                const res = yield this.opcuaService.getServers(this.moId);
                if (res && res.status !== 200) {
                    const data = res.json ? yield res.json() : undefined;
                    this.alertService.addServerFailure({ data, res });
                }
                else {
                    this.serverObjectList = (yield res.json());
                    this.serverObjectList.map(server => this.setQuickInfo(server));
                }
            }
        });
    }
    localServerObjectExist() {
        return !!this.serverObjectList.find(server => server.id === this.NEW_SERVER_ID);
    }
    addServer() {
        const server = this.initialServerObject;
        this.serverObjectList.push(server);
        this.onPresent(server);
    }
    onSaved(server) {
        if (server && server.id) {
            server.gatewayId = this.moId;
            if (server.id === this.NEW_SERVER_ID) {
                this.createServer(server);
            }
            else {
                this.updateServer(server);
            }
        }
    }
    reloadTabs() {
        if (this.context) {
            this.context.refreshTabs();
        }
    }
    onCanceled(server) {
        if (server && server.id && server.id === this.NEW_SERVER_ID) {
            this.removeServerObjectListById(server.id);
        }
        else {
            // update activity status for UI
            this.serverObjectList.forEach(item => {
                if (item.id === server.id) {
                    item.active = false;
                }
            });
            // When server id is not 'new' we just close the details
            delete this.server;
        }
    }
    onRemoved(server) {
        if (server.id === this.NEW_SERVER_ID) {
            this.onCanceled(server);
        }
        else {
            this.removeServer(server);
        }
    }
    getKeystore(binaryId) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.opcuaService.getKeystore(binaryId);
            return data;
        });
    }
    onPresent(server) {
        return __awaiter(this, void 0, void 0, function* () {
            if (server &&
                server.id !== this.NEW_SERVER_ID &&
                server.config &&
                server.config.keystoreBinaryId) {
                try {
                    const mo = yield this.getKeystore(server.config.keystoreBinaryId);
                    server.config.keystoreFilename = mo.name;
                }
                catch (ex) {
                    this.server = Object.assign({}, server);
                    console.log('Could not get existing keystore:', ex);
                }
            }
            if (this.serverObjectList.length > 0) {
                this.serverObjectList.forEach(item => {
                    item.active = false;
                    if (item.id === server.id) {
                        item.active = true;
                        server.active = item.active;
                    }
                });
                this.setQuickInfo(server);
                this.server = Object.assign({}, server);
            }
        });
    }
    createServer(server) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.opcuaService.createServer(server);
            const svr = (yield response.json());
            this.updateServerObjectListById(this.NEW_SERVER_ID, svr);
            this.reloadTabs();
        });
    }
    updateServer(server) {
        return __awaiter(this, void 0, void 0, function* () {
            const updatedServer = (yield this.opcuaService.updateServer(server));
            if (updatedServer) {
                this.updateServerObjectListById(updatedServer.id, updatedServer);
            }
        });
    }
    removeServer(server) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.opcuaService.removeServer(server);
                this.removeServerObjectListById(server.id);
                this.reloadTabs();
            }
            catch (ex) {
                console.log('Could not remove OPC UA server:', ex);
            }
        });
    }
    removeServerObjectListById(id) {
        this.serverObjectList.forEach((item, index) => {
            if (item.id === id) {
                this.serverObjectList.splice(index, 1);
                delete this.server;
            }
        });
    }
    updateServerObjectListById(id, server) {
        const idx = this.serverObjectList.findIndex(item => item.id === id);
        if (idx > -1) {
            this.setQuickInfo(server);
            this.serverObjectList[idx] = server;
        }
        delete this.server;
    }
    setQuickInfo(server) {
        server.quickInfo = {
            padlock: 'unlock',
            padlockMsg: ''
        };
        if (server && server.config) {
            if (server.config.securityMode) {
                server.quickInfo.padlock = server.config.securityMode !== 'NONE' ? 'lock' : 'unlock';
                server.quickInfo.padlockMsg = this.translateService.instant(gettext('The security policy is set to {{param}}.'), { param: server.config.securityMode });
            }
        }
    }
};
OpcuaServersComponent.ctorParameters = () => [
    { type: OpcuaService },
    { type: AlertService },
    { type: TranslateService },
    { type: ContextRouteComponent, decorators: [{ type: Optional }] }
];
OpcuaServersComponent = __decorate([
    Component({
        selector: 'opcua-servers',
        template: "<div class=\"row split-scroll\">\n  <div class=\"col-md-6 scroll-column has-footer\">\n    <div class=\"c8y-nav-stacked inner-scroll\">\n      <h4 class=\"bottom-m-sm\" translate>OPC UA servers</h4>\n      <p class=\"bottom-m-lg\" translate>\n        Below you can configure one or more OPC UA servers. The OPC UA agent will connect to these\n        servers if they are enabled and the connection state is set to \"connected\".\n      </p>\n      <opcua-server-list [serverList]=\"serverObjectList\" (present)=\"onPresent($event)\">\n      </opcua-server-list>\n    </div>\n    <div class=\"scroll-column-footer\">\n      <button\n        title=\"{{ 'Add server' | translate }}\"\n        class=\"btn btn-add-block\"\n        [disabled]=\"localServerObjectExist()\"\n        (click)=\"addServer()\"\n      >\n        <i [c8yIcon]=\"'plus-square'\"></i> {{ 'Add server' | translate }}\n      </button>\n    </div>\n  </div>\n\n  <opcua-server-config\n    class=\"col-md-6 scroll-column fast animated\"\n    [ngClass]=\"{ slideInRight: server, slideOutRight: !server }\"\n    (canceled)=\"onCanceled($event)\"\n    (removed)=\"onRemoved($event)\"\n    (saved)=\"onSaved($event)\"\n    [server]=\"server\"\n  >\n  </opcua-server-config>\n</div>\n"
    }),
    __param(3, Optional())
], OpcuaServersComponent);

let OpcuaDeviceProtocolDescription = class OpcuaDeviceProtocolDescription {
    constructor() {
        this.moId = '';
    }
    set model(_model) {
        this.moId = _model.referencedServerId;
        this._model = _model;
        this.autoScan = _model.enabled ? '1' : '0';
    }
    setAutoScanOption(data) {
        this._model.enabled = data !== '0' ? true : false;
    }
};
__decorate([
    Input()
], OpcuaDeviceProtocolDescription.prototype, "model", null);
OpcuaDeviceProtocolDescription = __decorate([
    Component({
        selector: 'opcua-device-protocol-description',
        template: "<div class=\"card bottom-m-xs\">\n  <div class=\"card-block\">\n    <div class=\"row\">\n      <div class=\"col-md-7\">\n        <div class=\"form-group\">\n          <label translate>Name</label>\n          <label class=\"editable\" [ngClass]=\"{'updated': ctrlName.dirty}\">\n            <input type=\"text\" class=\"form-control\" name=\"name\" #ctrlName=\"ngModel\" [(ngModel)]=\"_model.name\">\n          </label>\n        </div>\n        <div class=\"form-group\">\n          <label translate>Description</label>\n          <label class=\"editable\" [ngClass]=\"{'updated': ctrlDescription.dirty}\">\n            <textarea class=\"form-control\" rows=\"1\" name=\"description\" #ctrlDescription=\"ngModel\"\n              [(ngModel)]=\"_model.description\"></textarea>\n            <span *ngIf=\"_model.description\">{{ _model.description }}</span>\n          </label>\n        </div>\n        <div class=\"flex-row\">\n          <div style=\"min-width: 120px;\">\n            <button type=\"button\" class=\"btn top-m-xs\" name=\"autoScanAddressSpace\" [(ngModel)]=\"autoScan\"\n              (ngModelChange)=\"setAutoScanOption($event)\" btnCheckbox btnCheckboxTrue=\"1\" btnCheckboxFalse=\"0\"\n              ngDefaultControl>\n              <span *ngIf=\"autoScan === '1'\"><i c8yIcon=\"check\" class=\"text-success\"></i>\n                {{ 'Active' | translate }}</span>\n              <span *ngIf=\"autoScan === '0'\">\n                <i c8yIcon=\"ban\" class=\"text-danger\"></i> {{ 'Inactive' | translate }}</span>\n            </button>\n          </div>\n          <small class=\"m-l-16 text-muted\">\n            {{\n              'When active, the gateway scans the address space of all servers and automatically applies\n            this device protocol to all nodes matching the criteria.'\n                | translate\n            }}\n          </small>\n        </div>\n      </div>\n      <div class=\"col-md-5\">\n        <dl class=\"dl-horizontal\" style=\"margin-bottom:0;\">\n          <dt><label translate>Device protocol type</label></dt>\n          <dd>\n            <span class=\"label label-info right-m-sm\" style=\"text-transform: capitalize;\">{{\n              _model.fieldbusType\n            }}</span>\n          </dd>\n          <dt><label class=\"small\" translate>ID</label></dt>\n          <dd style=\"font-size:1.5em\">{{ _model.id }}</dd>\n          <dt><label class=\"small\" translate>Date created</label></dt>\n          <dd>{{ _model.creationTime | date: 'medium' }}</dd>\n          <dt><label class=\"small\" translate>Last update</label></dt>\n          <dd>{{ _model.lastUpdated | date: 'medium' }}</dd>\n          <dt><label class=\"small\" translate>Fieldbus version</label></dt>\n          <dd>{{ _model.fieldbusVersion }}</dd>\n        </dl>\n      </div>\n    </div>\n  </div>\n</div>",
        viewProviders: [{ provide: ControlContainer, useExisting: NgForm }]
    })
], OpcuaDeviceProtocolDescription);

class DynamicDataSource {
    constructor(treeControl, addressSpaceService, serverId) {
        this.treeControl = treeControl;
        this.addressSpaceService = addressSpaceService;
        this.serverId = serverId;
        this.dataChange = new BehaviorSubject([]);
        this.treeControl.isExpanded = (node) => node.expanded;
    }
    get data() {
        return this.dataChange.value;
    }
    set data(value) {
        this.treeControl.dataNodes = value;
        this.dataChange.next(value);
    }
    connect(collectionViewer) {
        this.treeControl.expansionModel.onChange.subscribe((change) => {
            if (change.added || change.removed) {
                this.handleTreeControl(change);
            }
        });
        return merge(collectionViewer.viewChange, this.dataChange).pipe(map(() => this.data));
    }
    /** Handle expand/collapse behaviors */
    handleTreeControl(change) {
        if (change.added) {
            change.added.forEach(node => this.toggleNode(node, true));
        }
        if (change.removed) {
            change.removed
                .slice()
                .reverse()
                .forEach(node => this.toggleNode(node, false));
        }
    }
    /**
     * Toggle the node, remove from display list
     */
    toggleNode(addressSpaceNode, expand) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!addressSpaceNode.children || addressSpaceNode.children.length === 0) {
                addressSpaceNode.currentlyLoadingChildren = true;
                const res = yield this.addressSpaceService.getChildrenOf(addressSpaceNode, this.serverId);
                const children = (yield res.json());
                addressSpaceNode.children = children || [];
                addressSpaceNode.children = addressSpaceNode.children.map((node) => {
                    node.parentNode = addressSpaceNode;
                    return node;
                });
                addressSpaceNode.currentlyLoadingChildren = false;
                this.treeControl.expand(addressSpaceNode);
            }
            addressSpaceNode.expanded = expand && addressSpaceNode.children.length > 0;
            this.refreshNestedTree(this.data);
            return Promise.resolve(addressSpaceNode);
        });
    }
    catch() {
        // do nothing
    }
    refreshNestedTree(treeData) {
        // necessary to rerender tree, otherwise new nodes will not
        // appear, but they are added to the list.
        this.data = [];
        this.dataChange.next(treeData);
        this.triggerResize(); // to resize the modal window when creating a new device protocol
    }
    triggerResize() {
        setTimeout(() => {
            try {
                window.dispatchEvent(new Event('resize'));
            }
            catch (error) {
                // do nothing
            }
        }, 200);
    }
}

let OpcuaAddressSpaceTreeComponent = class OpcuaAddressSpaceTreeComponent {
    constructor(addressSpaceService, opcuaService, alertService) {
        this.addressSpaceService = addressSpaceService;
        this.opcuaService = opcuaService;
        this.alertService = alertService;
        this.focusEmitter = new EventEmitter();
        this.selectedNode = new EventEmitter();
        this.dataSource = null;
        this.loading = false;
        this.getChildren = (node) => (node.expanded ? node.children : []);
        this.hasChild = (_, _nodeData) => this.addressSpaceService.childrenAvailable(_nodeData.references);
    }
    set moId(id) {
        this._moId = id || undefined;
    }
    ngOnInit() {
        this.nodeNavDataSubscription = this.addressSpaceService
            .getNodeNavData$()
            .subscribe(nodeNavData => this.openNode(nodeNavData));
        this.subscriptionRef = this.focusEmitter.subscribe(node => {
            this.focused = this.isFocusedNode(node) ? undefined : node;
        });
    }
    ngOnDestroy() {
        // clean up the address-space-tree
        this.addressSpaceService.resetTreeToRootNode();
        if (this.nodeNavDataSubscription && !this.nodeNavDataSubscription.closed) {
            this.nodeNavDataSubscription.unsubscribe();
        }
        if (this.subscriptionRef && !this.subscriptionRef.closed) {
            this.subscriptionRef.unsubscribe();
        }
    }
    openNode(nodeNavData) {
        return __awaiter(this, void 0, void 0, function* () {
            const { node, selectedAncestorIds } = nodeNavData;
            let nodeId;
            // We just set the nodeId when the selectedAncestorIds variable an empty array.
            // If selectedAncestorIds contain any id we assume that the tree should be travsersed beginning
            // from the root node.
            if (node && node.nodeId && selectedAncestorIds && selectedAncestorIds.length === 0) {
                nodeId = node.nodeId;
            }
            // Always recreate the tree when routing to a specific nested node,
            // because previous modifications to the tree-structure could cause errors
            // while traversing with 'old' tree-data
            // -----------------
            // setupTree is able to handle nodeId = undefined
            yield this.setupTree(nodeId);
            if (!selectedAncestorIds || selectedAncestorIds.length === 0) {
                return;
            }
            if (nodeNavData && this.dataSource) {
                const clonedAncestors = clone(selectedAncestorIds);
                clonedAncestors.shift();
                const n = yield this.dataSource.toggleNode(this.dataSource.data[0], true);
                this.setChildNodes(n.children, clonedAncestors);
                this.toggleFocusedNode(node);
            }
        });
    }
    setChildNodes(nodes, ids) {
        if (nodes) {
            ids.forEach((id) => __awaiter(this, void 0, void 0, function* () {
                const match = nodes.find(n => n.nodeId === id);
                if (match && ids.length > 0) {
                    const idx = ids.findIndex(value => value === id);
                    if (idx >= 0) {
                        ids.splice(idx, 1);
                    }
                    const toggledNode = yield this.dataSource.toggleNode(match, true);
                    this.setChildNodes(toggledNode.children, ids);
                }
            }));
        }
    }
    setupTree(nodeId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.loading = true;
            if (!this._moId || this._moId.length === 0) {
                this._moId = this.opcuaService.getMoId();
            }
            // addressSpaceService.getNode returns either the root node of the server (moId)
            // or if nodeId !== undefined the node with given nodeId
            const res = yield this.addressSpaceService.getNode(this._moId, nodeId);
            if (res) {
                if (res.status !== 200) {
                    const data = res.json ? yield res.json() : undefined;
                    this.alertService.addServerFailure({ data, res });
                    this.dataSource = undefined;
                }
                else {
                    const rootNode = (yield res.json());
                    this.nestedTreeControl = new NestedTreeControl(this.getChildren);
                    this.dataSource = new DynamicDataSource(this.nestedTreeControl, this.addressSpaceService, this._moId);
                    this.dataSource.data = [rootNode];
                }
                this.loading = false;
            }
            else {
                this.loading = false;
            }
        });
    }
    getMoId() {
        if (!this._moId || this._moId.length === 0) {
            return this.opcuaService.getMoId();
        }
        return this._moId;
    }
    getIcon(nodeClassName) {
        return this.addressSpaceService.getIcon(nodeClassName);
    }
    toggleFocusedNode(node) {
        const relativePath = [];
        this.getRelativePath(node, relativePath);
        node.relativePath = relativePath;
        this.selectedNode.emit(node);
        this.focused = this.isFocusedNode(node) ? undefined : node;
    }
    isFocusedNode(node) {
        if (this.focused) {
            return node.nodeId === this.focused.nodeId;
        }
        return false;
    }
    getRelativePath(node, relativePath) {
        if (node.parentNode) {
            relativePath.unshift(node.browseName);
            this.getRelativePath(node.parentNode, relativePath);
        }
    }
};
OpcuaAddressSpaceTreeComponent.ctorParameters = () => [
    { type: AddressSpaceService },
    { type: OpcuaService },
    { type: AlertService }
];
__decorate([
    Input()
], OpcuaAddressSpaceTreeComponent.prototype, "moId", null);
__decorate([
    Input()
], OpcuaAddressSpaceTreeComponent.prototype, "node", void 0);
__decorate([
    Input()
], OpcuaAddressSpaceTreeComponent.prototype, "focusEmitter", void 0);
__decorate([
    Output()
], OpcuaAddressSpaceTreeComponent.prototype, "selectedNode", void 0);
OpcuaAddressSpaceTreeComponent = __decorate([
    Component({
        selector: 'opcua-address-space-tree',
        template: "<div class=\"card-block\" *ngIf=\"dataSource && !loading\">\n  <cdk-tree [dataSource]=\"dataSource\" [treeControl]=\"nestedTreeControl\">\n    <!-- This is the tree node template for leaf nodes -->\n    <cdk-nested-tree-node *cdkTreeNodeDef=\"let node\" (click)=\"toggleFocusedNode(node)\"\n    [ngClass]=\"{'strong':isFocusedNode(node)}\" style=\"cursor: pointer\">\n      <span>\n        <i class=\"right-m-xs\" \n        [c8yIcon]=\"getIcon(node.nodeClassName)\" \n        [ngClass]=\"{'strong':isFocusedNode(node)}\" \n        style=\"cursor: pointer\"></i>\n        {{node.displayName}}\n      </span>\n    </cdk-nested-tree-node>\n    <!-- This is the tree node template for expandable nodes -->\n    <cdk-nested-tree-node *cdkTreeNodeDef=\"let node; when: hasChild\">\n      <div class=\"flex-row\">\n        <button cdkTreeNodeToggle class=\"btn-clean text-primary right-m-xs\" [disabled]=\"node.currentlyLoadingChildren\">\n          <i class=\"fa\" [ngClass]=\"{'fa-plus-square': !node.expanded, 'fa-minus-square': node.expanded}\"></i>\n        </button>\n        <i class=\"right-m-xs\" [c8yIcon]=\"getIcon(node.nodeClassName)\" [ngClass]=\"{'strong':isFocusedNode(node)}\" style=\"cursor: pointer\"></i>\n        <span (click)=\"toggleFocusedNode(node)\" [ngClass]=\"{'strong':isFocusedNode(node)}\" style=\"cursor: pointer\"> {{node.displayName}} </span>\n        <span class=\"left-m-xs\" [style.visibility]=\"node.currentlyLoadingChildren ? 'visible': 'hidden'\">\n          <i class=\"fa fa-circle-o-notch fa-spin\"></i>\n        </span>\n      </div>\n      <ng-container cdkTreeNodeOutlet></ng-container>\n    </cdk-nested-tree-node>\n  </cdk-tree>\n</div>\n<div style=\"padding: 8px;\" *ngIf=\"loading\">\n  <div class=\"spinner\" style=\"position: relative\">\n    <div class=\"rect1\"></div>\n    <div class=\"rect2\"></div>\n    <div class=\"rect3\"></div>\n    <div class=\"rect4\"></div>\n    <div class=\"rect5\"></div>\n  </div>\n</div>\n<div class=\"alert alert-info m-t-16\" *ngIf=\"!dataSource && !loading\" translate>\n  No source data available to fetch address space.\n</div>"
    })
], OpcuaAddressSpaceTreeComponent);

let OpcuaAutoApplySettingsComponent = class OpcuaAutoApplySettingsComponent {
    constructor(inventoryService) {
        this.inventoryService = inventoryService;
        this.opcuaServers = [];
        this.selected = [];
        this.constraints = {
            browsePathMatchesRegex: '',
            matchesNodeIds: [],
            serverObjectHasFragment: '',
            matchesServerIds: []
        };
        this.placeholderSelectServerIds = gettext('Select server IDs from list');
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.inventoryService.list({
                pageSize: 1000,
                withTotalPages: true,
                type: 'c8y_OpcuaServer'
            });
            this.opcuaServers = data;
            this.selected = [];
            const { matchesServerIds } = this.constraints;
            data.forEach(server => {
                if (matchesServerIds &&
                    matchesServerIds.length > 0 &&
                    matchesServerIds.find(itemId => itemId === server.id)) {
                    this.selected.push(server);
                }
            });
        });
    }
    set model(model) {
        if (model && model.applyConstraints) {
            this.constraints = model.applyConstraints;
        }
        this._model = model;
    }
    get model() {
        return this._model;
    }
    serverIdsSelected(items) {
        if (this.constraints) {
            this.constraints.matchesServerIds = items.map((item) => item.id);
        }
        this.selected = items;
    }
    onChangeNodeId(event) {
        if (event.target.checked) {
            this.showRootNodes = true;
            this.add();
        }
        else {
            this.showRootNodes = false;
            this.constraints.matchesNodeIds = [];
        }
    }
    add() {
        this.constraints.matchesNodeIds.push('');
    }
    remove(index) {
        this.constraints.matchesNodeIds.splice(index, 1);
    }
    trackByFn(index, item) {
        return index;
    }
};
OpcuaAutoApplySettingsComponent.ctorParameters = () => [
    { type: InventoryService }
];
__decorate([
    Input()
], OpcuaAutoApplySettingsComponent.prototype, "model", null);
OpcuaAutoApplySettingsComponent = __decorate([
    Component({
        selector: 'opcua-auto-apply',
        template: "<div class=\"row\">\n  <div class=\"col-md-4\">\n    <p translate>\n      Specifying auto-apply constraints allows you to limit the scope where the device types are\n      applied, for example by specifying a set of possible servers or node IDs.\n    </p>\n    <p translate>\n      If no constraints are set, device types are applied at any fitting location on the OPC UA\n      server.\n    </p>\n  </div>\n\n  <div class=\"col-md-6\">\n    <ul class=\"list-group\" style=\"box-shadow: none;\">\n      <!-- Limit device type to a set of servers -->\n      <li class=\"list-group-item\">\n        <label class=\"c8y-checkbox\">\n          <input\n            type=\"checkbox\"\n            [checked]=\"constraints.matchesServerIds.length > 0\"\n            (change)=\"$event.target.checked ? (showServerIds = true) : (showServerIds = false)\"\n          />\n          <span></span>\n          <strong class=\"m-l-8\" translate>Limit device type to a set of servers</strong>\n        </label>\n        <div\n          class=\"collapse\"\n          [collapse]=\"!showServerIds && constraints.matchesServerIds.length < 1\"\n        >\n          <c8y-form-group class=\"m-t-8 m-b-8\">\n            <c8y-select\n              [items]=\"opcuaServers\"\n              [selected]=\"selected\"\n              [placeholder]=\"placeholderSelectServerIds\"\n              (onChange)=\"serverIdsSelected($event)\"\n            >\n            </c8y-select>\n          </c8y-form-group>\n        </div>\n      </li>\n      <!-- Limit device type scope in the address space -->\n      <li class=\"list-group-item\">\n        <label class=\"c8y-checkbox\">\n          <input\n            type=\"checkbox\"\n            [checked]=\"constraints.browsePathMatchesRegex.length > 0\"\n            (change)=\"$event.target.checked ? (showBrowsePath = true) : (showBrowsePath = false)\"\n          />\n          <span></span>\n          <strong class=\"m-l-8\" translate>Limit device type scope in the address space</strong>\n        </label>\n        <div\n          class=\"collapse\"\n          [isAnimated]=\"true\"\n          [collapse]=\"!showBrowsePath && constraints.browsePathMatchesRegex.length < 1\"\n        >\n          <c8y-form-group class=\"m-t-8 m-b-8\">\n            <input\n              name=\"browsePath\"\n              type=\"text\"\n              class=\"form-control\"\n              placeholder=\"{{ 'e.g.' | translate }} /objects/devices/.*\"\n              [(ngModel)]=\"constraints.browsePathMatchesRegex\"\n              ngDefaultControl\n            />\n          </c8y-form-group>\n        </div>\n      </li>\n      <!-- Limit device type to servers with a certain fragment-->\n      <li class=\"list-group-item\">\n        <label class=\"c8y-checkbox\">\n          <input\n            type=\"checkbox\"\n            [checked]=\"constraints.serverObjectHasFragment.length > 0\"\n            (change)=\"\n              $event.target.checked ? (showServerFragment = true) : (showServerFragment = false)\n            \"\n          />\n          <span></span>\n          <strong class=\"m-l-8\" translate\n            >Limit device type to servers with a certain fragment</strong\n          >\n        </label>\n        <div\n          class=\"collapse\"\n          [isAnimated]=\"true\"\n          [collapse]=\"!showServerFragment && constraints.serverObjectHasFragment.length < 1\"\n        >\n          <c8y-form-group class=\"m-t-8 m-b-8\">\n            <input\n              name=\"serverFragment\"\n              type=\"text\"\n              class=\"form-control\"\n              placeholder=\"{{ 'e.g.' | translate }} c8y_SomeServerMarker\"\n              [(ngModel)]=\"constraints.serverObjectHasFragment\"\n              ngDefaultControl\n            />\n          </c8y-form-group>\n        </div>\n      </li>\n      <!-- Limit device type to a specific root node ID -->\n      <li class=\"list-group-item\">\n        <label class=\"c8y-checkbox\">\n          <input\n            type=\"checkbox\"\n            [checked]=\"constraints.matchesNodeIds.length > 0\"\n            (change)=\"onChangeNodeId($event)\"\n          />\n          <span></span>\n          <strong class=\"m-l-8\" translate>Limit device type to specific root nodes ID</strong>\n        </label>\n        <div\n          class=\"collapse\"\n          [isAnimated]=\"true\"\n          [collapse]=\"!showRootNodes && constraints.matchesNodeIds.length < 1\"\n        >\n          <c8y-form-group class=\"m-t-8 m-b-8\">\n            <ul c8yInputGroupListContainer class=\"list-unstyled\">\n              <li\n                class=\"m-b-8\"\n                *ngFor=\"let item of constraints.matchesNodeIds; let i = index; trackBy: trackByFn\"\n              >\n                <c8y-input-group-list [index]=\"i\" (onAdd)=\"add()\" (onRemove)=\"remove($event)\">\n                  <input\n                    type=\"text\"\n                    class=\"form-control\"\n                    placeholder=\"{{ 'e.g.' | translate }} nodeId\"\n                    [(ngModel)]=\"constraints.matchesNodeIds[i]\"\n                    [required]=\"true\"\n                  />\n                </c8y-input-group-list>\n              </li>\n            </ul>\n          </c8y-form-group>\n        </div>\n      </li>\n    </ul>\n  </div>\n</div>\n"
    })
], OpcuaAutoApplySettingsComponent);

var OpcuaDeviceProtocolBrowsePathValidation_1;
let OpcuaDeviceProtocolBrowsePathValidation = OpcuaDeviceProtocolBrowsePathValidation_1 = class OpcuaDeviceProtocolBrowsePathValidation {
    constructor(el) {
        this.el = el;
    }
    validate(control) {
        if (control.value) {
            if (!this.isValidJson(control.value)) {
                return { invalidBrowsePathNotation: true };
            }
            else {
                if (this.isBrowsePathUnique(control.value)) {
                    return { browsePathNotUnique: true };
                }
            }
        }
        return null;
    }
    isValidJson(value) {
        try {
            const browsePath = JSON.parse(value);
            return !isEmpty$1(browsePath);
        }
        catch (error) {
            return false;
        }
    }
    toArray(str) {
        return JSON.parse(str);
    }
    isBrowsePathUnique(value) {
        const mappings = this.getMappings();
        const found = some(mappings, item => {
            if (isEqual(item.browsePath, this.toArray(value)) && item.id !== this.model.id) {
                return item;
            }
        });
        return found ? true : false;
    }
};
OpcuaDeviceProtocolBrowsePathValidation.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input()
], OpcuaDeviceProtocolBrowsePathValidation.prototype, "getMappings", void 0);
__decorate([
    Input()
], OpcuaDeviceProtocolBrowsePathValidation.prototype, "model", void 0);
OpcuaDeviceProtocolBrowsePathValidation = OpcuaDeviceProtocolBrowsePathValidation_1 = __decorate([
    Directive({
        selector: '[c8yBrowsePathValidator][ngModel]',
        providers: [
            {
                provide: NG_VALIDATORS,
                useExisting: forwardRef(() => OpcuaDeviceProtocolBrowsePathValidation_1),
                multi: true
            }
        ]
    })
], OpcuaDeviceProtocolBrowsePathValidation);

const routes = [
    {
        context: ViewContext.Device,
        path: 'opcua-servers',
        component: OpcuaServersComponent,
        label: gettext('OPC UA server'),
        icon: 'server',
        canActivate: [OpcuaAgentGuard, OpcuaMicroserviceGuard]
    },
    {
        context: ViewContext.Device,
        path: 'address-space',
        component: OpcuaAddressSpaceComponent,
        label: gettext('Address space'),
        icon: 'sitemap',
        canActivate: [OpcuaServerGuard, OpcuaMicroserviceGuard]
    }
];
const deviceProtocolRoutes = [
    {
        path: 'deviceprotocols/opcuaV2/:id',
        component: OpcuaDeviceProtocolDetailComponent
    }
];
const 0 = routes;
let OpcuaProtocolModule = class OpcuaProtocolModule {
};
OpcuaProtocolModule = __decorate([
    NgModule({
        declarations: [
            OpcuaServersComponent,
            OpcuaServerListComponent,
            OpcuaServerConfigComponent,
            OpcuaAddressSpaceComponent,
            OpcuaAddressSpaceTreeComponent,
            OpcuaAddressSpaceDetailComponent,
            OpcuaDeviceProtocolDescription,
            OpcuaDeviceProtocolDetailComponent,
            OpcuaDeviceProtocolDataReportingComponent,
            OpcuaDeviceProtocolMapping,
            OpcuaDeviceProtocolObjectMapping,
            OpcuaDeviceProtocolMappingCustomAction,
            OpcuaDeviceProtocolObjectMappingStatus,
            OpcuaAutoApplySettingsComponent,
            OpcuaDeviceProtocolBrowsePathValidation
        ],
        imports: [
            CoreModule,
            FormsModule,
            ReactiveFormsModule,
            DropAreaModule,
            ButtonsModule,
            CdkTreeModule,
            RouterModule.forRoot(deviceProtocolRoutes, { useHash: true }),
            TooltipModule.forRoot(),
            PopoverModule.forRoot(),
            DeviceStatusModule,
            BrowserAnimationsModule,
            CollapseModule.forRoot(),
            BsDropdownModule.forRoot()
        ],
        entryComponents: [
            OpcuaAddressSpaceTreeComponent,
            OpcuaAddressSpaceComponent,
            OpcuaServersComponent
        ],
        providers: [
            OpcuaAgentGuard,
            OpcuaServerGuard,
            OpcuaMicroserviceGuard,
            OpcuaService,
            AddressSpaceService,
            {
                provide: HOOK_ONCE_ROUTE,
                useValue: 0,
                multi: true
            }
        ]
    })
], OpcuaProtocolModule);

const opcuaAddressSpaceTreeComponent = downgradeComponent({
    component: OpcuaAddressSpaceTreeComponent,
    inputs: ['moId'],
    outputs: ['selectedNode']
});

const NAME = 'c8y.upgrade.opcua';
const angularJsModule = module(NAME, [])
    .directive('c8yOpcuaAddressSpaceTree', opcuaAddressSpaceTreeComponent);
const ng1Modules = [NAME];
registerNgModule(ng1Modules);

/**
 * Generated bundle index. Do not edit.
 */

export { OpcuaAddressSpaceTreeComponent, OpcuaAutoApplySettingsComponent, OpcuaDeviceProtocolDetailComponent, OpcuaProtocolModule, OpcuaServersComponent, ng1Modules, 0, OpcuaService as a, OpcuaServerListComponent as b, OpcuaServerConfigComponent as c, OpcuaAddressSpaceComponent as d, AddressSpaceService as e, OpcuaAddressSpaceDetailComponent as f, OpcuaDeviceProtocolDescription as g, OpcuaDeviceProtocolMapping as h, OpcuaDeviceProtocolObjectMapping as i, OpcuaDeviceProtocolDataReportingComponent as j, OpcuaDeviceProtocolMappingCustomAction as k, OpcuaDeviceProtocolObjectMappingStatus as l, OpcuaDeviceProtocolBrowsePathValidation as m, OpcuaAgentGuard as n, OpcuaServerGuard as o, OpcuaMicroserviceGuard as p };
//# sourceMappingURL=c8y-ngx-components-protocol-opcua.js.map
