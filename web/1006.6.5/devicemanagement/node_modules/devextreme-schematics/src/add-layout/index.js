"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const dependencies_1 = require("@schematics/angular/utility/dependencies");
const rxjs_1 = require("rxjs");
const core_1 = require("@angular-devkit/core");
const path_1 = require("path");
const project_1 = require("../utility/project");
const string_1 = require("../utility/string");
const styles_1 = require("../utility/styles");
const modify_json_file_1 = require("../utility/modify-json-file");
const dependencies_2 = require("@schematics/angular/utility/dependencies");
const tasks_1 = require("@angular-devkit/schematics/tasks");
const source_1 = require("../utility/source");
const change_1 = require("../utility/change");
const routing_1 = require("../utility/routing");
const ast_utils_1 = require("@schematics/angular/utility/ast-utils");
const config_1 = require("@schematics/angular/utility/config");
const projectFilesSource = './files/src';
const workspaceFilesSource = './files';
const ngRequireStaticFlag = /^(\W*[8-9][0-9]*)/;
function addScriptSafe(scripts, name, value) {
    const currentValue = scripts[name];
    if (!currentValue) {
        scripts[name] = value;
        return;
    }
    const alterName = `origin-${name}`;
    const safeValue = `npm run ${alterName} && ${value}`;
    if (currentValue === value || currentValue === safeValue) {
        return;
    }
    scripts[alterName] = currentValue;
    scripts[name] = safeValue;
}
function addBuildThemeScript() {
    return (host) => {
        modify_json_file_1.modifyJSONFile(host, './package.json', config => {
            const scripts = config['scripts'];
            addScriptSafe(scripts, 'build-themes', 'devextreme build');
            addScriptSafe(scripts, 'postinstall', 'npm run build-themes');
            return config;
        });
        return host;
    };
}
function addCustomThemeStyles(options, sourcePath) {
    return (host) => {
        modify_json_file_1.modifyJSONFile(host, './angular.json', config => {
            const stylesList = [
                `${sourcePath}/dx-styles.scss`,
                `${sourcePath}/themes/generated/theme.additional.css`,
                `${sourcePath}/themes/generated/theme.base.css`,
                'node_modules/devextreme/dist/css/dx.common.css'
            ];
            return styles_1.addStylesToApp(host, options.project, config, stylesList);
        });
        return host;
    };
}
function updateBudgets(options) {
    return (host) => {
        modify_json_file_1.modifyJSONFile(host, './angular.json', config => {
            const projectName = project_1.getProjectName(host, options.project);
            const budgets = config.projects[projectName].architect.build.configurations.production.budgets;
            const budget = budgets.find((item) => item.type === 'initial');
            if (budget) {
                budget.maximumWarning = '4mb';
                budget.maximumError = '6mb';
            }
            return config;
        });
        return host;
    };
}
function addViewportToBody(sourcePath) {
    return (host) => {
        const indexPath = path_1.join(sourcePath, 'index.html');
        let indexContent = host.read(indexPath).toString();
        indexContent = indexContent.replace(/<body>/, '<body class="dx-viewport">');
        host.overwrite(indexPath, indexContent);
        return host;
    };
}
function modifyFileRule(path, callback) {
    return (host) => {
        const source = source_1.getSourceFile(host, path);
        if (!source) {
            return host;
        }
        const changes = callback(source);
        return change_1.applyChanges(host, changes, path);
    };
}
function updateAppModule(host, sourcePath) {
    const appModulePath = sourcePath + 'app.module.ts';
    const importSetter = (importName, path) => {
        return (source) => {
            return ast_utils_1.addImportToModule(source, appModulePath, importName, path);
        };
    };
    const providerSetter = (importName, path) => {
        return (source) => {
            return ast_utils_1.addProviderToModule(source, appModulePath, importName, path);
        };
    };
    const rules = [
        modifyFileRule(appModulePath, importSetter('SideNavOuterToolbarModule', './layouts')),
        modifyFileRule(appModulePath, importSetter('SideNavInnerToolbarModule', './layouts')),
        modifyFileRule(appModulePath, importSetter('SingleCardModule', './layouts')),
        modifyFileRule(appModulePath, importSetter('FooterModule', './shared/components')),
        modifyFileRule(appModulePath, importSetter('LoginFormModule', './shared/components')),
        modifyFileRule(appModulePath, providerSetter('AuthService', './shared/services')),
        modifyFileRule(appModulePath, providerSetter('ScreenService', './shared/services')),
        modifyFileRule(appModulePath, providerSetter('AppInfoService', './shared/services'))
    ];
    if (!hasRoutingModule(host, sourcePath)) {
        rules.push(modifyFileRule(appModulePath, importSetter('AppRoutingModule', './app-routing.module')));
    }
    return schematics_1.chain(rules);
}
function getComponentName(host, sourcePath) {
    let name = '';
    const index = 1;
    if (!host.exists(sourcePath + 'app.component.ts')) {
        name = 'app';
    }
    while (!name) {
        const componentName = `app${index}`;
        if (!host.exists(`${sourcePath}${componentName}.component.ts`)) {
            name = componentName;
        }
    }
    return name;
}
function hasRoutingModule(host, sourcePath) {
    return host.exists(sourcePath + 'app-routing.module.ts');
}
function addPackagesToDependency() {
    return (host) => {
        dependencies_2.addPackageJsonDependency(host, {
            type: dependencies_2.NodeDependencyType.Default,
            name: '@angular/cdk',
            version: '^8.0.0'
        });
        return host;
    };
}
function modifyContentByTemplate(sourcePath, templateSourcePath, filePath, templateOptions = {}, modifyContent) {
    return (host, context) => {
        const modifyIfExists = (fileEntry) => {
            const fileEntryPath = path_1.join(sourcePath, fileEntry.path.toString());
            if (!host.exists(fileEntryPath)) {
                return fileEntry;
            }
            const templateContent = fileEntry.content.toString();
            let modifiedContent = templateContent;
            const currentContent = host.read(fileEntryPath).toString();
            if (modifyContent) {
                modifiedContent = modifyContent(templateContent, currentContent, fileEntryPath);
            }
            // NOTE: Workaround for https://github.com/angular/angular-cli/issues/11337
            if (modifiedContent !== currentContent) {
                host.overwrite(fileEntryPath, modifiedContent);
            }
            return null;
        };
        const rules = [
            schematics_1.filter(path => {
                return !filePath || path_1.join('./', path) === path_1.join('./', filePath);
            }),
            schematics_1.template(templateOptions),
            schematics_1.forEach(modifyIfExists),
            schematics_1.move(sourcePath)
        ];
        const modifiedSource = schematics_1.apply(schematics_1.url(templateSourcePath), rules);
        const resultRule = schematics_1.mergeWith(modifiedSource);
        return schematics_1.callRule(resultRule, rxjs_1.of(host), context);
    };
}
function updateDevextremeConfig(sourcePath) {
    const devextremeConfigPath = '/devextreme.json';
    const templateOptions = {
        engine: 'angular',
        sourcePath
    };
    const modifyConfig = (templateContent, currentContent) => {
        const oldConfig = JSON.parse(currentContent);
        const newConfig = JSON.parse(templateContent);
        [].push.apply(oldConfig.build.commands, newConfig.build.commands);
        return JSON.stringify(oldConfig, null, '   ');
    };
    return modifyContentByTemplate('./', workspaceFilesSource, devextremeConfigPath, templateOptions, modifyConfig);
}
const modifyRoutingModule = (host, routingModulePath) => {
    // TODO: Try to use the isolated host to generate the result string
    let source = source_1.getSourceFile(host, routingModulePath);
    const importChange = ast_utils_1.insertImport(source, routingModulePath, 'LoginFormComponent', './shared/components');
    const providerChanges = ast_utils_1.addProviderToModule(source, routingModulePath, 'AuthGuardService', './shared/services');
    change_1.applyChanges(host, [importChange, ...providerChanges], routingModulePath);
    source = source_1.getSourceFile(host, routingModulePath);
    const routes = routing_1.findRoutesInSource(source);
    if (!routing_1.hasComponentInRoutes(routes, 'login-form')) {
        const loginFormRoute = routing_1.getRoute('login-form');
        change_1.insertItemToArray(host, routingModulePath, routes, loginFormRoute);
    }
};
function default_1(options) {
    return (host) => {
        const project = project_1.getProjectName(host, options.project);
        const workspace = config_1.getWorkspace(host);
        const prefix = workspace.projects[project].prefix;
        const title = string_1.humanize(project);
        const appPath = project_1.getApplicationPath(host, project);
        const sourcePath = project_1.getSourceRootPath(host, project);
        const layout = options.layout;
        const override = options.resolveConflicts === 'override';
        const componentName = override ? 'app' : getComponentName(host, appPath);
        const pathToCss = sourcePath.replace(/\/?(\w)+\/?/g, '../');
        const ngVersion = dependencies_1.getPackageJsonDependency(host, '@angular/core').version;
        const templateOptions = {
            name: componentName,
            layout,
            title,
            strings: core_1.strings,
            path: pathToCss,
            prefix,
            // https://github.com/angular/angular/blob/master/CHANGELOG.md#800-2019-05-28
            requireStaticFlag: ngRequireStaticFlag.test(ngVersion)
        };
        const modifyContent = (templateContent, currentContent, filePath) => {
            if (path_1.basename(filePath) === 'styles.scss') {
                return `${currentContent}\n${templateContent}`;
            }
            if (path_1.basename(filePath) === 'app-routing.module.ts' && hasRoutingModule(host, appPath)) {
                modifyRoutingModule(host, filePath);
                return currentContent;
            }
            return templateContent;
        };
        const rules = [
            modifyContentByTemplate(sourcePath, projectFilesSource, null, templateOptions, modifyContent),
            updateDevextremeConfig(sourcePath),
            updateAppModule(host, appPath),
            addBuildThemeScript(),
            addCustomThemeStyles(options, sourcePath),
            addViewportToBody(sourcePath),
            addPackagesToDependency()
        ];
        if (options.updateBudgets) {
            rules.push(updateBudgets(options));
        }
        if (!options.skipInstall) {
            rules.push((_, context) => {
                context.addTask(new tasks_1.NodePackageInstallTask());
            });
        }
        if (override) {
            if (project === workspace.defaultProject) {
                rules.push(modifyContentByTemplate('./', workspaceFilesSource, 'e2e/src/app.e2e-spec.ts', { title }));
                rules.push(modifyContentByTemplate('./', workspaceFilesSource, 'e2e/src/app.po.ts'));
            }
        }
        return schematics_1.chain(rules);
    };
}
exports.default = default_1;
//# sourceMappingURL=index.js.map